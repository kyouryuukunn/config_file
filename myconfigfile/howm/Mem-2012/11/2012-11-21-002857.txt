= トランジション
ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
クイックスタート 
Ren'Py ランチャー 
簡素なゲーム 
キャラクター 
画像 
トランジション 
表示位置 
BGM と効果音 
ゲームの終了 
メニュー、ラベル、ジャンプ 
Python と if 文 
ゲームの公開 
The Question のスクリプト 
これから何をする？ 
前のトピックへ
Ren'Py のドキュメントにようこそ！

次のトピックへ
言語の基礎

Search
    
 powered by  

Created using Sphinx. 
クイックスタート¶
Ren'Py クイックスタートマニュアルにようこそ。このマニュアルでは、Ren'Py ゲームを簡単な手順でゼロから作る方法を説明します。そのために、簡単なゲーム The Question の作り方をお見せします。マニュアルで使用している例のいくつかは、このデモゲームの一部になっているものです。

Ren'Py ランチャー¶
ゲームの制作を始める前に、まず少し Ren'Py ランチャーの動作を知りましょう。ランチャーを使って Ren'Py プロジェクトの作成、管理、編集、実行ができます。

始めましょう。 まず、Ren'Py をダウンロード します。

Ren'Py をダウンロードしたら、それを解凍します。パッケージファイルを右クリックし、"展開" のオプションがあればそれを、そうでなければ "開く" を選べばいいはずです。プロンプトに従えば、Ren'Py のワーキングコピーが得られるでしょう。

ノート

Ren'Py は、必ずディスクのディレクトリやフォルダに展開してください。ZIP ファイルの中から実行しようとすると、適切に動きません。

Ren'Py を展開したら、実行してみましょう。

Windows では、renpy または renpy.exe プログラムを実行してください。 
Mac OS X では、renpy アプリケーションを実行してください。 
Linux では、renpy.sh スクリプトを実行してください。 
実行すると、Ren'Py ランチャーが動作するはずです。

 
プロジェクトを選択して起動します。 まずは、完成済みの The Question ゲームがどのようなものか見てみましょう。そのために、Ren'Py ランチャーを立ち上げ、Select Project を選んでください。プロジェクトのメニューが現れるので、その中から "the_question" を選んでください。するとメインメニューに戻り、"Launch" で The Question を始められます。

同じようにして "the_question" の代わりに "demo" を選べば、Ren'Py のデモに戻ることができます。

新しいプロジェクトを作成します。 ランチャーから "New Project" を選んで、新しいプロジェクトを作成します。ランチャーからテンプレートを選ぶように言われるので "template" を選んでください。次に、ランチャーにプロジェクト名を尋ねられます。"the_question" はすでに使われているので、"My Question" など別の名前を入力してください。それから、プロジェクトのカラーテーマを尋ねられます。ここでどれを選んでも問題ないので、気に入ったものを選んでください。すると、新しいゲームが選択された状態で Ren'Py ランチャーのトップメニューに戻ります。

簡素なゲーム¶
label start:
    "I'll ask her..."

    "Me" "Um... will you..."
    "Me" "Will you be my artist for a visual novel?"

    "Silence."
    "She is shocked, and then..."

    "Sylvie" "Sure, but what is a \"visual novel?\""

これは、Ren'Py のゲームの中で最も簡素なもののひとつでしょう。絵などは一切無く、二人のキャラクターの会話だけを表示します。

このゲームを試すには、ランチャーに入り、"My Question" プロジェクトに変更し、"Edit Script" を選んでください。これで、テキストエディタにスクリプトファイルが開きます。script.rpy を選び、そのファイルに書かれているすべてを消してください。ゼロから始めるので、この内容は必要ありません。上の例を script.rpy にコピーし、保存してください。

これで、この例を実行する準備が整いました。ランチャーに戻り、"Launch" をクリックしてください。Ren'Py が立ち上がり、単純にメニューだけを表示します。このメニューでゲームを開始またはロードしたり、様々な設定を変更できます。準備ができたら、"Start Game" をクリックして、例のゲームをひと通り遊んでみましょう。

この例は、Ren'Py のよく使われる文をいくつか使っています。

1 行目は label 文です。label 文は、プログラム内のある場所に名前を与えるのに使います。この例では、start という名前のラベルを作ります。start ラベルは、ユーザがメインメニューで "Start Game" をクリックしたときに Ren'Py のスクリプトが始まる場所となる、特別なラベルです。

残りの行は say 文です。say 文には 2 つの形式があります。第一の形式は、行に単独で置かれた文字列 (ダブルクオートで始まり、文字を含み、ダブルクオートで終わるもの) です。これは、ナレーションやメインキャラクターの思考に使われます。第二の形式は 2 つの文字列でできていて、前の文字列はキャラクターの名前で、後の文字列はそのキャラクターのセリフです。これは会話文に使われます。

なお、ここの say 文はすべて 4 つのスペースでインデントされています。この文は label 文の下にあるブロックだからです。Ren'Py では、ブロックは先行する文に対してインデントされていなければならず、ブロック内のすべての文は同じ量だけインデントされている必要があります。

文字列がダブルクオート文字を含むときは、そのダブルクオートにバックスラッシュを前置しなければなりません。これは上の例の最後の行で使われています。

この簡素なゲームは見栄えはしませんが、Ren'Py で動くものを作ることがいかに簡単か、という一例です。少ししたら画像を追加しますが、その前に、キャラクターを宣言する方法を見てみましょう。

キャラクター¶
最初の例では、キャラクターがしゃべる度にそのキャラクターの名前を繰り返し打たないといけないことが問題になります。会話の多いゲームだと、タイプ量が多くなります。また、キャラの名前がどちらも同じように、つまらない白い文字で表示されています。これを解決するために、Ren'Py ではキャラクターを先に定義しておくことができます。これにより、短い名前をキャラクターに関連付け、さらにキャラクター名の色を変えられます。

define s = Character('Sylvie', color="#c8ffc8")
define m = Character('Me', color="#c8c8ff")

label start:
    "I'll ask her..."

    m "Um... will you..."
    m "Will you be my artist for a visual novel?"

    "Silence."
    "She is shocked, and then..."

    s "Sure, but what is a \"visual novel?\""

1 行目と 2 行目は、キャラクターを定義しています。1 行目は、短い名前が "s"、長い名前が "Sylvie" で、キャラクター名が緑色で表示されるキャラクターを定義しています。(色は、web ページで使われているような、RGB の 16 進数です。) (訳注: このようにして定義されたものを、"s" という名前の キャラクターオブジェクト といいます。)

2 行目は、短い名前が "m"、長い名前が "Me" で、キャラクター名が赤色で表示されるキャラクターを作成しています。キャラクターの行の一方をコピーし、短い名前、長い名前、色を変えることで、他のキャラクターも定義できます。

また、say 文もキャラクター名文字列の代わりにキャラクターオブジェクトを使うように変更しました。これで Ren'Py は init ブロックで定義したキャラクターを使ってくれます。

画像¶
ビジュアルノベルは、画像がなければビジュアルノベルになりません。ゲームに画像を追加してみましょう。

image bg meadow = "meadow.jpg"
image bg uni = "uni.jpg"

image sylvie smile = "sylvie_smile.png"
image sylvie surprised = "sylvie_surprised.png"

define s = Character('Sylvie', color="#c8ffc8")
define m = Character('Me', color="#c8c8ff")

label start:
    scene bg meadow
    show sylvie smile

    "I'll ask her..."

    m "Um... will you..."
    m "Will you be my artist for a visual novel?"

    show sylvie surprised

    "Silence."
    "She is shocked, and then..."

    show sylvie smile

    s "Sure, but what is a \"visual novel?\""

まずは、init ブロックの内部で、2、3、5、6 行目にある image 文を使って、画像を宣言します。これらの image 文は、image 名と、その画像があるファイル名を与えます。

例えば 5 行目は、"sylvie smile" という名前で、ファイル名 "sylvie_smile.png" で見つかる画像を、"sylvie" というタグで定義しています。

12 行目にあるのは scene 文です。この文は画面を消去して "bg meadow" の画像を表示します。次の行は show 文で、"sylvie smile" の画像を画面に表示します。

画像名の最初の部分は画像のタグです。ある画像が表示されていて、同じタグを持つ別の画像がスクリーンに現れると、スクリーンの画像は新しい画像で置き換えられます。これは 19 行目の、2 番目の show 文で起きています。19 行目が実行される前は、"sylvie smile" がスクリーン上にあり、19 行目が実行されるとき、"sylvie" タグが同じなので、その画像が "sylvie surprised" で置き換えられます。

画像ファイルは、Ren'Py が見けるために、対象となるプロジェクトの game ディレクトリに置かなければなりません。game ディレクトリは "プロジェクト名/game/" にあり、ランチャーの "Game Directory" ボタンをクリックすれば表示できます。この例を実行できるように、"the_question/game/" ディレクトリから "my_question/game/" ディレクトリに画像をコピーしましょう。

Ren'Py は、キャラクター絵と背景絵を全く区別せず、画像として同じように扱います。一般に、キャラクター絵は透過が必要なので、PNG ファイルであるべきです。背景絵は JPEG や PNG ファイルにできます。慣例で、背景画像は "bg" タグで始めることになっています。

hide 文。 Ren'Py は、与えられた画像を隠す hide 文もサポートしています。

label leaving:

    s "I'll get right on it!"

    hide sylvie

    "..."

    m "That wasn't what I meant!"

実際には、hide はあまり使わないでしょう。キャラクターの表情が変わるときには show が使えますし、全員がいなくなるときは scene が使われます。hide が必要なのは、あるキャラクターがいなくなって、場面は変わらない時だけです。

トランジション¶
画像がただ現れたり消えたりするだけではつまらないので、Ren'Py は画面の変化を面白くするトランジションを実装しています。トランジションは画面を、前の対話 (会話、メニュー、トランジション) が終わった時点の見た目から、scene、show、hide 文の後の見た目に変えます。

label start:
    scene bg uni
    show sylvie smile

    s "Oh, hi, do we walk home together?"
    m "Yes..."
    "I said and my voice was already shaking."

    scene bg meadow
    with fade

    "We reached the meadows just outside our hometown."
    "Autumn was so beautiful here."
    "When we were children, we often played here."
    m "Hey... ummm..."

    show sylvie smile
    with dissolve

    "She turned to me and smiled."
    "I'll ask her..."
    m "Ummm... will you..."
    m "Will you be my artist for a visual novel?"

with 文は、使用するトランジションの名前を取ります (with に続けてトランジションの名前を書く必要があります)。よく使うものの一つは dissolve で、ある画面から次の画面に徐々に移行します。便利なトランジションには他に fade があり、一旦何もない画像にフェードアウトし、それから新しい画面にフェードインします。

トランジションは、複数の scene、show、hide 文の後に置かれたとき、そのすべてに同時に適用されます。こう書くと:

    scene bg meadow
    show sylvie smile
    with dissolve

"bg meadow" と "sylvie smiles" が同時にディゾルブします。一人づつディゾルブさせたいときは、2 つの with 文を書く必要があります:

    scene bg meadow
    with dissolve
    show sylvie smile
    with dissolve

まず meadow がディゾルブし、それから sylvie がディゾルブします。meadow を即座に表示し、それから sylvie をディゾルブさせたいなら、こう書けます:

    scene bg meadow
    with None
    show sylvie smile
    with dissolve

ここで、特殊なトランジションを指定するために None が使われています。これは、実際にユーザに何も見せることなく Ren'Py の以前のスクリーンの概念を更新します。

表示位置¶
デフォルトでは、画像は水平方向には中央に、そして画像の下端が画面の下端に重なるように表示されます。これは背景と一人のキャラクターでは十分ですが、画面に二人以上のキャラクターがいるときは別の位置にするべきです。また、ストーリー上キャラクターを移動させたい時もあります。

     show sylvie smile at right

この移動を行うには、show 文に at 節を加えます。at 節は、表示位置を取り、画像をその位置に表示します。Ren'Py は、表示位置を前もっていくつか定義しています: left はスクリーンの左側に、right は右側に、center は水平方向の中央 (デフォルト) に、そして truecenter は水平方向にも垂直方向にも中央に、それぞれ表示します。

ユーザは、独自の表示位置や複雑な動きを定義できますが、クイックスタートの範囲外になります。

BGM と効果音¶
ゲームでは、背景に音楽を流すことが多いです。Ren'Py では、音楽ファイルはユーザが止めるまで自動的にループされます。音楽は、play music 文で再生されます:

    play music "illurock.ogg"

音楽を変えるときは、fadeout 節を使うことができます。これは新しい音楽が再生されるとき、古い音楽をフェードアウトさせます:

    play music "illurock.ogg" fadeout 1.0

音楽は、stop music 文で停止できます。これも fadeout 節を取れます:

    stop music

効果音は、play sound 文で再生できます:

    play sound "effect.ogg"

Ren'Py は、多くのフォーマットの音声や音楽をサポートしていますが、OGG Vorbis がおすすめです。画像ファイルのように、音声や音楽ファイルは game ディレクトリに置かなければなりません。

ゲームの終了¶
何も呼び出していない状態で return 文を実行することで、ゲームを終了できます。その前に、ゲームが終わることを表す何か、例えばエンディング番号やエンディング名を伝えるのがいいです:

    ".:. Good Ending."

    return

選択肢のないゲーム、キネティックノベルを作るのに必要なことは以上です。それでは、ユーザにメニューを提示するのに必要なことを見てみましょう。

メニュー、ラベル、ジャンプ¶
menu 文で、ユーザに選択肢を提示できます:

    s "Sure, but what's a \"visual novel?\""

menu:
    "It's a story with pictures.":
         jump vn

    "It's a hentai game.":
         jump hentai

label vn:
    m "It's a story with pictures and music."
    jump marry

label hentai:
    m "Why it's a game with lots of sex."
    jump marry

label marry:
    scene black
    with dissolve

    "--- years later ---"

この例は、Ren'Py でメニューがどのように使われているかを表しています。menu 文に続けて、文字列の後にコロンを付けた行からなるブロックを書きます。この文字列は、ユーザに提示される menu の選択肢になります。menu のそれぞれの選択肢に続けて、一行以上の Ren'Py 文のブロックを書かなければなりません。ある選択肢が選ばれると、それに続く文が実行されます。

上の例では、menu のそれぞれの選択肢が jump 文を実行します。jump 文は、label 文で定義された label に制御を移します。そのラベルに続くコードが実行されます。

上の例では、Sylvie が質問した後、ユーザは 2 択の menu を提示されます。ユーザが "It's a story with pictures." を選ぶと、jump 文が起動し、vn ラベルに制御が移ります。これにより、主人公が "It's a story with pictures and music." と言い、それから制御が marry ラベルに移ります。

ラベルは、ゲームディレクトリの .rpy で終わるどのファイルでも定義できます。Ren'Py にとって重要なのはファイル名ではなく、その中に含まれているラベルだけです。一つのラベルは一つのファイルにのみ置けます。

Python と if 文¶
簡素なゲームは (それどころかかなり複雑なゲームでさえ) menu と jump 文だけで作れますが、それを超えるとユーザの選択を変数に保存して後で取り出すというようなことが必要になります。このために、Ren'Py は Python をサポートしています。

Python サポートは、2 種類の方法で利用できます。ドル記号で始まる行は単行の Python 文で、予約語 "python:" は Python 文のブロックを導入するのに使います。

Python によって、ユーザの入力に対応したフラグを保存するのが簡単になります。ゲームの最初にフラグの初期化だけはしておいてください:

label start:
    $ bl_game = False

そうすれば、コード内で menu で選択されたフラグを変更できます:

label hentai:

    $ bl_game = True

    m "Why it's a game with lots of sex."
    s "You mean, like a boy's love game?"
    s "I've always wanted to make one of those."
    s "I'll get right on it!"

    jump marry

そして、あとでこれを判定します:

"And so, we became a visual novel creating team."
"We made games and had a lot of fun making them."

if bl_game:
    "Well, apart from that boy's love game she insisted on making."

"And one day..."

もちろん、Python の変数は単なる True/False に限定されず、任意の Python の値にできます。変数はプレイヤー名の保存、得点の保存、その他のあらゆる目的に使えます。Ren'Py では Python プログラミング言語を完全に自由に使えるので、いろいろなことができます。

ゲームの公開¶
ゲームを作ったら、公開する前にいくつかやるべきことがあります:

options.rpy の編集。 
新しいゲームを作るときに生成された options.rpy ファイルには、カスタマイズのための設定事項があります。その中には、スクリーンの高さや幅など、ゲームを作る前に設定しておくべきこともあります。それ以外の、ウィンドウのタイトルなどは、好きなときに設定できます。 
Ren'Py の宣伝。 
これは全くの自由なのですが、ゲームにクレジットを入れるなら、その中に Ren'Py を入れていただけるよう、お願いします。"Made with the Ren'Py visual novel engine." などと書くことを提案しますが、実際にどう書くかはあなたにお任せします。

我々は、作成されたゲームこそが Ren'Py の最高の広告であると考えています。そして、クレジットに表記してもらうことで、Ren'Py でビジュアルノベルを作る方法を多くの人に知ってもらえれば嬉しいです。

Ren'Py の新バージョンの確認。 
Ren'Py は定期的にリリースされ、バグの修正や新機能の追加が行われます。新しいバージョンが出ていないか、download page を調べてみてください。このページから、バグ修正も確認できます。 
スクリプトの確認。 
ランチャーから、Tools ページに進み、"Check Script (Lint)" を選んでください。ユーザに影響するかもしれないようなエラーがないか確かめられます。これらのエラーは、Mac や Linux プラットフォームのユーザに影響するかもしれないので、あなたのコンピュータで見られなくても、これらをすべて修正しておくことは重要です。 
ディストリビューションのビルド。 
Tools ページから、distribute をクリックしてください。ランチャーがスクリプトをもう一度チェックし、いくつかの質問をし、そしてゲームのディストリビューションをビルドします。 
テスト。 
Lint は完全なテストの代わりにはなりません。ゲームをリリースする前にチェックするのはあなたの責任です。友達にゲームのベータテストを手伝ってもらえば、あなたが見つけられなかった問題をテスターが見つけてくれることも多いでしょう。 
公開。 
(Windows, Mac, Linux 用に) 生成されたファイルを web のどこかにアップロードし、ダウンロード出来る場所を知らせましょう。おめでとう、ゲームが公表されました！

リリースされたゲームは、ぜひ games database に登録してください。出来上がったゲームをこれで追跡できます。

The Question のスクリプト¶
''The Question'' の完全なスクリプトを ここ でご覧になれます。

これから何をする？¶
このクイックスタートは、Ren'Py でできることのほんの表面にしか触れていません。簡単のため、Ren'Py の多くの機能を省略しました。Ren'Py にできることを感じ取るには、デモをひと通りプレイするのがおすすめです。Eileen が機能を実演してくれます。

Ren'Py の決定的なガイドである、マニュアルの続き (の複雑な部分) に進むのもいいでしょう。

Ren'Py ウェブサイトには、よくある質問に答える FAQ や、便利なコード例を載せている Cookbook などがあります。質問があれば、Ren'Py の公式フォーラムである Lemma Soft Forums で質問するのがおすすめです。ここは Ren'Py コミュニティの中心になっていて、初心者やその質問を歓迎しています。

Ren'Py visual novel engine を選んでいただき、ありがとうございます。どんなゲームができるか、楽しみにしています！

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
言語の基礎 
ファイル 
コメント 
論理行 
インデンテーションとブロック 
文の要素 
共通の構文 
Python 式の構文 
前のトピックへ
クイックスタート

次のトピックへ
台詞とナレーション

Search
    
 powered by  

Created using Sphinx. 
言語の基礎¶
Ren'Py 言語について解説する前に、まず Ren'Py スクリプトの構造を解説します。ここでは、ファイルがどのように行でできたブロックに分けられ、その行がどのように文を構成する要素に分けられるかを説明します。

ファイル¶
Ren'Py ゲームのスクリプトは、game ディレクトリの .rpy 拡張子で終わるファイルでできています。Ren'Py はそのようなファイルを (Unicode 順に) 考慮し、そのファイルの内容をスクリプトとして扱います。

一般に、複数ファイルに分割したスクリプトも、単一の大きなファイルでできたスクリプトも同じです。他のファイルにあるラベルに jump したり、呼び出したりすることで、制御はファイル間を移ります。これにより、自分のやり方に合わせてスクリプトをファイルに分けられます。(イベントごとや、一日ごとの) 小さなファイルを好む人もいれば、大きなスクリプトを好む人もいるでしょう。

ロード時間を速くするために、Ren'Py は起動時に .rpy ファイルを .rpyc ファイルにコンパイルします。.rpy ファイルが変更されたとき、.rpyc ファイルは Ren'Py の起動時にアップデートされます。しかし、対応する .rpy がないような .rpyc ファイルが存在すると、その .rpyc ファイルが使われます。このため、.rpy ファイルを削除するときに .rpyc ファイルも削除しないと問題になりえます。

コメント¶
Ren'Py スクリプトファイルは、コメントを含むことができます。コメントは、ハッシュ記号 ('#') で始まり、コメントを含む行の終端で終わります。例のように、コメントは文字列の一部にはできません。

# This is a comment.
show black # this is also a comment.

Ren'Py はコメントを無視するので、スクリプトはコメントが無いかのように扱われます。

論理行¶
スクリプトは、論理行 に分けられます。論理行は必ずファイル内の行の最初で始まります。論理行は、以下に当てはまらない限り、行の最後で終わります:

行がバックスラッシュ ('') で終わるとき。 
行にある開き括弧文字 ('(', '{', または '[') のなかに、閉じ括弧文字 (それぞれ ')', '}', または ']') が対応していないものがあるとき。 
行の最後が文字列中にあるとき 
論理行が終わると、次の行の初めから次の論理行が始まります。

Ren'Py 言語のほとんどの文は一つの論理行でできていますが、中には複数の行でできている文もあります。

"This is one logical line"

"Since this line contains a string, it continues
 even when the line ends."

$ a = [ "Because of parenthesis, this line also",
        "spans more than one line." ]

空の論理行は無視されます。

インデンテーションとブロック¶
インデンテーション とは、各論理行の始めにあるスペースのことで、Ren'Py の文を整列するのに使われます。Ren'Py では、インデンテーションにはスペースのみを使わなければなりません。

インデンテーションは、文を ブロック にまとめるのに使われます。ブロックは行のまとまりで、多くは文のまとまりでもあります。ファイルをブロックに分ける規則は:

ファイルの先頭で、ブロックが一つ始まります。 
前の論理行より深くインデントされるごとに、新しいブロックが始まります。 
一つのブロック内のインデンテーションは、すべて同じでなければなりません。 
ブロックは、ブロックの各行よりも少ないインデンテーションの論理行があるときに終わります。 
Ren'Py ではインデンテーションが非常に重要で、正しくないと構文の、または論理のエラーを起こします。同時に、インデンテーションでブロック構造を伝えることで、スクリプトテキストを圧迫することなく構造を指示できます。

"This statement, and the if statement that follows, is part of a block."

if True:

    "But this statement is part of a new block."

    "This is also part of that new block."

"This is part of the first block, again."

文の要素¶
Ren'Py の文は、いくつかの基本的な部品でできています。

予約語 
予約語は、ソースコードに正確に書かなければならない単語です。予約語は文やプロパティを導入するのに使われます。 
名前 
名前は、文字またはアンダースコアで始まり、それにゼロ個以上の文字、数字、アンダースコアが続きます。ここでは、U+00a0 から U+fffd までの Unicode 文字が文字とみなされます。

一つのアンダースコアで始まる名前は、他に記述がない限り、Ren'Py 内部で使うために予約されています。__ で始まり、__ では終わらないとき、これはその名前のファイル特有のバージョンに変更されます。

画像名 
画像名 は、スペースで分けられた1 つ以上の名前でできています。画像名を構成する最初の部分は 画像タグ と呼ばれます。名前のそれ以降の部分は、画像属性 です。

例えば、mary beach night happy という画像名があるとします。この画像タグは mary で、画像属性は mary、beach、night です。

文字列 
クオート文字 (", ', ` のいずれか) で始まる文字列は、文字の並びを含み、同じクオート文字で終わります。

バックスラッシュ文字 () は、クオート、% (% と書く) および { ({ と書く) をエスケープするのに使います。また、n と並べて改行を含めるのにも使います。

Ren'Py 文字列の中で連続する空白は、そのスペースにバックスラッシュを前置しない限り、一つの空白文字にまとめられます:

'Strings can\'t contain their delimiter, unless you escape it.'

単純式 
単純式は Python 式で、Python を Ren'Py スクリプトの部品として含めるのに使います。単純式はこれらで始まります:

名前。 
文字列。 
数。 
括弧内のあらゆる Python 式。 
そしてこれらを任意の数だけ続けられます:

ドットとそれに続く名前。 
括弧に入れられた Python 式。 
例えば、3, (3 + 4), foo.bar, および foo(42) はすべて単純式です。しかし、文字列の終わりで式は途切れるので、3 + 4 は単純式ではありません。

式リスト 
式リストは、カンマで分けられた一連の単純式です。 
Python 式 
Python 式は任意の Python 式で、コロンを含むことはできません。これらは、if や while 文の条件に使われます。 
共通の構文¶
ほとんどの Ren'Py 文は構文が同じです。say 文を除き、文を導入する予約語で始まります。文がパラメタを取るなら、予約語の次に続きます。

パラメタの後には、一つ以上のプロパティが続きます。プロパティは好きな順序で与えられますが、それぞれのプロパティは一度しか与えられません。プロパティは予約語で始まります。ほとんどのプロパティでは、プロパティ名に上述の構文要素を続けます。

ブロックを取る文では、行はコロン (:) で終わります。そうでなければ、行は普通に終わります。

Python 式の構文¶
ノート

この節を今すぐ読み通す必要はないかもしれません。飛ばして先に進み、例を理解できなかったり、実際にどのように動いているかを理解したくなったりしたら、ここに戻ってきて見直すことができます。

Ren'Py は多くの部分で Python 式を取ります。例えば、新しいキャラクターを定義するときには、Character 関数を呼び出しています。Python 式は非常に強力ですが、普通の Ren'Py ゲームを書くのに必要なのはその力のほんの一部だけです。

Python 式の概要はこちらです。

整数 
整数は、小数点を持たない数です。3 や 42 は整数です。 
浮動小数点数 
浮動小数点数は、小数点を持つ数です。.5、7.、9.0 はすべて浮動小数点数です。 
文字列 
Python 文字列は、" または ' で始まり、同じ文字で終わります。終わりの文字をエスケープしたり、改行 (\n) などの特殊文字を導入するのにするのに \ が使われます。Ren'Py の文字列と違い、Python の文字列は行を跨げません。 
True, False, None 
特殊な値が 3 つあります。True は真値、False は偽値です。None は値がないことを表します。 
タプル 
タプルは、要素の数が重要なコンテナを表すのに使います。例えば、2-タプル (対とも呼ばれます) で幅と高さを表したり、4-タプル (x, y, width, height) で長方形を表したりできます。

タプルは左丸括弧 ( で始まり、カンマで分けられたゼロ個以上の Python 式からなり、右丸括弧 ) で終わります。1-タプルは特殊で、要素の次にカンマを置かなければなりません。例えば:

()
(1,)
(1, "#555")
(32, 24, 200, 100)

リスト 
リストは、要素の数が変わるコンテナを表すのに使います。リストは [ で始まり、カンマで分けられた一連の式を含み、] で終わります。例えば:

[ ]
[ 1 ]
[ 1, 2 ]
[ 1, 2, 3 ]

変数 
Python 式は変数を使って、define 文や Python 文を使って定義された値を保存できます。変数は文字またはアンダースコアで始まり、ゼロ個以上の文字、数字、アンダースコアが続きます。例えば:

name
love_love_points
trebuchet2_range

_ で始まる変数は Ren'Py で使用するために予約されているので、ユーザコードでは使うべきではありません。

フィールドアクセス 
Python のモジュールとオブジェクトはフィールドをもち、式にドットとフィールド名を続けることでアクセスできます。例えば:

config.screen_width

は、変数 (config) にフィールドアクセス (screen_width) を続けています。

呼び出し 
Python の式は、値を返す関数を呼び出せます。式 (通常は変数) で始まり、括弧で括られてカンマで分けられた引数リストが続きます。引数リストは、Python 式である位置引数で始まります。その後に、「引数名=式」という形式のキーワード引数が続きます。Character 関数を呼び出す例は:

Character("Eileen", type=adv, color="#0f0")

1 つの位置引数、文字列 "Eileen" が与えられています。2 つのキーワード引数、type に値 adv が、color に文字列値 "#0f0" が与えられています。

コンストラクタは新しいオブジェクトを返す関数の型で、同じように呼び出されます。

このドキュメントには、以下のような関数の表記があります:

Sample(name, delay, position=(0, 0), **properties)¶ 
ドキュメントにのみ使われていて、Ren'Py には実在しないサンプル関数です。

この関数は:

"Sample" という名前です。 
2 つの位置引数、name と delay を持ちます。実際の関数では、このパラメタの意味はドキュメントで解説されます。 
1 つのキーワード引数 position を持ち、そのデフォルト値は (0, 0) です。 
この関数は **properties で終わっているので、追加の引数として スタイルプロパティ を取ることができます。その他の項目として、任意の数の位置引数を取ることを表す *args や、ドキュメントで解説されているキーワード引数を取る **kwargs があります。

Python は、このマニュアルでは解説しきれないほど強力です。Python を詳しく知りたいなら、python.org (日本語版は こちら) の Python チュートリアルから始めるのがおすすめです。Ren'Py を使うには Python を深く知る必要はないと思いますが、Python の式について知っておくと便利です。

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
台詞とナレーション 
say 文 
Character オブジェクトの定義 
画像属性を伴う say 
キャラクターの例 
特殊なキャラクター 
前のトピックへ
言語の基礎

次のトピックへ
画像の表示

Search
    
 powered by  

Created using Sphinx. 
台詞とナレーション¶
テキストはビジュアルノベルの基本であり、物語を中心としたゲームにとってとても大切なものです。テキストには、それを話しているキャラクターで分類される台詞と、話し手のいないナレーションがあります。(簡単のため、特に分ける必要がない限り、台詞もナレーションも台詞で統一します。) また、台詞の見た目はゲームに合わせてユーザがカスタマイズできます。

Ren'Py では、ほとんどの台詞は say 文で書かれます。台詞の見た目は Character オブジェクトを使ってキャラクター毎にカスタマイズできます。

say 文¶
say 文は、台詞やナレーションに使われます。これは Ren'Py スクリプトで最も多く使われる文ですから、say 文の構文は最小限の負荷で書けます。say 文の例は:

    "This is narration."

    "Eileen" "This is dialogue, with an explicit character name."

    e "This is dialogue, using a character object instead."

say 文の最初の形式は、1 つの文字列だけでできています。この形式はナレーションに使われ、この文字列がナレーションの内容です。

第二の形式は、2 つの文字列でできています。最初の文字列は話者の名前で、二番目が話される台詞です。

最後の形式は、単純分とその後の文字列でできています。ここでの単純文は、キャラクター名を与える文字列または Character オブジェクトであるべきです。後者の場合、その Character オブジェクトが台詞の見た目を制御するのに使われます。

say 文の詳細な動作は使われる Character オブジェクトによって制御されますが、say 文は通常、台詞をスクリーンに表示し、ユーザがクリックしたら台詞をスクリーンから取り除きます。

文字の中には Ren'Py で特別な意味を持ち、それゆえ台詞の文字列で使えないものがあります。{ 文字はテキストタグを開始し、[ 文字は置換を開始します。これらを台詞中で使うには、2 つ重ねてください。また、クオートが文字列を閉じてしまうのを防ぐには、バックスラッシュを前置しなければなりません。例えば:

    "I walked past a sign saying, \"Let's give it 100%!\""

Character オブジェクトの定義¶
Character オブジェクトを作成し、これを say 文で使うことで、会話文の見た目 (と動作をある程度) を変更できます。キャラクターは、define 文を使って変数に Character を代入することで作成できます。例えば:

define e = Character("Eileen",
                     who_color="#c8ffc8")

これが済めば、そのキャラクターを say 文で使えます:

    e "Hello, world."

Character は Python 関数で、多くのキーワード引数を取ります。これらのキーワード引数は、キャラクターの動作を制御します。

Character(name, kind=adv, **args)¶ 
台詞やナレーションのルックアンドフィールを制御する、Character オブジェクトを作成して返します。

name 
文字列なら、台詞に使われるこのキャラクターの名前です。name が None なら、ナレーションのように、名前の表示は省略されます。 
kind 
このキャラクターの基になるキャラクターです。使われると、このキャラクターに与えられなかった全ての引数のデフォルト値は、kind に与えられた引数の値です。これはテンプレートキャラクターを定義して、そのキャラクターを変更してコピーするのに使われます。 
関連画像 キャラクターに画像タグを関連付けられます。これにより、そのキャラクターに関わる say 文でこのタグの画像を表示したり、そのキャラクターがしゃべるときに現れる横の画像を自動的に選んだりできます。

image 
このキャラクターに関連する画像タグを与える文字列です。 
接頭辞と接尾辞 これを使うと、キャラクター名と表示されるテキストには、接頭辞や接尾辞を適用できます。これは例えば、会話文のそれぞれの行をクオートで囲むのに使えます。

what_prefix 
会話文が表示される前に前置される文字列です。 
what_suffix 
会話文が表示される前に後置される文字列です。 
who_prefix 
キャラクター名が表示される前に前置される文字列です。 
who_suffix 
キャラクター名が表示される前に後置される文字列です。 
名前表示の変更 このオプションは、名前の表示を制御するのに役立ちます。

dynamic 
真なら、name は Python 式を含む文字列でなければなりません。この文字列は、台詞のそれぞれの行の前にこの文字列が評価され、その結果がキャラクター名として使われます。 
作用の制御 これらのオプションは、台詞が表示されるか、作用が行われるか、そして入ったモードが表示されるかを制御します。

condition 
与えられれば、これは Python 式を含む文字列でなければなりません。この式が偽なら、say 文が起こらなかったかのように、台詞は現れません。 
interact 
真なら、デフォルトで、台詞が表示される度に作用が行われます。偽なら、作用は行われず、スクリーンに要素を追加できます。 
mode 
このキャラクターがしゃべるときに入るモードを与える文字列です。詳しくは modes をご覧ください。 
callback 
キャラクターがしゃべっている間にイベントが起こるときに呼び出される関数です。詳しくは character callbacks をご覧ください。 
クリック待ち クリック待ち標識は、全てのテキストが表示された後に、ユーザに進んでもらうために表示される標識です。

ctc 
特殊な標識が使われないときにクリック待ち標識に使う Displayable です。 
ctc_pause 
テキストの表示が {p} や {w} テキストタグで停止されたときにクリック待ち標識に使う Displayable です。 
ctc_timedpause 
テキストの表示が {p=} や {w=} テキストタグで停止されたときにクリック待ち標識に使う Displayable です。None であれば、ctc_pause をデフォルトとするので、ctc_pause だけ使って ctc_timedpause は使わないときは、Null() を使ってください。 
ctc_position 
クリック待ち標識の位置を制御します。"nestled" なら、標識は表示されるテキストの一部として、最後の文字の直後に表示されます。"fixed" なら、標識はスクリーンに追加され、その位置は position スタイルプロパティで制御されます。 
スクリーン 台詞の表示には スクリーン を使います。これらの引数で、スクリーンを選んだり、スクリーンに引数を提供できます。

screen 
台詞を表示するのに使われるスクリーンの名前です。 
show_ で始まるキーワード引数は、接頭辞を剥ぎ取られ、スクリーンに引数として渡されます。例えば、show_side_image の値はスクリーンの side_image 変数の値になります。

便利な変数がデフォルトのスクリーンによって定義されています:

show_side_image 
Displayable が与えられると、台詞が表示されるときにその displayable が表示されます。displayable の位置は、位置プロパティで制御されます。これは主に、しゃべっているキャラクターを台詞の横に表示するのに使われます。 
show_two_window 
真なら、レイアウトの構成を変更し、キャラクター名が一つのウィンドウに、台詞がもう一つのウィンドウに表示されるようにします。 
テキストとウィンドウのスタイル who_, what_, および window_` で始まるキーワード引数は、接頭辞を剥ぎ取られ、それぞれキャラクター名、会話テキスト、その両方を含むウィンドウの スタイル になります。

例えば、キャラクターがキーワード引数 who_color="#c8ffc8" を与えられると、キャラクター名の色が変わり、この場合は緑になります。window_background="frame.png" で、キャラクターの台詞を含むウィンドウの背景を設定します。

キャラクター名、会話テキスト、ウィンドウに適用されたスタイルは、それぞれ who_style, what_style, および window_style を使い、この方法でも設定できます。

画像属性を伴う say¶
キャラクターが画像を伴って定義されたとき、そのキャラクターを含む say 文のキャラクター名と第二の文字列の間に画像属性を持たせられます。

この形式では、与えられたタグの画像が表示されていれば、Ren'Py はそのキャラクタータグと属性を含む show コマンドを発します。その画像が表示されていなければ、Ren'Py はその属性を横の画像で使うために保存しますが、画像の表示はしません。

例えば、このコード:

define e = Character("Eileen", image="eileen")

label start:

    show eileen mad
    e "I'm a little upset at you."

    e happy "But it's just a passing thing."

は、次のコードと等価です:

define e = Character("Eileen")

label start:

    show eileen mad
    e "I'm a little upset at you."

    show eileen happy
    e "But it's just a passing thing."

画像がこのように変更される度にトランジションを起こすには、config.say_attribute_transition をトランジションに設定してください。

キャラクターの例¶
キャラクターの例をいくつか挙げます:

# A character that has its dialogue enclosed in parenthesis.
define e = Character("Eileen", what_prefix='"', what_suffix='"')

# A character that pulls its name from a variable.
define p = Character("player_name", dynamic=True)

特殊なキャラクター¶
デフォルトでいくつかのキャラクター名が定義されていて、特定の状況で自動的に使われます。これらのキャラクターを意図的に再定義すれば Ren'Py の振る舞いを変えられますが、間違えて使ってしまうと問題になりえます。

adv 
Character によって使われるデフォルトのキャラクターの種類です。これは、画面に一度に一行ずつ表示されるようなキャラクターを設定します。 
nvl 
台詞が NVL-mode で、画面に一度に複数行表示されるようなキャラクターの種類です。 
narrator 
キャラクター名の無い say 文による、ナレーションを表示するのに使われるキャラクターです。 
name_only 
キャラクター名が文字列で与えられた台詞を表示するのに使われるキャラクターです。このキャラクターは与えられた名前の新しいキャラクターにコピーされ、台詞を表示するのにその新しいキャラクターが使われます。 
ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
画像の表示 
概念 
画像 
レイヤ 
image 文 
show 文 
scene 文 
hide 文 
with 文 
with None 
scene、show、hide 文の with 節 
前のトピックへ
台詞とナレーション

次のトピックへ
ゲーム内メニュー

Search
    
 powered by  

Created using Sphinx. 
画像の表示¶
ビジュアルノベルを定義する特徴は、その名が表すとおり、ビジュアルです。Ren'Py には、画像を制御する 4 つの文があります。また、画像が表示される順番を定義するモデルをもっています。これにより、ビジュアルノベルに適した方法で画像を表示できます。

画像に使える 4 つの文は:

image - 新しい画像を定義します。 
show - レイヤに画像を表示します。 
scene - レイヤを消去し、必要ならレイヤに画像を表示します。 
hide - レイヤからイメージを取り除きます。 
画像を急に変えるとユーザはびっくりするので、Ren'Py は with 文を用意しています。これにより、場面が変わるときに効果が適用されます。

概念¶
画像¶
画像は、show 文を使ってスクリーンに表示されるものです。画像は名前と displayable でできています。画像がレイヤに表示されるとき、その画像に対応する displayable がレイヤに表示されます。

画像名 は、スペースで区切られた 1 つ以上の名前でできています。画像名の最初の部分は 画像タグ と呼ばれます。名前のそれ以降の部分は 画像属性 です。

例えば、mary beach night happy という画像名があるとします。この画像タグは mary で、画像属性は beach, night, および happy です。

displayable とは、スクリーンに表示できるものです。主に静止画像を表示するのに使われます。これを指定するには、画像のファイル名を文字列として与えます。上述の例では、ファイル名として例えば "mary_beach_night_happy.png" を使います。しかし、画像は静止画像に限らず、Ren'Py がサポートする displayable全て を参照できます。ですから、画像を表示するのと同じ文が、アニメーション、全面色、その他の displayable にも使えます。

レイヤ¶
レイヤとは、スクリーンに表示される displayable のリストです。Ren'Py は複数のレイヤをサポートしていて、ユーザ定義のレイヤも使えます。レイヤの順序はゲーム内で固定されています (config.layers 変数で制御されます)。また、レイヤ内の displayable の順序は、scene 文や show 文が呼び出された順序と、その文に与えられたプロパティとで制御されます。

Ren'Py 内部では、以下のレイヤが定義されています:

master 
これは、scene 文、show 文、hide 文で使われるデフォルトのレイヤです。主に、背景やキャラクタースプライトに使われます。 
transient 
ui 関数で使われるデフォルトのレイヤです。このレイヤは、作用が終わる度に消去されます。 
screens 
このレイヤは、スクリーンシステムによって使われます。 
overlay 
ui 関数が overlay 関数の内部から呼び出されたときに使われる、デフォルトのレイヤです。このレイヤは、作用が再開する度に消去されます。 
その他のレイヤも定義できます。config.layers や、レイヤ関連のその他いろいろな設定変数をアップデートしてください。renpy.layer_at_list() を使うと、レイヤに変換を適用できます。

image 文¶
image 文は、画像を定義するのに使われます。image 文は、image で始まり、画像名、等号 (=)、displayable を続けた論理行でできています。例えば:

image eileen happy = "eileen_happy.png"
image black = "#000"
image bg tiled = LiveTile("tile.jpg")

image 文は、ゲームコードを実行する前に、初期化時に実行しなければなりません。image 文は init ブロックに含まれていないとき、優先度 0 の init ブロックの中に含まれているかのように、初期化時に実行されます。

image 文の ATL variant もご覧ください。

show 文¶
show 文は、画像をレイヤに表示するのに使われます。show 文は show で始まり、画像名、ゼロ個以上のプロパティが続く論理行でできています。

show 文に与えられたのが既存の画像の正確な名前なら、その画像が表示されます。そうでなければ、Ren'Py は以下のような画像を一つ探します:

show 文で指定されたのと同じタグを持つ 
show 文で与えられた全ての属性を持つ 
同じタグの画像がすでに表示されているなら、その画像と共通の属性を最も多く持つ 
そのような画像が一つに決まらなければ、例外が発生します。

レイヤ上に同じタグの画像がすでに表示されているなら、それを新しい画像が置き換えます。そうでなければ、その画像がレイヤの一番上に置かれます。(つまり、ユーザに最も近いところです。) この順序は、zorder および behind プロパティで変更できます。

show 文は、作用を起こしません。イメージを実際にユーザに表示するためには、作用を起こす文 (say, menu, pause, および with 文など) を実行しなければなりません。

show 文は、以下のプロパティを取ります:

as 
as プロパティは名前を取ります。画像が表示されるとき、画像タグの代わりにこの名前が使われます。これで、同じ画像をスクリーンに二度表示できます。 
at 
このプロパティは、カンマで区切られた一つ以上の単純式を取ります。それぞれの式の評価は、変換でなければなりません。この画像に、その変換が左から順に適用されます。

at 節が与えられなければ、Ren'Py は画像に適用されている変換を全て保持します。変換が存在しなければ、画像は default 変換を使って表示されます。

behind 
カンマで区切られた一つ以上の名前を取ります。それぞれの名前は画像タグとして取られます。画像は、現在表示されている画像の中で、与えられたタグを持つもの全ての後に表示されます。 
onlayer 
名前を取ります。指名されたレイヤに画像を表示します。 
zorder 
整数を取ります。この整数は、画像のレイヤ上における相対的な順序を指定します。この数字が大きいほど、ユーザに近くなります。これは通常 Ren'Py コードでは使いませんが、他のエンジンからコードを移植するときに便利です。 
以下の画像を定義したとします:

image mary night happy = "mary_night_happy.png"
image mary night sad = "mary_night_sad.png"
image moon = "moon.png"

show 文の例は:

# Basic show
show mary night sad

# Since 'mary night happy' is showing, the following statement is
# equivalent to:
# show mary night happy
show mary happy

# Show an image on the right side of the screen.
show mary night happy at right

# Show the same image twice.
show mary night sad as mary2 at left

# Show an image behind another.
show moon behind mary, mary2

# Show an image on a user-defined layer.
show moon on user_layer

show expression show 文の変種として、画像名の代わりに予約語 expression を使い、その後に単純式を続けるものがあります。この式の評価は、displayable でなければなりません。その displayable がレイヤに表示されます。この displayable を hide するためには、この文でタグを与えておかなければなりません。

例えば:

show expression "moon.png" as moon

scene 文¶
scene 文はレイヤから全ての displayable を削除し、その後、そのレイヤに画像を表示します。この文は、予約語 scene、画像名、ゼロ個以上のプロパティの順でできています。画像は、show 文と同じように表示されます。また、scene 文は show 文と同じプロパティを取ります。

scene 文は、主に背景レイヤに画像を表示するのに使います。例えば:

scene bg beach

scene expression show 文と同様、scene 文も画像名の代わりに式を取れます。

レイヤの消去 画像名が全く与えられないとき、scene 文はレイヤから全ての displayable を消去し、代わりの画像は表示しません。

hide 文¶
hide 文は、レイヤから画像を取り除きます。この文は、予約語 hide、画像名、ゼロ個以上のプロパティの順でできています。hide 文は画像名から画像タグを取り、そのタグを持つ画像がレイヤにあれば、その画像を隠します。

hide 文が必要になることは余りありません。あるスプライトがあるキャラクターを表しているなら、hide 文が必要なのはそのキャラクターがシーンから退場する時だけです。キャラクターが表情を変えるときは、show 文を使うのが望ましいです。show 文は、同じタグの画像を自動的に置き換えてくれます。

hide 文は、以下のプロパティを取ります:

onlayer 
名前を取ります。指名されたレイヤから画像を隠します。 
例えば:

e "I'm out of here."

hide eileen

こうは書かずに:

hide eileen
show eileen happy

こう書いてください:

show eileen happy

with 文¶
with 文は、シーンが変わるときに使われます。トランジション効果を適用して、画像の表示や非表示を緩やかにします。with 文は、予約語 with と、それに続く評価がトランジションか特殊値 None である単純式でできています。

トランジション効果は、前の作用 (会話、メニュー、トランジション) が終わった時点のスクリーンの内容と、scene、show、hide 文が実行された後の内容の間で適用されます。

with 文は、作用を起こします。作用の時間幅はユーザが制御できますし、ユーザが早く終わらせることもできます。

利用できるトランジションの一覧は、トランジション の章をご覧ください。

with 文の例は:

show bg washington
with dissolve

show eileen happy at left
show lucy mad at right
with dissolve

これは、2 つのトランジションを行います。最初の with 文は、dissolve トランジションを使い、スクリーンを washington 背景に変えます。(dissolve トランジションは、デフォルトで、0.5 秒のディゾルブと定義されています。)

第二のトランジションは、Eileen と Lucy の画像を表示する文の後にあります。これにより、背景のみの場面から、3 つ全ての画像がある場面にディゾルブします。結果として、2 つの新しい画像がディゾルブして現れます。

with None¶
上述の例には、2 つのディゾルブがあります。しかし、背景は即座に現れ、その後に 2 人のキャラが現れるようにするにはどうするのでしょうか？最初の with 文を単純になくしてしまうと、3 つの画像すべてがディゾルブして現れてしまいます。背景が即座に現れるようにしたいです。

with 文は、特殊な値 None を与えると、動作が変わります。with None 文は、ユーザに表示するものを変えない、省略された作用を起こします。次のトランジションは、この省略された作用が終わった時点で表示されている場面から始まります。

例えば、コード中で:

show bg washington
with None

show eileen happy at left
show lucy mad at right
with dissolve

washington 背景から、3 つの画像が表示されている場面に、一度だけトランジションが起こります。

scene、show、hide 文の with 節¶
show、scene、hide 文は、必要なら with 節を取れます。これは、画像の表示や非表示に、トランジションを組み合せます。

with 節をつけることは、with None 文を前に、with 文 を後に置くことと同等です:

show eileen happy at left with dissolve
show lucy mad at right with dissolve

は、これと同じです:

with None
show eileen happy at left
with dissolve

with None
show lucy mad at right
with dissolve


ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 前のトピックへ
画像の表示

次のトピックへ
テキスト

Search
    
 powered by  

Created using Sphinx. 
ゲーム内メニュー¶
ビジュアルノベルには、プレイヤーに物語の行方を左右するような選択を迫るものがたくさんあります。Ren'Py 言語の menu 文で、ユーザに選択肢を簡単に提示できます。

ここに menu 文の例を挙げます:

menu:
     "What should I do?"

     "Drink coffee.":
         "I drink the coffee, and it's good to the last drop."

     "Drink tea.":
         $ drank_tea = True

         "I drink the tea, trying not to make a political statement as I do."

     "Genuflect.":
         jump genuflect_ending

label after_menu:

     "After having my drink, I got on with my morning."

menu 文は、予約語 menu で始まります。これにラベル名を続けると、先行するそのラベルのメニューと同じになります。例えば:

menu drink_menu:
    ...

menu 文には、インデントされたブロックを続けます。このブロックには say 文 を書くことができ、また menu 選択肢を書かなければなりません。say 文があれば、menu と同時にそれがスクリーンに表示されます。

menu 選択肢 menu 選択肢は、ユーザがゲーム内メニューから選べる項目です。menu 選択肢は、文字列で始まります。その文字列に if 節を続けると、それを選択肢の条件にできます。menu 選択肢はコロンで終わり、Ren'Py 文のブロックを続けなければなりません。

選択肢が選ばれると、コードの対応するブロックが実行されます。コードのこのブロックが最後まで実行されると、menu 文が終わった後にある文に実行が続きます。

if 節は、予約語 if で始まり、Python 式が続きます。その式が真であるときのみ対応する menu 選択肢が表示されます。以下の menu で:

menu:
    "Go left.":
        ...
    "Go right.":
        ...
    "Fly above." if drank_tea:
        ...

第三の選択肢は、drank_tea 変数が真であるときのみ提示されます。

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
テキスト 
エスケープ文字 
データの補完 
スタイリングとテキストタグ 
全体のテキストタグ 
台詞のテキストタグ 
ユーザ定義のテキストタグ 
英語以外の言語 
ルビテキスト 
フォント 
画像ベースのフォント 
テキスト displayable 
低速テキストについて 
翻訳 
翻訳ファイルの作成 
テキストオーバーフローのロギング 
前のトピックへ
ゲーム内メニュー

次のトピックへ
displayable

Search
    
 powered by  

Created using Sphinx. 
テキスト¶
Ren'Py でテキストを表示する方法はいくつかあります。ユーザにテキストを表示する方法としてまず考えられるのは say や menu です。text, textbutton, および label スクリーン言語文を使ってユーザインタフェースにテキストを表示することがよくあります。これらやその他の関数は、Text() displayable を作成し、これをスクリーンに表示します。

テキスト displayable の役割は、ユーザにテキストを表示する工程を管理することです。テキスト displayable は、以下の順序にそって処理されます:

テキストを翻訳する。 
データをテキストに補完する。 
スタイルとテキストタグを使ってテキストの体裁を整える。 
整えられたテキストをレイアウトする。 
テキストをスクリーンに描画する。 
この章では、Ren'Py のテキスト表示に焦点を当てます。

エスケープ文字¶
Ren'Py のテキスト表示を制御する文字が 3 つあります。クリエータはこれらの文字がエンジンに誤解釈されないよう気をつける必要があります。

(バックスラッシュ) 
バックスラッシュ文字は、Ren'Py の、または Python の文字列を書くときに導入するのに使われます。よく使うエスケープコードは:

\" (バックスラッシュ-ダブルクオート) 
ダブルクオートで囲まれた文字列にダブルクオートを含めます。 
\' (バックスラッシュ-クオート) 
シングルクオートで囲まれた文字列にシングルクオートを含めます。 
\ (バックスラッシュ-スペース) 
Ren'Py の文字列にスペースを含めます。デフォルトでは、Ren'Py スクリプトテキストは、連続する空白は一つのスペース文字に折りたたまれます。 
\n (バックスラッシュ-n) 
テキストに改行文字を含めます。 
\\ (バックスラッシュ-バックスラッシュ) 
テキストにバックスラッシュ文字を含めます。 
[ (左角括弧) 
左角括弧は、テキストへの値の補完を導入するのに使われます。テキストに左角括弧自体を含めるには、二重にして、[[ と書いてください。 
{ (左波括弧) 
左角括弧は、テキストタグを導入するのに使われます。テキストに左波括弧自体を含めるには、二重にして、{{ と書いてください。 
データの補完¶
Ren'Py では、テキスト文字列が表示される前にデータを補完できます。例えば、プレイヤー名が playername 変数に保存されているとすると、台詞をこのように書けます:

g "Welcome to the Nekomimi Institute, [playername]!"

Ren'Py は、グローバルに保存されている変数を補完します。スクリーンでテキストウィジェットを使っているときは、Ren'Py はスクリーンのローカル変数も補完します。(テキスト displayable にスコープ引数を明示的に与えることで、これをオーバーライドできます。)

Ren'Py の補完は単なる変数に限りません。フィールドやタプルの要素も補完できます。ですから、以下のコードも書けます:

g "My first name is [player.names[0]]."

数を表示するときには、フォーマット化コードを適用できます。このコードは、浮動小数点数を小数第 2 位まで表示します:

$ percent = 100.0 * points / max_points
g "I like you [percent:.2] percent!"

Ren'Py の文字列補完は、PEP 3101 文字列フォーマット化構文を引き継いでいます。Ren'Py では { をテキストタグに使うので、文字列フォーマット化に [ を使います。

Python でサポートされている !s や !r 変換フラグに加え、Ren'Py は !q 変換フラグをサポートしています。The !q conversion flag ensures that text tags are properly quoted, so that displaying a string will not introduce unwanted formatting constructs. 例えば:

g "Don't pull a fast one on me, [playername!q]."

スタイリングとテキストタグ¶
Ren'Py でテキストにスタイル情報を与える方法は 2 つあります。1 つめは、テキストのブロック全体に適用されるスタイルを使う方法です。詳細は スタイルシステム の章、特に テキストスタイルプロパティ の節を参照してください。

2 つ目は、テキストタグを使う方法です。テキストタグは、テキストブロックの一部をスタイル化するのに向いています。行ごとに同じテキストタグを適用しているようなら、代わりにスタイルの使用を考えてください。

ここにテキストタグが 2 つあります。テキストタグには、自動的に閉じるものと、閉じタグが必要なものがあります。複数の閉じタグが使われたときは、最後に開かれたものが最初に閉じられる順になります。Ren'Py は、不適切なネストを却下します。例えば:

# This line is correct.
"Plain {b}Bold {i}Bold-Italic{/i} Bold{/b} Plain"

# This line is incorrect, and will cause an error or incorrect
# behavior.
"Plain {b}Bold {i}Bold-Italic{/b} Italic{/i} Plain"

テキストタグには、引数を取るものがあります。この場合、タグ名に等号 (=)、引数が続きます。引数には右波括弧文字 (}) を含められません。引数の意味は、テキストタグによって変わります。

全体のテキストタグ¶
以下のタグはテキスト全体に適用されます:

a¶ 
アンカータグは、自身からその閉じタグまでの間にハイパーリンクを作成します。ハイパーリンクの働きは hyperlink_functions スタイルプロパティで制御でき、デフォルトのハンドラは以下のように働きます。

ハイパーリンクは、style.hyperlink_text スタイルを使ってレンダされます。 
引数がテキスト "http://" で始まるなら、それをクリックすると、その url が web ブラウザで開かれます。そうでなければ、引数はラベルとして解釈され、新しいコンテキストで呼び出されます。これにより、ハイパーリンクを用語の定義に使えます。 
ハイパーリンクがホバーされたとき、スタイルが変わる以外に特別な動作はありません。 
label test:

    e "Why don't you visit {a=http://renpy.org}Ren'Py's home page{/a}?"

    e "The {a=define_trebuchet}trebuchet{/a} is at the gates."

    return

label define_trebuchet:

    e "A trebuchet is a kind of siege engine."
    e "It uses a lever to fling things at targets."
    e "Like us!"

    return

b¶ 
ボールドタグは、自身からその閉じタグまでの間をボールドフォントでレンダします。

"An example of {b}bold test{/b}."

color¶ 
カラーテキストタグは、自身からその閉じタグまでの間を指定された色でレンダします。色は #rgb, #rgba, #rrggbb, または #rrggbbaa の形式にしてください。

"{color=#f00}Red{/color}, {color=#00ff00}Green{color}, {color=#0000ffff}Blue{/color}"

cps¶ 
秒あたり文字数タグは、自身からその閉じタグまでの間のテキストにおける、テキスト表示の速度を設定します。引数がアスタリスクで始まっていたら、それが現在のテキスト速度に乗ぜられます。そうでなければ、テキストを表示する速度を秒あたりの文字数で与えます。

"{cps=20}Fixed Speed{/cps} {cps=*2}Double Speed{/cps}

font¶ 
フォントタグは、自身からその閉じタグまでの間を指定されたフォントでレンダします。引数は、使用するフォントのファイル名です。

"Try out the {font=mikachan.ttf}mikachan font{/font}."

i¶ 
イタリックタグは、自身からその閉じタグまでの間をイタリック体でレンダします。

"Visit the {i}leaning tower of Pisa{/i}."

k¶ 
カーニングタグは、自身からその閉じタグまでの間の文字のカーニングを調整します。これは浮動小数点数の引数を取り、それが各カーニングペアに加えられるカーニングのピクセル数を与えます。(負数にしてカーニングを減ずることもできます。)

"{k=-.5}Negative{/k} Normal {k=.5}Positive{/k}"

image¶ 
イメージタグは、テキストに画像を挿入する自己終了タグです。画像はテキスト一行の高さであるべきです。引数は画像のファイル名または、image 文で定義された画像でなければなりません。

g "Good to see you! {image=heart.png}"

s¶ 
打ち消し線タグは、自身からその閉じタグまでの間のテキストに打ち消し線を引きます。

g "It's good {s}to see you{/s}."

rb¶ 
ルビ下部タグは、自身からその閉じタグまでの間のテキストをルビをふる対象としてマークします。詳細は ルビテキスト の節をご覧ください。

rt¶ 
ルビ上部タグは、自身からその閉じタグまでの間のテキストをルビの内容としてマークします。詳細は ルビテキスト の節をご覧ください。

size¶ 
サイズタグは、自身からその閉じタグまでの間のテキストの大きさを変更します。引数は整数で、+ か - を前置できます。引数が整数だけなら、その大きさに設定されます。そうでなければ、大きさが指定された分だけ増減されます。

"{size=+10}Bigger{/size} {size=-10}Smaller{/size} {size=24}24 px{/size}."
space¶ 
スペースタグは、テキストに水平スペースを挿入する自己終了タグです。引数として、追加されるスペースのピクセル数を与える整数を取ります。

"Before the space.{space=30}After the space."

u¶ 
下線タグは、自身からその閉じタグまでの間のテキストに下線を引きます。

g "It's good to {u}see{/u} you."

vspace¶ 
スペースタグは、テキストの行間に水平スペースを挿入する自己終了タグです。引数として、追加されるスペースのピクセル数を与える整数を取ります。

"Line 1{vspace=30}Line 2"

台詞のテキストタグ¶
台詞にのみ適用されるテキストタグは:

fast¶ 
テキストの行内で急速タグが表示されると、遅いテキストモードであっても、その前にあるテキストがすべて即座に表示されます。

g "Looks like they're{nw}"
show trebuchet
g "Looks like they're{fast} playing with their trebuchet again."

nw¶ 
ノーウェイトタグは、現在の行が最後まで表示されきった時点で台詞を自動的に消し去る自己終了タグです。

g "Looks like they're{nw}"
show trebuchet
g "Looks like they're{fast} playing with their trebuchet again."

p¶ 
段落ポーズタグは自己終了タグです。これは現在の段落を終了し、ユーザがクリックで継続するのを待ちます。引数を与えられると、その引数が数として解釈され、それだけの時間が経過すると自動的に待ちが終了します。

"Line 1{p}Line 2{p=1.0}Line 3"

w¶ 
段落ポーズタグは自己終了タグです。これはユーザがクリックで継続するのを待ちます。引数を与えられると、その引数が数として解釈され、それだけの時間が経過すると自動的に待ちが終了します。

"Line 1{w} Line 1{w=1.0} Line 1"

ユーザ定義のテキストタグ¶
Ren'Py はユーザ定義のテキストタグもサポートしています。ユーザ定義のテキストタグは、タグ名が空であるようなテキストタグです。この場合、引数はスタイルの名前として取られます。このタグからその閉じタグまでの間のテキストは、スタイルで定義されている以下のプロパティを設定されます。

antialias 
font 
size 
bold 
italic 
underline 
strikethrough 
color 
black_color 
kerning 
英語以外の言語¶
Ren'Py のデフォルトフォントには、英語やその他多くの文字が含まれています。容量の都合から、中国語、日本語、朝鮮語などに必要な文字は含まれていません。あるプロジェクトでこれらの言語をサポートするためには、まずデフォルトのフォントを以下のようなコードを使って変更しなければなりません:

init python:
    style.default.font = "mikachan.ttf"

これだけの設定で、Ren'Py は世界の殆どの言語をサポートするでしょう。しかし、朝鮮語は分かち書きをするかしないかを選べます。Ren'Py には朝鮮語の分かち書きをサポートする特別なモードがあり、このコードで有効にできます:

init python:
     style.default.language = "korean-with-spaces"

最後に、表意文字の言語には改行が多いです。高速な改行アルゴリズムを有効にするには、このコードを使ってください:

init python:
     style.default.layout = "greedy"

高速な改行アルゴリズムは、NVL モードのような莫大な量のテキストを表示するゲームでなければ必要有りません。

ルビテキスト¶
ルビテキスト (ふりがな表記とも言います) は、文字や単語の上に小さなテキストを配置する方法です。貴方のゲームでルビテキストをサポートするために必要な手順があります。

まずは、ルビテキストのスタイルを設定します。以下のスタイル変更が必要です:

ルビテキストに十分な垂直スペースを残すために、line_leading プロパティを使います。 
新しく名前をつけたスタイルを作ります。このスタイルの size などのプロパティは、ルビテキストに合うように設定します。 
yoffset を設定し、ルビテキストがベースラインの上に来るようにします。 
テキストのスタイルの ruby_style フィールドを、新しく作成されたスタイルに設定します。 
例えば:

init python:
    style.default.line_leading = 12

    style.ruby_style = Style(style.default)
    style.ruby_style.size = 12
    style.ruby_style.yoffset = -20

    style.default.ruby_style = style.ruby_style

Ren'Py の設定が済めば、rt と rb を使ってルビテキストを使えます。rt タグは、文字がルビテキストとして表示されるようにマークします。ルビテキストの前に rb タグで囲まれたテキストがあると、ルビはその上で中央寄せされます。そうでなければ、前の一文字の上で中央寄せされます。

例えば:

e "Ruby can be used for furigana (東{rt}とう{/rt} 京{rt}きょう{/rt})."

e "It's also used for translations ({rb}東京{/rb}{rt}Tokyo{/rt})."

クリエータは、ルビテキストがテキストの境界を超えないようにしなければなりません。そのようなエラーが起こらないように、先頭や左右に文字間のスペースを開ける必要があるかもしれません。

フォント¶
Ren'Py は Truetype と画像ベースのフォントをサポートしています。

Truetype フォントは、フォントファイルの名前を与えることで指定できます。ファイルは game ディレクトリにあるか、アーカイブファイルのひとつでなければなりません。

Ren'Py は、複数のフォントを定義している Truetype コレクションもサポートしています。コレクションにアクセスするときは、0 ベースのフォントインデクス、アットマーク、そしてファイル名の順に使ってください。例えば、"0@font.ttc" がコレクションの最初のフォントなら、次は "1@font.ttc"、などとなります。

config.font_replacement_map 変数は、フォントを対応付けるのに使われます。フォントのファイル名、ボールド体、イタリック体の組合せが、同じような組合せに対応付けられます。これにより、自動的に生成されたイタリック体の代わりに適切なイタリック体にできます。

このようなマッピングによって Deja Vu Sans font のイタリック版を公式の斜体版に置き換えると (web で斜体版をダウンロードする必要があります。)

init python:
    config.font_replacement_map["DejaVuSans.ttf", False, True] = ("DejaVuSans-Oblique.ttf", False, False)

このマッピングでイタリックテキストの見た目が向上します。

画像ベースのフォント¶
画像ベースのフォントは、以下の登録関数の何れかを呼び出すことで登録できます。画像ベースのフォントの登録には、名前、大きさ、ボールド体、イタリック体、下線付きを指定する必要があります。これらすべてのプロパティが登録されたフォントに合致するとき、登録されたフォントが使われます。

renpy.register_bmfont(name=None, size=None, bold=False, italics=False, underline=False, filename=None)¶ 
これは、与えられた詳細の BMFont を登録します。なお、size, bold, italic, および underline はすべて (マッチングに使われる) 助言的なものであり、フォントの外見を変えるものではありません。

BMFont home page をご覧ください。Ren'Py は、filename パラメタが BMFont テキストフォーマットのファイルであることを期待し、それは 32-bit フォントを記述するものでなければなりません。アルファチャンネルは、フォント情報を含まなければならず、それに Red, Green, および Blue チャンネルが設定されます。

Ren'Py の全てのインタフェースが確実にレンダできるように、BMFont にはラテン文字と一般的な句読点を含めることを推奨します。

name 
登録するフォントの名前で、文字列です。 
size 
登録するフォントのサイズで、整数です。 
bold 
登録するフォントがボールド体であるかどうかで、ブール値です。 
italics 
登録するフォントがイタリック体であるかどうかで、ブール値です。 
underline 
このパラメタは無視されます。 
filename 
BMFont 制御情報を含むファイルです。 
renpy.register_mudgefont(name=None, size=None, bold=False, italics=False, underline=False, filename=None, xml=None, spacewidth=10, default_kern=0, kerns={})¶ 
これは、与えられた詳細の MudgeFont を登録します。なお、size, bold, italic, および underline はすべて (マッチングに使われる) 助言的なものであり、フォントの外見を変えるものではありません。

MudgeFonts を作成するツールについては、MudgeFont home page をご覧ください。Ren'Py は、MudgeFont xml ファイルに見つかった文字コードが Unicode 文字番号であると推測し、負の文字コードを無視します。

name 
登録するフォントの名前で、文字列です。 
size 
登録するフォントのサイズで、整数です。 
bold 
登録するフォントがボールド体であるかどうかで、ブール値です。 
italics 
登録するフォントがイタリック体であるかどうかで、ブール値です。 
underline 
このパラメタは無視されます。 
filename 
MudgeFont イメージを含むファイルで、文字列です。このイメージは通常 TGA ファイルですが、PNG その他の Ren'Py がサポートするフォーマットにもできます。 
xml 
MudgeFont ツールによって生成された情報を含む xml ファイルです。 
spacewidth 
空白文字の幅で、整数のピクセル数です。 
default_kern 
文字間のデフォルトのカーニング間隔で、ピクセル数です。 
kerns 
二文字の文字列から、その文字間に使われるカーニング間隔へのマッピングです。 
renpy.register_sfont(name=None, size=None, bold=False, italics=False, underline=False, filename=None, spacewidth=10, default_kern=0, kerns={}, charset=u'!"#$%&'()*+, -./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~')¶ 
これは、与えられた詳細の SFont を登録します。なお、size, bold, italic, および underline はすべて (マッチングに使われる) 助言的なものであり、フォントの外見を変えるものではありません。

More information about SFont.

name 
登録するフォントの名前で、文字列です。 
size 
登録するフォントのサイズで、整数です。 
bold 
登録するフォントがボールド体であるかどうかで、ブール値です。 
italics 
登録するフォントがイタリック体であるかどうかで、ブール値です。 
underline 
このパラメタは無視されます。 
filename 
SFont イメージを含むファイルで、文字列です。 
spacewidth 
空白文字の幅で、整数のピクセル数です。 
default_kern 
文字間のデフォルトのカーニング間隔で、ピクセル数です。 
kerns 
二文字の文字列から、その文字間に使われるカーニング間隔へのマッピングです。

このフォントの文字セットです。文字を画像に現れる順に並べた文字列です。SFont のデフォルトの文字セットは:

! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _
` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~

BMFont は Ren'Py がサポートしている 3 つの画像フォントの中で最も完成されているので、新しいプロジェクトにはこれを使うことをお勧めします。BMFont を使う例は:

init python:
    renpy.register_bmfont("bmfont", 22, filename="bmfont.fnt")

define ebf = Character('Eileen', what_font="bmfont", what_size=22)

label demo_bmfont:

    ebf "Finally, Ren'Py supports BMFonts."

テキスト displayable¶
テキストは displayable としても使えます。これによりテキストに変換を適用し、画像であるかのように変換してスクリーン周りに移動させられます。

Text(text, slow=None, scope=None, substitute=None, slow_done=None, **properties)¶ 
テキストをスクリーンに表示する displayable です。

text 
スクリーンに表示するテキストです。これは文字列か、文字列や displayable のリストにできます。 
slow 
テキストの表示を低速にして一文字づつ打ち出されるようにするかを決定します。None であれば、低速テキストモードは slow_cps スタイルプロパティによって決定されます。そうでなければ、低速テキストモードを使用するかはこのパラメタの真理値によって決定されます。 
scope 
None でなければ、これは辞書でなくてはならず、テキスト補間が行われる追加のスコープを提供します。 
substitute 
真なら、テキスト補間が行われます。偽なら行われません。None なら、config.new_substitutions で制御されます。 
低速テキストについて¶
Ren'Py では、クリエータやユーザがテキストの表示を低速にできます。この場合、Ren'Py はテキストをテクスチャにレンダし、そのテクスチャからスクリーンに長方形を描画します。

残念ながらこれにより、文字が重複するときにレンダが乱れることがあります。このレンダの乱れを最小限にするためには、line_leading および line_spacing を十分大きくとり、行が重複しないようにしてください。最初の行の文字の下部が切り捨てられている、特に line_spacing が負であるなら、line_overlap_split を増やすことも考えてください。

隣り合う文字が出っ張っているときは水平方向の乱れもありえますが、その乱れはフレームひとつにしか存在しないため、あまり深刻ではありません。

menu やその他のユーザインタフェースなどのテキストのような、静的なテキストには問題になりません。

翻訳¶
Ren'Py は、テキストの自動的な翻訳をサポートしています。テキストが表示されるごとに、テキストが補間される前に翻訳が行われます。

Ren'Py は .rpt から翻訳を読み込みます。.rpt ファイルは、以下の文字で始まる行を含むテキストファイルです:

# 
ハッシュマークで始まる行はコメント行で、無視されます。 
< 
小なり記号にスペースを続けて始まる行は、翻訳ソース行となり、翻訳されるべき文字列を与えます。 
> 
大なり記号にスペースを続けて始まる行は、翻訳行となり、前の翻訳ソースを翻訳したもの与えます。 
翻訳行では、改行記号は \n でエスケープされ、バックスラッシュは \\ でエスケープされます。

デフォルトでは、translations.rpt というファイルが存在すれば、Ren'Py はそこから翻訳を読み込みます。Language() 操作で使われる翻訳ファイルを変更できます。

翻訳ファイルの作成¶
Ren'Py は、自動的な翻訳ファイルの作成をサポートしています。これを利用するには 3 つの手順が必要です。

game ディレクトリに translations.rpt などの空の翻訳ファイルを作ります。 
RENPY_UPDATE_TRANSLATIONS 環境変数を空でない文字列に設定してください。 
すべてのテキストを見るまでゲームを通してプレイします。 
Ren'Py は、表示されたテキストの単位ごとに翻訳ファイルのエントリを追加します。これで、そのテキストを翻訳できます。

テキストオーバーフローのロギング¶
Ren'Py は、テキストが割り当てられた領域の外に出た事例のログを取れます。テキストオーバーフローのロギングを有効にするには、以下の手順が必要です。

config.debug_text_overflow 変数を真に設定します。 
xmaximum および ymaximum スタイルプロパティをテキスト displayable またはそれを含むコンテナに設定します。 
ゲームを起動します。 
テキストが表示されて利用できる領域からあふれるごとに、Ren'Py はエラーのログを text_overflow.txt に取ります。

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
displayable 
画像 
画像風 displayable 
動的 displayable 
displayable への変換の適用 
レイアウトボックス 
効果 
画像マニピュレータ 
im.MatrixColor 
前のトピックへ
テキスト

次のトピックへ
変換 (transform)

Search
    
 powered by  

Created using Sphinx. 
displayable¶
displayable は、ユーザに表示されるオブジェクトです。Ren'Py の displayable には多くの用途があります。

image 文を使って画像に代入する。 
スクリーン言語の add 文を使ってスクリーンに追加する 
設定変数に代入する。 
スタイルプロパティに代入する。 
displayable を受け取る Ren'Py の関数や変数には、以下の 4 つを与えられます:

以下の関数のいずれかを呼び出すことで作成された Displayable 型のオブジェクト。 
ドット (.) を含む文字列。このような文字列は Image() によってファイル名として解釈されます。 
単色。単色は文字列かタプルとして与えます。文字列は "#rgb", "#rgba", "#rrggbb", または "#rrggbbaa" の形式の 16 進数です。タプルは (r, g, b, a) で、それぞれが 0 から 255 までの整数です。単色は Solid() に渡されます。 
画像名。それ以外の文字列は image 文で定義された画像への参照として解釈されます。 
画像¶
最もよく使われる displayable は画像です。画像はディスクからファイルを読み込んで表示します。画像はよく使われるので、displayable を待つコンテキストでファイル名を与える文字列が使われると、画像が自動的に作成されます。画像を直接使う必要があるのは、スタイルプロパティから画像を作成したいときだけです。

Image(filename, **properties)¶ 
ファイルから画像をロードします。filename はファイル名を与える文字列です。

filename は適切な拡張子の JPEG または PNG ファイルでなくてはなりません。

# These two lines are equivalent.
image logo = "logo.png"
image logo = Image("logo.png")

# Using Image allows us to specify a default positon as part of
# an image.
image logo right = Image("logo.png", xalign=1.0)

画像をディスク上のファイルからロードし、それをスクリーンに描画できるようにデコードするのには時間がかかります。10 から 100 分の数秒ほどになるので、ロード処理の所要時間は許容できるフレームレートに収まらず、ユーザをいらいらさせます。

画像のサイズは一定で、また画像は入力やゲームの状態、利用できる空間の大きさに応じては変わりません。ですから必要になる前に画像を読み込み、画像キャッシュと呼ばれるメモリ空間に配置できます。画像をキャッシュにデコードしておけば、スクリーンに素早く描画できます。

Ren'Py は、将来使われる画像を予想し、実際に使われる前にロードしようとします。キャッシュの空間を他の画像に使う必要ができたとき、Ren'Py は使われなくなった画像を消去します。

デフォルトでは、Ren'Py は前もって最大画像データ 8 スクリーン分だけキャッシュします。(スクリーンが 800x600 なら、そのスクリーンは 800x600 の画像 1 枚、400x600 の画像 2 枚、などのデータに相当します。) これは config.image_cache_size 設定変数で変更できます。

経験上、画像キャッシュはピクセルあたりメインメモリ 4 バイトとビデオメモリ 4 バイトを消費します。ただし、正確な量は実装によって、または無視できないオーバーヘッドがあるかどうかによって異なります。

画像風 displayable¶
これらは長方形の領域で、入力に反応しないので、displayable を画像風であると呼びます。これらは普通の画像と異なり、領域を満たすように大きさを変えたり (Frame, LiveTile, および Solid)、ユーザが大きさを指定できたり (LiveComposite, LiveCrop, Null) します。画像ではこのような操作はできません。

画像風 displayable は Position Style Properties を取ります。

Frame(image, xborder, yborder, tile=False, **properties)¶ 
境界の幅と高さを保ちながら、利用できる領域を満たすようにリサイズする displayable です。ウィンドウやボタンの背景によく使われます。

 
フレームを使って画像のサイズを倍にします。

image 
このフレームによって大きさを変えられる画像マニピュレータです。 
left 
左側の境界のサイズです。 
top 
上側の境界のサイズです。 
right 
右側の境界のサイズです。None なら、デフォルトでは left です。 
bottom 
下側の境界のサイズです。None なら、デフォルトでは top です。 
tile 
真なら、画像の一部をリサイズするのにスケーリングではなくタイリングが使われます。 
# Resize the background of the text window if it's too small.
init python:
    style.window.background = Frame("frame.png", 10, 10)

LiveCrop(rect, child, **properties)¶ 
child を rect に刈りこんで displayable を作成します。ここで rect は (x, y, width, height) タプルです。

image eileen cropped = LiveCrop((0, 0, 300, 300), "eileen happy")

LiveTile(child, style='tile', **properties)¶ 
この displayable に割り当てられた領域まで child をタイル張りします。

image bg tile = LiveTile("bg.png")

Null(width=0, height=0, **properties)¶ 
スクリーン上に空のボックスを作成する displayable です。このボックスの大きさは width と height で制御できます。これは、displayable が子を要求しているが適切な子が無いときや、ボックス内のスペーサーとして使えます。

image logo spaced = HBox("logo.png", Null(width=100), "logo.png")

Solid(color, **properties)¶ 
割り当てられた領域を color で満たす displayable です。

image white = Solid("#fff")

動的 displayable¶
動的 displayable は、ゲームの状態に基づいて子 displayable を表示します。このレイアウトは自身が返す子 displayable のプロパティで制御されるので、これらはプロパティを取りません。

ConditionSwitch(*args, **kwargs)¶ 
これは、Python 条件式に基づいて表示するものを変える displayable です。位置引数は、これらを二つ一組にまとめて与えなければなりません:

Python 式を含む文字列 
条件式が真の時に使う displayable 
最初に真になった条件式の displayable が表示され、少なくとも一つの条件式が真にならなければなりません。

image jill = ConditionSwitch(
    "jill_beers > 4", "jill_drunk.png",
    "True", "jill_sober.png")

DynamicDisplayable(function, *args, **kwargs)¶ 
対話が起こったとき、Python 関数に基づいて子を変える displayable です。

function 
これらの引数を渡して呼び出される関数です:

displayable が表示される時間。 
同じタグの displayable が表示される時間。 
DynamicDisplayable に提供する任意の位置引数とキーワード引数。 
これは (d, redraw) タプルを返すべきです。ここで:

d は表示する displayable です。 
redraw は、関数を再び呼び出すまでに待つ時間です。None にすると、次の対話が始まるまでもうこの関数は呼び出されません。 
function は、対話が始まるごとに呼び出されます。

特別に、function は評価が displayable である Python 文字列にもできます。その場合、関数は対話ごとに一度実行されます。

# If tooltip is not empty, shows it in a text. Otherwise,
# show Null. Checks every tenth of a second to see if the
# tooltip has been updated.
init python:
     def show_tooltip(st, at):
         if tooltip:
             return tooltip, .1
         else:
             return Null()

image tooltipper = DynamicDisplayable(show_tooltip)

ShowingSwitch(*args, **kwargs)¶ 
これは、スクリーンに表示されている画像に基づいて表示する画像を変える displayable です。位置引数は、これらを二つ一組にまとめて与えなければなりません:

画像名を与える文字列。または、デフォルトを表す None 
条件式が死んである時に使われる displayable。 
デフォルトの画像は指定されなければなりません。

ShowingSwitch の使い方の一つは、キャラクターの現在の表情に応じてサイドイメージを変えることです。例えば:

define e = Character("Eileen",
    show_side_image=ShowingSwitch(
        "eileen happy", Image("eileen_happy_side.png", xalign=1.0, yalign=1.0),
        "eileen vhappy", Image("eileen_vhappy_side.png", xalign=1.0, yalign=1.0),
        None, Image("eileen_happy_default.png", xalign=1.0, yalign=1.0),
        )
    )

displayable への変換の適用¶
At 関数は、1 つの displayable と 1 つ以上の 変換 とから、displayable を作成します。

At(d, *args)¶ 
与えられた displayable d に args のそれぞれの変換を適用します。変換は左から右へ順に適用され、最後になされる変換は最も右側の引数です。

transform birds_transform:
     xpos -200
     linear 10 xpos 800
     pause 20
     repeat

image birds = At("birds.png", birds_transform)

レイアウトボックス¶
レイアウトボックスは、その子 displayable をスクリーンにレイアウトする displayable です。子 displayable を、水平や垂直に並べたり、一定の配置法でレイアウトしたりできます。

ボックス displayable は、任意の数の位置引数とキーワードを取ります。位置引数はボックスに子として加えられる displayable となります。キーワード引数はボックスに適用されるスタイルプロパティです。

ボックスは Position Style Properties と Box Style Properties を取ります。

Fixed(*args, **properties)¶ 
スクリーンを満たすボックスです。このメンバは奥から手前に並べられ、この位置は位置プロパティで制御されます。

HBox(*args, **properties)¶ 
ボックスで、このメンバは左から右へ並べられます。

VBox(*args, **properties)¶ 
ボックスで、このメンバは上から下へ並べられます。

# Display two logos, to the left and right of each other.
image logo hbox = HBox("logo.png", "logo.png")

# Display two logos, one on top of the other.
image logo vbox = VBox("logo.png", "logo.png")

# Display two logos. Since both default to the upper-left
# corner of the screen, we need to use Image to place
# those logos on the screen.
image logo fixed = Fixed(
    Image("logo.png", xalign=0.0, yalign=0.0),
    Image("logo.png", xalign=1.0, yalign=1.0))

効果¶
これらの displayable は、特定の視覚効果を作成するのに使われます。

AlphaBlend(control, old, new, alpha=False)¶ 
このトランジションは、ある displayable から別の displayable へのトランジションに control displayable を使います。そのトランジションが評価されます。変換が不透明なときは new displayable が使われ、変換が透明なときは old displayable が使われます。

alpha 
真であれば、画像は背後のものと合成されます。デフォルトの偽であれば、画像は不透明で背後のものを上書きします。 
画像マニピュレータ¶
画像マニピュレータは、画像や画像マニピュレータを取る displayable で、それらに演算を行い、演算結果を画像キャッシュに保存します。画像マニピュレータは画像と同じように予測できるので、表示時間のオーバーヘッドなしに高価な演算を実行できます。

画像マニピュレータは、キャッシュに画像データを保存するだけです。よって、結果は一定の大きさになり、事前に知ることができ、ゲームの状態や入力によっては変化しません。一般に、画像マニピュレータは画像や別の画像マニピュレータしか取れません。

画像マニピュレータは displayable が使える所ならどこででも使えますが、その逆はできません。Image() は画像マニピュレータの一種なので、Image は画像マニピュレータが要求されたときはいつでも使えます。

多くの画像マニピュレータは、他の displayable と同じ機能を提供します。これらのほとんどは、他の画像マニピュレータへの入力として渡せるので、ゲームメーカーはキャッシュメモリの使用かレンダ時になされる動作を選べます。また、歴史的な事故によって存在するものもあります。これらの画像マニピュレータのほとんどと等価なものが後で作られています。

im.AlphaMask(base, mask, **properties)¶ 
画像マニピュレータで、base と mask 2 つの画像マニピュレータを引数として取ります。

これは、二枚目の画像のアルファチャンネルを適用するのに使います。一枚目の jpeg を色データに、二枚目をアルファデータにといった具合にします。2 枚の jpeg の方が 1 枚の png ファイルよりも容量が小さいことがあります。

im.Composite(size, *args, **properties)¶ 
この画像マニピュレータは、複数の画像を合成して一つの画像にします。

size は (width, height) タプルで、合成された画像のサイズを与えます。

その他の位置引数は、(x, y) タプルと画像マニピュレータの二つ一組で解釈されます。画像マニピュレータによって生産された画像は、タプルで与えられた位置に合成されます。

image girl clothed happy = im.Composite(
    (300, 600)
    (0, 0), "girl_body.png",
    (0, 0), "girl_clothes.png",
    (100, 100), "girl_happy.png"
    )

im.Crop(im, rect)¶ 
画像マニピュレータ im から (x, y, width, height) タプル rect を刈りこむ画像マニピュレータです。

image logo crop = im.Crop("logo.png", (0, 0, 100, 307))

im.FactorScale(im, width, height=None, bilinear=True, **properties)¶ 
別の画像マニピュレータ im の大きさを調整し、幅を width 倍、高さを height 倍にする画像マニピュレータです。height を省略すると、デフォルトで width になります。

bilinear が真なら、大きさの調整に双線形補間が使われます。そうでなければ、近隣補間が使われます。

image logo doubled = im.FactorScale("logo.png", 1.5)

im.Flip(im, horizontal=False, vertical=False, **properties)¶ 
im (画像マニピュレータ) を水平または垂直に裏返す画像マニピュレータです。vertical および horizontal で画像が裏返される方向を制御します。

image eileen flip = im.Flip("eileen_happy.png", vertical=True)

im.Grayscale(im, **properties)¶ 
画像マニピュレータ im の彩度をなくした版を作成する画像マニピュレータです。

im.Scale(im, width, height, bilinear=True, **properties)¶ 
im (画像マニピュレータ) の大きさを width と height に調整する画像マニピュレータです。

bilinear が真なら、大きさの調整に双線形補間が使われます。そうでなければ、近隣補間が使われます。

image logo scale = im.Scale("logo.png", 100, 150)

im.Sepia(im, **properties)¶ 
画像マニピュレータ im のセピアトーン版を作成する画像マニピュレータです。

im.Tile(im, size=None, **properties)¶ 
画像マニピュレータ im を size になるまでタイル張りする画像マニピュレータです。

size 
None でなければ、(width, height) タプルです。None であれば、デフォルトで (config.screen_width, config.screen_height) になります。 
im.MatrixColor¶
im.MatrixColor 画像マニピュレータは、画像の色の変換を行列で指定する画像マニピュレータです。使われる行列は im.matrix オブジェクトです。im.matrix オブジェクトは 5x5 行列をオブジェクトにエンコードし、行列操作をサポートし、一連の関数によって返されます。im.matrix オブジェクトを掛け合わせて、両方の演算を行う一つのオブジェクトを得られます。例えば、このコードは:

image city blue = im.MatrixColor(
    "city.jpg",
    im.matrix.desaturate() * im.matrix.tint(0.9, 0.9, 1.0))

まず画像の彩度をなくし、それから青く染めます。中間の画像が必要ないときは、im.MatrixColors を二度使うよりも行列を掛け合わせましょう。そのほうが時間上も画像キャッシュ領域上も遥かに効率的です。

im.MatrixColor(im, matrix, **properties)¶ 
matrix を使って画像マニピュレータ im を線形に変換する画像マニピュレータです。

matrix は、20 または 25 要素のリスト、タプル、または im.matrix() にしてください。オブジェクトに 25 要素あれば、20 番目よりあとは無視されます。

ソースカラーの 4 つの構成要素が R, G, B, および A でそれぞれの範囲が 0.0 から 1.0、変換された後の色の 4 つの構成要素が R', G', B', および A' で同じ範囲、そして行列の要素が以下のように名付けられるとすると:

[ a, b, c, d, e,
  f, g, h, i, j,
  k, l, m, n, o,
  p, q, r, s, t ]

変換先の色は以下の公式で計算されます:

R' = (a * R) + (b * G) + (c * B) + (d * A) + e
G' = (f * R) + (g * G) + (h * B) + (i * A) + j
B' = (k * R) + (l * G) + (m * B) + (n * A) + o
A' = (p * R) + (q * G) + (r * B) + (s * A) + t

変換先の色の構成要素は範囲 [0.0, 1.0] に固定されます。

im.matrix()¶ 
matrix から im.matrix オブジェクトを構成します。im.matrix オブジェクトがサポートする演算は、行列乗算、スカラー乗算、要素ごとの加算、要素ごとの減算です。これらの演算は、標準の数学演算子 (それぞれ *, *, +, および -) を使って呼び出されます。二つの im.matrix オブジェクトを乗じると行列乗算が行われ、そうでなければスカラー乗算が使われます。

matrix は 20 または 25 要素のリストまたはタプルです。これが 20 要素なら、乗算をしやすいように (0, 0, 0, 0, 1) が付け足され、5x5 の行列になります。

im.matrix.brightness(b)¶ 
画像の輝度を変える im.matrix を返します。

b 
画像の輝度を変化させる量です。これは -1 から 1 でなければならず、-1 は可能な中で最も暗い画像で、1 は最も明るい画像です。 
im.matrix.colorize(black_color, white_color)¶ 
白黒の画像に着色する im.matrix を返します。black_color および white_color は Ren'Py スタイルの色で、文字列か (0-255) の明度値のタプルかで指定できます。

# This makes black colors red, and white colors blue.
image logo colored = im.MatrixColor(
    "bwlogo.png",
    im.matrix.colorize("#f00", "#00f"))

im.matrix.contrast(c)¶ 
画像のコントラストを変化させる im.matrix を返します。c は 0.0 より大きく、0.0 から 1.0 の値はコントラストを下げ、1.0 より大きい値はコントラストを上げます。

im.matrix.desaturate()¶ 
画像の彩度を無くす (グレースケールにする) im.matrix を返します。これは、im.matrix.saturation(0) を呼び出すのと等価です。

im.matrix.hue(h)¶ 
高度を変えずに色相を h 度循環させる im.matrix を返します。

im.matrix.identity()¶ 
色やアルファ値を変えない恒等行列を返します。

im.matrix.invert()¶ 
アルファ値を変えずに赤、緑、青のチャンネルを反転させる im.matrix を返します。

im.matrix.opacity(o)¶ 
画像の不透明度を変更する im.matrix を返します。o は 0.0 で完全に透明、1.0 で完全に不透明になります。

im.matrix.saturation(level, desat=(0.2126, 0.7152, 0.0722))¶ 
画像の彩度を変える im.matrix を返します。アルファチャンネルはそのままです。

level 
変更後の画像の彩度です。1.0 はそのままの画像で、0.0 はグレースケールです。 
desat 
これは 3 要素のタプルで、赤、緑、青チャンネルが完全に彩度を無くされた 3 つのチャンネルにどれだけ置かれるかを制御します。デフォルトは、NTSC テレビジョンシグナルの輝度チャンネルに使われる定数に基づきます。人間の目は緑に一番敏感なので、緑チャンネルは他の 2 つのチャンネルよりも多く残されます。 
im.matrix.tint(r, g, b)¶ 
画像のアルファチャンネルはそのままで色合いをつける im.matrix を返します。r, g, および b は 0 から 1 の数で、与えられたチャンネルのうちの最終的な画像に置かれる割合を制御します。(例えば、r が .5 で、赤チャンネルの値が 100 なら、変換された後の色の赤値は 50 になります。)

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
変換 (transform) 
デフォルトの変換 
クリエータ定義の変換 
前のトピックへ
displayable

次のトピックへ
トランジション

Search
    
 powered by  

Created using Sphinx. 
変換 (transform)¶
変換を displayable に適用して別の displayable を得られます。組み込みの変換は、スクリーン上におけるオブジェクトの配置場所を制御します。ユーザ定義の変換で、動作、ズーム、回転など、より複雑な効果を与えられます。

変換は、scene 文や show 文に at 節を与えることで適用できます。以下のコードは、eileen happy displayable に "right" 変換を適用します。

show eileen happy at right

複数の変換をカンマで区切って適用できます。その変換は左から右へ順に適用され、競合したら最も右のものが優先されます。

show eileen happy at halfsize, right

displayable には、必ず変換が関わります。変換が与えられないと、それまで使っていた変換を引き継ぎます。変換が変えられると、定義されていない値は使っていた変換を引き継ぎ、使っていた変換がなければ default から取られます。

デフォルトの変換¶
Ren'Py では、デフォルト変換をいくつか定義しています。これらの変換は、画像をスクリーン上に配置します。デフォルトの各変換がどこに画像を配置するかをここに示します。

+-----------------------------------------------------------+
|topleft, reset               top                   topright|
|                                                           |
|                                                           |
|                                                           |
|                                                           |
|                          truecenter                       |
|                                                           |
|                                                           |
|                                                           |
|                                                           |
|left                   center, default                right|
+-----------------------------------------------------------+

offscreenleft および offscreenright 変換は、スクリーンの外に画像を配置します。この変換は、スクリーン外に画像を動かすのに使えます (リソースを浪費しないために、後で必ず hide してください)。

変換は次のとおりです:

center¶ 
スクリーンの中央下に配置します。

default¶ 
スクリーンの中央下に配置します。これは、show 文や scene 文によって表示される画像の位置のデフォルトを変更することで再定義できます。

left¶ 
スクリーンの左下に配置します。

offscreenleft¶ 
スクリーンよりも左に配置し、画面下部に合わせます。

offscreenright¶ 
スクリーンよりも右に配置し、画面下部に合わせます。

reset¶ 
変換をリセットします。displayable をスクリーンの左上に配置し、ズーム、回転その他の効果を消去します。

right¶ 
スクリーンの右下に配置します。

top¶ 
スクリーンの中央上に配置します。

topleft¶ 
スクリーンの左上に配置します。

topright¶ 
スクリーンの右上に配置します。

truecenter¶ 
水平にも垂直にも中央に配置します。

クリエータ定義の変換¶
クリエータは、アニメーションと変換言語 や Transform 関数を使って変換を定義できます。

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
トランジション 
定義済みのトランジション 
トランジションクラス 
トランジション族 
前のトピックへ
変換 (transform)

次のトピックへ
アニメーションおよび変換言語

Search
    
 powered by  

Created using Sphinx. 
トランジション¶
トランジションは with 文 やその他の場面で使え、場面の変化に効果を適用します。Ren'Py には定義済みのトランジションがあり、with 文に直接与えられます。トランジションクラスを使って新しいトランジションを作成することもできます。

定義済みのトランジション¶
定義済みのトランジションは、with 文に直接与えられます。例えば:

show bg washington
with dissolve

fade¶ 
0.5 秒かけて黒画面にフェードし、さらに 0.5 秒かけて新しい画面にフェードします。Fade() トランジションクラスのインスタンスです。

dissolve¶ 
0.5 秒かけて元の画面から新しい画面にディゾルブします。フェードします。Dissolve() トランジションクラスのインスタンスです。

pixellate¶ 
0.5 秒かけて元の画面をピクセレートアウトし、さらに 0.5 秒かけて新しい画面をピクセレートインします。Pixellate() トランジションクラスのインスタンスです。

move¶ 
0.5 秒かけて画像を新しい場所に移動します。MoveTransition() トランジションクラスのインスタンスです。

moveinright¶ 
Also: moveinleft, moveintop, moveinbottom

0.5 秒かけて画像をスクリーンの対応する方向から進入させます。

moveoutright¶ 
Also: moveoutleft, moveouttop, moveoutbottom

0.5 秒かけて画像をスクリーンの対応する方向から退出させます。

ease¶ 
Also: easeinright, easeinleft, easeintop, easeinbottom, easeoutright, easeoutleft, easeouttop, easeoutbottom

move- 類と同じですが、トランジションのはじめと終わりがコサインベースで遅くなります。

zoomin¶ 
0.5 秒かけて画像をズームインで進入させます。

zoomout¶ 
0.5 秒かけて画像をズームアウトで退出させます。

zoominout¶ 
0.5 秒かけて画像のズームアウトによる退出と別の画像のズームインによる進入を同時に行います。

vpunch¶ 
呼び出されたとき、画面を 4 分の 1 秒間垂直に揺らすトランジションです。

hpunch¶ 
呼び出されたとき、画面を 4 分の 1 秒間水平に揺らすトランジションです。

blinds¶ 
スクリーンに 1 秒間続く垂直ブラインド効果を与えるトランジションです。ImageDissolve() トランジションクラスのインスタンスです。

squares¶ 
スクリーンに 1 秒間続くスクエア効果を与えるトランジションです。

wipeleft¶ 
Also: wiperight, wipeup, wipedown

シーンを与えられた方向へワイプします。CropMove() トランジションクラスのインスタンスです。

slideleft¶ 
Also: slideright, slideup, slidedown

新しいシーンを与えられた方向へスライドインします。CropMove() トランジションクラスのインスタンスです。

slideawayleft¶ 
Also: slideawayright, slideawayup, slideawaydown

元のシーンを与えられた方向へスライドアウトします。CropMove() トランジションクラスのインスタンスです。

irisin¶ 
Also: irisout

新しい画面の表示や元の画面の非表示に矩形の絞りを使います。CropMove() トランジションクラスのインスタンスです。

トランジションクラス¶
トランジションクラスは、新しいトランジションを作成するために呼び出される関数です。これらの関数にパラメタを渡すことで、全てのトランジション群が作成できます。

トランジションクラスの呼び出しは、with 文の一部としてなされます。例えば:

# A very long dissolve.
with Dissolve(10.0)

同じトランジションクラスを何度も呼び出さなくて済むように、define 文 を使って変数にトランジションを代入できます:

define annoytheuser = Dissolve(1.0)

label start:
     show bg washington
     with annoytheuser

AlphaDissolve(control, delay=0.0, alpha=False, reverse=False)¶ 
コントロール displayable (たいていは動きのある変換) を使ってあるスクリーンから別のスクリーンへトランジションするトランジションを返します。変換は評価されます。変換が不透明なときは新しい displayable が使われ、変換が透明なときは元の displayable が使われます。

control 
コントロール変換です。 
delay 
トランジションが終了までにかける時間です。 
alpha 
真であれば、画像は背後のものと合成されます。デフォルトの偽であれば、画像は不透明で背後のものを上書きします。 
reverse 
真なら、アルファチャンネルが反転されます。不透明な領域は元の画像から取られ、透明な領域は新しい画像から取られます。 
ComposeTransition(trans, before, after)¶ 
3 つ以内のトランジションから構成される新しいトランジションを返します。before と after トランジションは、None でなければ、元の場面と新しい場面にそれぞれ適用されます。更新されたこれらの元の場面と新しい場面が trans トランジションに与えられます。

# Move the images in and out while dissolving. (This is a fairly expensive transition.)
define moveinoutdissolve = ComposeTransition(dissolve, before=moveoutleft, after=moveinright)

CropMove(time, mode="slideright", startcrop=(0.0, 0.0, 0.0, 1.0), startpos=(0.0, 0.0), endcrop=(0.0, 0.0, 1.0, 1.0), endpos=(0.0, 0.0), topnew=True)¶ 
場面を切り抜いてスクリーンに配置するトランジションを返します。これは、場面の矩形のスライスに関わる様々なエフェクトを実装するのに使えます。

time 
トランジションにかける時間です。 
mode 
トランジションのモードの名前です。モードには三種類あります。ワイプ、スライド、その他です。カスタムモードを定義するために "custom" にもできます。

ワイプでは、画像は固定されたままで、トランジションが進むにつれて見える領域が増えていきます。例えば、左から右へのワイプである "wiperight" では、まず画像の左端がスクリーンの左端に現れ、画像の中央が現れ、最後には画像の右端がスクリーンの右端に現れます。ワイプには、その他 "wipeleft", "wipedown", そして "wipeup" があります。

スライドでは、画像が動きます。ですから "slideright" では、画像は右端がスクリーンの左端から現れ出し、トランジションが進むにつれて右に進みます。スライドには、その他 "slideleft", "slidedown", そして "slideup" があります。

スライドアウェイは、元の画像が新しい画像の上を動きます。スライドアウェイには、"slideawayright", "slideawayleft", "slideawayup", そして "slideawaydown" があります。

矩形の絞りを開く "irisin" と矩形の絞りを閉じる "irisout" もサポートしています。

以下のパラメタは、モードが "custom" であるときのみ考慮されます。ポジションはスクリーンのサイズに対する割合で、クロップは画像のサイズに対する割合です。ですから、(0.25, 0.0, 0.5, 1.0) のクロップは画像の中半分を切り抜きます。

startcrop 
手前の画像から最初に切り抜かれる矩形です。x, y, width, そして height からなる 4 要素のタプルです。 
startpos 
手前の画像が最初に描画されるスクリーン上の場所です。x, y からなる 2 要素のタプルです。 
endcrop 
手前の画像から最後に切り抜かれる矩形です。x, y, width, そして height からなる 4 要素のタプルです。 
endpos 
手前の画像が最後に描画されるスクリーン上の場所です。x, y からなる 2 要素のタプルです。 
topnew 
真なら、切り取られてたり動いたりする場面 (そして手前にある方の場面) は新しい場面です。偽なら、元の場面です。 
define wiperight = CropMove(1.0, "wiperight")
define wipeleft = CropMove(1.0, "wipeleft")
define wipeup = CropMove(1.0, "wipeup")
define wipedown = CropMove(1.0, "wipedown")

define slideright = CropMove(1.0, "slideright")
define slideleft = CropMove(1.0, "slideleft")
define slideup = CropMove(1.0, "slideup")
define slidedown = CropMove(1.0, "slidedown")

define slideawayright = CropMove(1.0, "slideawayright")
define slideawayleft = CropMove(1.0, "slideawayleft")
define slideawayup = CropMove(1.0, "slideawayup")
define slideawaydown = CropMove(1.0, "slideawaydown")

define irisout = CropMove(1.0, "irisout")
define irisin = CropMove(1.0, "irisin")

Dissolve(time, alpha=False, time_warp=None)¶ 
元の場面から新しい場面にディゾルブするトランジションを返します。

time 
ディゾルブにかける時間です。 
alpha 
真なら、ディゾルブはトランジションの結果をスクリーンとアルファ合成します。偽なら、トランジションの結果はスクリーンを置き換え、より効率的です。 
time_warp 
タイムラインを調節する関数です。None でなければ、0.0 から 1.0 の小数の時間を取り、同じ範囲の数を返す関数でなければなりません。 
Fade(out_time, hold_time, old_time, color="#000")¶ 
out_time 秒かけて color で満たされたスクリーンにフェードし、そのスクリーンを hold_time 秒保ち、それから in_time 秒かけて新しいスクリーンにフェードするトランジションを返します。

# Fade to black and back.
define fade = Fade(0.5, 0.0, 0.5)

# Hold at black for a bit.
define fadehold = Fade(0.5, 1.0, 0.5)

# Camera flash - quickly fades to white, then back to the scene.
define flash = Fade(0.1, 0.0, 0.5, color="#fff")

ImageDissolve(image, time, ramplen=8, reverse=False, alpha=True, time_warp=None)¶ 
ディゾルブの過程を制御する画像を使い、元の場面から新しい場面にディゾルブするトランジションを返します。この画像の白いビクセルに対応する部分が最初にディゾルブし、黒いピクセルに対応する部分が最後にディゾルブします。

image 
使用する制御画像です。これは画像ファイルまたは画像マニピュレータでなければなりません。この画像はディゾルブするスクリーンと同じ大きさでなければなりません。 
time 
ディゾルブにかける時間です。 
ramplen 
使用する ramp の長さです。これは 2 の整数乗でなければなりません。これがデフォルト値の 8 であるとき、白いピクセルが完全にディゾルブすると、一段階ごとに 8 シェード暗いピクセルのディゾルブインが進みます。 
reverse 
真なら、黒いピクセルの方が白いビクセルより先にディゾルブインします。 
alpha 
真なら、ディゾルブはトランジションの結果をスクリーンとアルファ合成します。偽なら、トランジションの結果はスクリーンを置き換え、より効率的です。 
time_warp 
タイムラインを調節する関数です。None でなければ、0.0 から 1.0 の小数の時間を取り、同じ範囲の数を返す関数でなければなりません。 
define circirisout = ImageDissolve("circiris.png", 1.0)
define circirisin = ImageDissolve("circiris.png", 1.0, reverse=True)
define circiristbigramp = ImageDissolve("circiris.png", 1.0, ramplen=256)

MoveTransition(delay, factory=None, enter_factory=None, leave_factory=None, old=False, layers=['master'])¶ 
移動した画像を見つけ、元の場所から新しい場所に delay 秒かけて動かすトランジションを返します。

factory は、与えられるなら関数でなければなりません。その関数は、元の位置、新しい位置、ディレイを引数に取り、displayable を返すものです。与えられないときのデフォルトでは、displayable を始点から終点まで動かします。位置は常に (xpos, ypos, xanchor, yanchor) タプルで与えられます。

enter_factory や leave_factory は、与えられるなら関数でなければなりません。それらの関数は、元の位置、新しい位置、ディレイを引数に取り、displayable を返すものです。それらの関数はそれぞれ進入および退出する displayable に適用されます。デフォルトでは、進入する displayable はその場に現れ、退出する displayable はその場で消えます。

old が真なら、ファクトリは与えられたタグを持つ元の displayable を動かします。そうでなければ、与えられたタグを持つ新しい displayable を動かします。

layers は、トランジションが適用されるレイヤのリストです。

同じタグが付いている画像は同じであるとみなされます。これは、どの画像を置き換えたり隠したりするかを決めるのにタグが使われるのと同様です。また、タグが付いていない画像同士は、同じ displayable を使っていれば同じであるとみなされます。

画像が表示される順の計算は、3 段階の工程があります。まず、進入または移動した画像の相対的な順序を保存する画像のリストを作ります。次に、退出する画像を元の場面で奥にあったすべての画像よりも上にあるような最低の位置に挿入します。最後に、zorder 違反を防ぐため、リストが zorder でソートされます。

このトランジションで画像をスクリーンの外側に動かし終わったら、必ず hide してください。(または、単純に leave_factory を使ってください。)

MultipleTransition(args)¶ 
複数のトランジションを次々に表示するトランジションを返します。

args 
要素が奇数個あるリストです。1 番目、3 番目などの奇数番目の要素は場面でなくてはならず、偶数番目の要素はトランジションでなくてはなりません。場面は次のうちのいずれかです:

displayable。 
False, トランジション前の場面を表す。 
True, トランジション後の場面を表す。 
ほぼ必ず、最初の引数は False で最後の引数は True です。

args 内のトランジションが順に適用されます。各トランジションは、その前に置かれたスクリーンから後に置かれたスクリーンにトランジションします。たとえば:

define logodissolve = MultipleTransition(
    False, Dissolve(0.5)
    "logo.jpg", NoTransition(1.0),
    "logo.jpg", dissolve,
    True)

この例は、logo.jpg にディゾルブし、1 秒待ち、それから新しい場面にディゾルブします。

Pause(delay)¶ 
新しいスクリーンを delay 秒間表示するだけのトランジションを返します。MultipleTransition の一部にするのに便利です。

Pixellate(time, steps)¶ 
元のスクリーンをピクセレートアウトし、それから新しいスクリーンをピクセレートインするトランジションを返します。

time 
トランジションにかける合計時間の秒数です。 
steps 
それぞれの方向に行われる段階の数です。各段階ごとに、一つ前の段階の 2 倍のピクセルができます。よって、ピクセレートの 5 段階目では 32x32 のピクセルができます。 
トランジション族¶
トランジション族は、大量の関連するトランジション族を定義する関数群です。

define.move_transitions(prefix, delay, time_warp=None, in_time_warp=None, out_time_warp=None, old=False, layers=['master'], **kwargs)¶ 
これは、move トランジションや ease トランジションみたいなトランジション属を定義します。与えられた prefix に対しては、以下のトランジションを定義しますう:

prefix- delay 秒かけて画像を新しい位置に動かすトランジションです。 
prefixinleft, prefixinright, prefixintop, prefixinbottom - delay 時間かけて画像を新しい位置に動かすトランジションです。新しく表示される画像は適切な側から現れます。 
prefixoutleft, prefixoutright, prefixouttop, prefixoutbottom - delay 時間かけて画像を新しい位置に動かすトランジションです。新しく隠蔽される画像は適切な側へ消えます。 
time_warp, in_time_warp, out_time_warp 
タイムラップ関数です。これらは移動が完了するまでの時間に対する割合を表す 0.0 から 1.0 の小数を与えられ、線形移動が完了するまでの距離に対する割合を表す同じ範囲の小数値を返します。

これは、一定の速度では動かない画像を動かす関数を定義するのに使えます。

これら 3 つの引数は、スクリーンにある画像、新しく現れる画像、新しく消える画像に、それぞれ使われます。

old 
真なら、トランジションは新しい displayable の代わりに元の displayable を動かします。 
layers 
トランジションが適用されるレイヤです。 
移動には追加のキーワード引数が (間接的に) 与えられます。追加すると最も便利な引数はおそらく subpixel=True で、1 ピクセル以下の位置まで考慮に入れた移動を使うものです。

# This defines all of the pre-defined transitions beginning
# with "move".
init python:
    define.move_transitions("move", 0.5)


ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation 目次
アニメーションおよび変換言語 
Ren'Py スクリプトの文 
transform 文 
image 文の ATL ブロック 
scene 文および show 文の ATL ブロック 
ATL 構文および語義 
ATL 文 
補間文 
time 文 
式文 
pass 文 
repeat 文 
block 文 
choice 文 
parallel 文 
event 文 
on 文 
contains 文 
function 文 
ラッパ 
変換プロパティの一覧 
円運動 
外部イベント 
前のトピックへ
トランジション

次のトピックへ
Styles and Style Properties

Search
    
 powered by  

Created using Sphinx. 
アニメーションおよび変換言語¶
アニメーションおよび変換言語 (Animation and Transformation Language, ATL) では高水準に以下のことができます。* 表示する displayable を選択する * それをスクリーンに配置する * 回転、ズーム、アルファ修正のような変換を適用するこれらは時間の経過やイベントに対応して変化させられます。

Python で ATL 変換と等価なのは Transform() displayable です。ATL 変換はプログラム的には作成できません。

Ren'Py スクリプトの文¶
ATL コードは Ren'Py スクリプト文の一部として使えます。

transform 文¶
transform 文は、at 節に与える変換を作成します。transform 文の構文は:

atl_transform ::=  "transform" name "(" parameters ")" ":"
                      atl_block

transform 文は、init (初期化) 時に実行されなければなりません。init ブロックの外にあると、自動的に init ブロック内に配置され、優先度は 0 になります。変換にはパラメタリストを与えることができ、呼び出されたときに供給されなければなりません。

Name は Python 識別子でなければなりません。ATL ブロックによって作成された変換は、その名前に束縛されます。

transform left_to_right:
    xalign 0.0
    linear 2.0 yalign 1.0
    repeat

image 文の ATL ブロック¶
ATL を使う第二の方法は、image 文の ATL ブロックとして使うことです。これは、画像名を与えられた変換に束縛します。この変換にパラメタを与える方法はないので、この使い道はアニメーションの定義ぐらいです。image 文に ATL ブロックを加える構文は:

atl_image ::=  "image" image_name ":"
                  atl_block

image eileen animated:
    "eileen_happy.png"
    pause 1.0
    "eileen_vhappy.png"
    pause 1.0
    repeat

scene 文および show 文の ATL ブロック¶
ATL を使う最後の方法は、scene 文や show 文に含めることです。これは、表示される画像を ATL 変換でラップします。

atl_scene ::=  stmt_scene ":"
                   atl_block
atl_show  ::=  stmt_show ":"
                   atl_block

scene bg washington:
    zoom 2.0

show eileen happy:
    xalign 1.0

ATL 構文および語義¶
ある文の ATL ブロックは、その文より深いインデント上に揃えた 1 行以上の論理行からなります。ATL ブロックの各論理行は、1 つ以上の ATL 文を含まなければなりません。

ATL 文には 2 種類あります。単純文型と複合文型です。単純文は ATL ブロックを取りません。1 行の論理行は、カンマで区切られた 1 つ以上の ATL 文を含めます。複合文はブロックを含むもので、行にそれ以外を置くことはできません。複合文の最初の行は必ずコロン (":") で終わります。

デフォルトでは、ブロック中の文は書いてある順に最初の文から実行されます。実行は、ブロックの終端に達したときに終わります。time 文はこれを、該当の節で説明する通りに変更します。

ブロックの実行は、ブロックの全ての文が終了したときに終わります。

ATL 文が式の評価を要求するとき、その式は変換がシーンリストに最初に加えられるときに評価されます。(例えば、show 文や ui 関数を使うとき。)

ATL 文¶
これらが ATL 文です。

補間文¶
補間文は、ATL が変換を制御する主な方法です。

atl_interp ::=  ( warper simple_expression | "warp" simple_expression simple_expression )?
                ( property simple_expression ( "knot" simple_expression )*
                | "clockwise"
                | "counterclockwise"
                | "circles" simple_expression
                | simple_expression )*

補間文の最初の部分で、補間をタイムラップする関数を選びます。(これは、線形時間から非線形時間への関数です。) そのために、ATL で登録されたラッパの名前を与えるか、予約語 "warp" に続けて関数を与える式を与えてください。どちらの場合でも、補間にかける時間を秒で指定する数を続けます。

ラップ関数が与えられなければ、補間関数は pause 関数を使って 0 秒実行されます。

このラッパと持続時間は、完了率を計算するのに使われます。これは、補間にかかる時間を補間の持続時間で割ることで計算されます。これは持続時間に固定され、ラッパに渡されます。このラッパから返された結果が完了率です。

補間文は、他の節をいくつか加えられます。プロパティと値があるとき、その値は文の終わりにプロパティが得る値です。この値はいくつかの方法で得られます:

値に節となる点が 1 つまたは 2 つ続けられると、スプラインモーションが使われます。始点は補間の開始時のプロパティの値です。終点はプロパティの値です。節がスプラインを制御するのに使われます。 
補間文に "clockwise" または "counterclockwise" が含まれると、以下で解説する円運動が使われます。 
そうでなければ、完了率を使って線形補間されます。 
単純式があれば、その評価はラッパもスプラインも円運動も含まない補間文 1 つでなければなりません。変換から取られたプロパティは、この文に含まれていたかのように処理されます。

補間の例は:

show logo base:
     # Show the logo at the upper right side of the screen.
     xalign 0.0 yalign 1.0

     # Take 1.0 seconds to move things back to the left.
     linear 1.0 xalign 0.0

     # Take 1.0 seconds to move things to the location specified in the
     # truecenter transform. Use the ease warper to do this.
     ease 1.0 truecenter

     # Just pause for a second.
     pause 1.0

     # Set the location to circle around.
     alignaround (.5, .5)

     # Use circular motion to bring us to spiral out to the top of
     # the screen. Take 2 seconds to do so.
     linear 2.0 yalign 0.0 clockwise circles 3

     # Use a spline motion to move us around the screen.
     linear 2.0 align (0.5, 1.0) knot (0.0, .33) knot (1.0, .66)

重要で特別な例は pause ラッパで、時間だけを続けて書き、その時間だけ ATL の実行が休止します。

プロパティには、複数の型の値を取れるものがあります。例えば、xpos プロパティは整数、浮動小数点数、または renpy.absolute にできます。補間に異なる型の古いプロパティと新しいプロパティがあるときの動作は未定義です。

time 文¶
time 文は単純な制御文です。この文が含まれるブロックが実行され始めてからの時間を秒で表す単純式を 1 つ含みます。

atl_time ::=  "time" simple_expression

この文で与えられた時間が経過すると続く文の実行が始まります。この制御の移行は前の文が実行中であってさえ行われ、先行する文は即座に終了します。

time 文には暗黙に無限時間の pause 文が前置されます。つまり、time 文にたどり着いたときに制御が別のところにあれば、time 文は制御を得るまで待ちます。

一つのブロックに複数の time 文があるなら、それらは厳密に時間の経過順でなくてはなりません。

image backgrounds:
    "bg band"
    time 2.0
    "bg whitehouse"
    time 4.0
    "bg washington"

式文¶
式文は、単純式で始まる単純文です。with 節で 2 つめの単純式を続けることもできます。

atl_expression ::=   simple_expression ("with" simple_expression)?

最初の単純式は、以下の 3 つのいずれかに評価されるものにできます:

変換なら、その変換が実行されます。with 節は変換が与えられたときは無視されます。 
整数または浮動小数点数なら、pause が実行される秒数になります。 
そうでなければ、この式は displayable と解釈されます。この displayable は、この節が実行されたときに変換の子を置き換えるので、アニメーションに便利です。with 節があると、第二の式はトランジションと評価され、そのトランジションが前後の displayable に適用されます。 
image atl example:
     # Display logo_base.png
     "logo_base.png"

     # Pause for 1.0 seconds.
     1.0

     # Show logo_bw.png, with a dissolve.
     "logo_bw.png" with Dissolve(0.5, alpha=True)

     # Run the move_right tranform.
     move_right

pass 文¶
atl_pass ::=  "pass"

pass 文は、何も起こさない単純文です。これは、文を分割したいときに使えます。例えば、2 組の choice 文が連続するのではなく分かれているときです。

repeat 文¶
repeat 文は、そのブロックの実行を再び最初から始める単純文です。式があれば、その評価がブロックの実行回数を与える整数になります。(ですから、"repeat 2" で終わる文は最高で 2 回実行されます。)

atl_repeat ::=  "repeat" (simple_expression)?

repeat 文は、必ずブロックの最後になければなりません。

show logo base:
    xalign 0.0
    linear 1.0 xalign 1.0
    linear 1.0 xalign 0.0
    repeat

block 文¶
block 文は、ATL コードのブロックを含む文をまとめます。文を繰り返すためにグループ化するのに使えます。

atl_block_stmt ::=  "block" ":"
                         atl_block

label logo base:
    alpha 0.0 xalign 0.0 yalign 0.0
    linear 1.0 alpha 1.0

    block:
        linear 1.0 xalign 1.0
        linear 1.0 xalign 0.0
        repeat

choice 文¶
choice 文は、選択肢群の 1 つを定義する複合文です。Ren'py はその選択肢群から 1 つ選び、対応する ATL ブロックを実行します。その後、最後の選択肢の後から実行を続けます。

atl_choice ::=  "choice" (simple_expression)? ":"
                    atl_block

ブロック内の連続する choice文は貪欲にグループ化されます。simple_expression が与えられていると、浮動小数点数のウェイトとしてブロックに与えられます。なければ 1.0 になります。

image eileen random:
    choice:
        "eileen happy"
    choice:
        "eileen vhappy"
    choice:
        "eileen concerned"

    pause 1.0
    repeat

parallel 文¶
parallel 文は、並行して実行される ATL ブロック群を定義するのに使われます。

atl_parallel ::=  "parallel" ":"
                     atl_block

ブロック内の連続する parallel 文は 貪欲にグループ化されます。全ての parallel 文のブロックが同時進行で実行されます。parallel 文は、最後のブロックが終了したときに終了します。

群中のブロックは、それぞれ独立したもので、かつ異なるプロパティを操作するものでなければなりません。2 つのブロックが同じプロパティを変更するときの結果は未定義です。

show logo base:
    parallel:
        xalign 0.0
        linear 1.3 xalign 1.0
        linear 1.3 xalign 0.0
        repeat
    parallel:
        yalign 0.0
        linear 1.6 yalign 1.0
        linear 1.6 yalign 0.0
        repeat

event 文¶
event 文は、与えられた名前のイベントを引き起こす単純文です。

atl_event ::=  "event" name

あるブロック内でイベントが引き起こされたとき、与えられた名前に対するイベントハンドラがそのブロックに存在しないかチェックされます。存在すれば、制御はイベントハンドラに移ります。存在しなければ、イベントは外側のイベントハンドラに伝播します。

on 文¶
on 文は、イベントハンドラを定義する複合文です。on 文は一つの文に貪欲にグループ化されます。

atl_on ::=  "on" name ":"
                 atl_block

on 文は、イベントを処理するのに使います。イベントが処理されるとき、他のイベントの処理は終了し、新しいイベントの処理が即座に始まります。他のイベントが起こることなくイベントハンドラが終了したとき、(すでに default イベントを処理していたのでなければ) default イベントが引き起こされます。

on 文の実行は自然には終わりません。(しかし、time 文や外側のイベントハンドラによって終了され得ます。)

show logo base:
    on show:
        alpha 0.0
        linear .5 alpha 1.0
    on hide:
        linear .5 alpha 0.0

contains 文¶
contains 文は、この ATL 変換に含まれる displayable (変換の子変換) を設定します。contains 文には 2 種類あります。

contains 式版は式を取り、その式を変換の子変換として設定します。これは ATL 変換が別の ATL を含みたいが取り込みたくないときに便利です。

atl_contains ::=  "contains" expression

transform an_animation:
    "1.png"
    pause 2
    "2.png"
    pause 2
    repeat

image move_an_animation:
    contains an_animation

    # If we didn't use contains, we'd still be looping and
    # would never reach here.
    xalign 0.0
    linear 1.0 yalign 1.0

contains ブロックで、この ATL 変換の子変換として使われる ATL ブロックを定義できます。連続する contains block 文は貪欲にグループ化され、Fixed() でラップされ、この変換の子変換として設定されます。全ての parallel 文のブロックが同時進行で実行されます。

atl_counts ::=  "contains" ":"

それぞれのブロックで使用する displayable を定義していなければならず、そうでなければ例外が発生します。contains 文は、子が完了するのを待たずにすぐに実行します。この文は、引数を子に簡単に渡せるようにするシンタックスシュガーに近いです。

image test double:
    contains:
        "logo.png"
        xalign 0.0
        linear 1.0 xalign 1.0
        repeat

    contains:
        "logo.png"
        xalign 1.0
        linear 1.0 xalign 0.0
        repeat

function 文¶
function 文で、ATL に ATL プロパティを制御する Python 関数を使わせられます。

atl_function ::=  "function" expression

この関数の定義は Transform() で使われるのと同じです:

第一引数は変換オブジェクトです。このオブジェクトに変換プロパティを設定できます。 
第二引数は出現時間軸で、関数が実行され始めてからの秒数です。 
第三引数はアニメーション時間軸で、同じタグのものがスクリーン上にある秒数です。 
この関数の結果が数ならば、その秒数が経過するとまた呼び出されます。(0 秒なら、関数はできるだけ早く呼び出されます。) 関数が None を返したら、制御は次の ATL 文に渡されます。 
init python:
    def slide_function(trans, st, at):
        if st > 1.0:
            trans.xalign = 1.0
            return None
        else:
            trans.xalign = st
            return 0

label start:
    show logo base:
        function slide_function
        pause 1.0
        repeat

ラッパ¶
ラッパは、補間文が経過したとみなす時間を変更する関数です。デフォルトで以下のラッパが定義されています。これらは t から t' への関数として定義されています。ここで t および t' は 0.0 から 1.0 の浮動小数点数です。(文の持続時間が 0 なら、t は実行時に 1.0 になります。)

pause 
一時停止し、新しい値に飛びます。t == 1.0 なら t' = 1.0、そうでなければ t' = 0.0 です。 
linear 
線形補間です。t' = t 
ease 
最初は遅く、スピードアップし、それからスローダウンします。t' = 0.5 - math.cos(math.pi * t) / 2.0 
easein 
最初は速く、スローダウンします。t' = math.cos((1.0 - t) * math.pi / 2.0 
easeout 
最初は遅く、スピードアップします。t' = 1.0 - math.cos(t * math.pi / 2.0) 
python early ブロック内で renpy.atl_warper を使って新しいラッパが定義できます。これはラッパを使うファイルの前に読み込まれるファイル内に書きこまれていなければなりません。コードは次のようになります:

python early hide:

    @renpy.atl_warper
    def linear(t):
        return t

変換プロパティの一覧¶
以下の変換プロパティが存在します。

型が position と書かれていれば、それは整数、浮動小数点数、または renpy.absolute にできます。浮動小数点数なら、それが含まれる (位置では) 領域または (アンカー位置では) displayable に対する割合として解釈されます。

なお、全てのプロパティが独立しているわけではありません。例えば、xalign と xpos はどちらも同じ根底のデータを更新します。parallel 文では、水平位置を調節していいブロックは 1 つだけ、垂直位置を調節していいブロックも 1 つだけです。(同じブロックで両方調節しても良いです。) angle および radius プロパティは、水平位置と垂直位置の両方を設定します。

pos¶ 
Type : (position, position) 
Default : (0, 0) 

それを含む領域の左上隅に対する位置です。

xpos¶ 
Type : position 
Default : 0 

それを含む領域の左端に対する水平位置です。

ypos¶ 
Type : position 
Default : 0 

それを含む領域の上端に対する垂直位置です。

anchor¶ 
Type : (position, position) 
Default : (0, 0) 

それを含む displayable の左上隅に対するアンカー位置です。

xanchor¶ 
Type : position 
Default : 0 

それを含む displayable の左端に対する水平アンカー位置です。

yanchor¶ 
Type : position 
Default : 0 

それを含む displayable の上端に対する垂直アンカー位置です。

align¶ 
Type : (float, float) 
Default : (0.0, 0.0) 

それを含む displayable の上端に対する垂直アンカー位置です。

xalign¶ 
Type : float 
Default : 0.0 

xpos および xanchor をこの値に設定するのと等価です。

yalign¶ 
Type : float 
Default : 0.0 

ypos および yanchor をこの値に設定するのと等価です。

xcenter¶ 
Type : float 
Default : 0.0 

xpos をこのプロパティの値に、xanchor を 0.5 に設定するのと等価です。

ycenter¶ 
Type : float 
Default : 0.0 

rpos をこのプロパティの値に、ranchor を 0.5 に設定するのと等価です。

rotate¶ 
Type : float or None 
Default : None 

None なら、回転は起こりません。そうでなければ、画像はこの角度だけ時計回りに回転します。displayable を回転すると、rotate_pad の設定に従ってリサイズされます。xanchor および yanchor が 0.5 でなければ、これによって位置取りが変わることがあります。

rotate_pad¶ 
Type : boolean 
Default : True 

真なら、回転された displayable の幅と高さが、元の幅と高さの斜辺と同じになるように埋め込まれます。これは、変換が内容を回転させてもサイズが変わらないことを保証します。偽なら、変換は変換された displayable を含む最小限のサイズになります。これは固定回転に向いています。

zoom¶ 
Type : float 
Default : 1.0 

This causes the displayable to be zoomed by the supplied factor. This should always be greater than .5. これは、displayable に与えられた係数倍ズームします。これは必ず 0.5 より大きくしてください。

xzoom¶ 
Type : float 
Default : 1.0 

これは、displayable に与えられた係数倍水平にズームします。これは必ず 0.5 より大きくしてください。

yzoom¶ 
Type : float 
Default : 1.0 

これは、displayable に与えられた係数倍垂直にズームします。これは必ず 0.5 より大きくしてください。

alpha¶ 
Type : float 
Default : 1.0 

これは、displayable の透明度を制御します。

around¶ 
Type : (position, position) 
Default : (0.0, 0.0) 

None でなければ、それを含む領域の右上に対する極座標の中心を指定します。これで中心を設定すると、position モードで円運動ができます。

alignaround¶ 
Type : (float, float) 
Default : (0.0, 0.0) 

None でなければ、それを含む領域の右上に対する極座標の中心を指定します。これで中心を設定すると、align モードで円運動ができます。

angle¶ 
Type : float 

極座標における位置の角度成分を取ります。これは、極座標の中心が設定されていないときには未定義です。

radius¶ 
Type : position 

極座標における位置の半径成分を取ります。これは、極座標の中心が設定されていないときには未定義です。

crop¶ 
Type : None or (int, int, int, int) 
Default : None 

None でなければ、displayable は与えられたボックスに切り抜かれます。そのボックスは、(x, y, width, height) のタプルで指定します。

corner1¶ 
Type : None or (int, int) 
Default : None 

None でなければ、crop ボックスの左上隅を与えます。これは crop より優先されます。

corner2¶ 
Type : None or (int, int) 
Default : None 

None でなければ、crop ボックスの右下隅を与えます。これは crop より優先されます。

size¶ 
Type : None or (int, int) 
Default : None 

None でなければ、displayable を与えられたサイズに合わせます。

subpixel¶ 
Type : boolean 
Default : False 

真なら、ピクセル以下の位置調整を利用してスクリーンに描画されます。

delay¶ 
Type : float 
Default : 0.0 

この変換がトランジションとして使われていれば、これはトランジションの持続時間です。

これらのプロパティは、以下の順に適用されます:

crop, corner1, corner2 
size 
rotate 
zoom, xzoom, yzoom 
position properties 
円運動¶
補間文が予約語 clockwise や counterclockwise を含むとき、円形モーションが補間されます。Ren'Py は開始と終了の位置を比較し、極座標の中心を計算します。そして Ren'Py は開始角度から終了角度まで、指定された方向の回転で進む角度を計算します。円運動の節が与えられたら、Ren'Py は適切な数の円が作られることを保証します。

Ren'Py は angle および radius プロパティを適切に補間し、円形運動を起こします。変換が align モードなら、angle および radius を設定すると align プロパティが設定されます。そうでなければ、pos プロパティが設定されます。

外部イベント¶
以下のイベントは自動的に引き起こされます:

start 
on 文に進入したときに、これより高い優先度のイベントが起こらなかった場合に引き起こされる擬似イベントです。 
show 
変換が show 文や scene 文によって表示されるとき、与えられたタグの画像がまだ存在しない場合に引き起こされます。 
replace 
変換が show 文によって表示され、与えられたタグの画像を置き換えるときに引き起こされます。 
hide 
変換が hide 文やそれと等価な Python を使って隠されたときに引き起こされます。

なお、これが引き起こされないときがあります。変換が scene 文を通して除去されたときや、ゲームメニューの終了などによって変換が存在するコンテキストから抜けることで除去されたときです。

replaced 
変換が別のもので置き換えられたときに引き起こされます。この画像は、ATL ブロックが完了するまで実際には隠されません。 
hover, idle, selected_hover, selected_idle 
この変換を含むボタンやこの変換に含まれるボタンが名前通りの状態になったときに引き起こされます。 
ナビゲーション
索引 次へ | 前へ |  Ren'Py Home | Ren'Py Japanese Documentation   

--------------------------------------------------------------------------------

renpy/ja/doc/FAQ
From Ren'Py Visual Novel Engine
< renpy
Jump to: navigation, search
FAQ 
このページには、Ren'Pyについてのよくある質問と、その回答が集めてあります。ここにある回答は、Ren'Pyを始めたばかりの人たちにとって、役に立つものとなるでしょう。 

Contents
[hide]
1 FAQ 
2 テキスト表示のテクニック 
2.1 ナレーションテキストのスタイルを変えるには？ 
2.2 ダイアログにクオーテーションマーク (") を入れるには？ 
2.3 行の途中で一時停止したり、改行したりするには？ 
2.4 ダイアログの中に画像を埋め込むには？ 
2.5 ダイアログの中の一部分だけ色・サイズを変えるには？ 
2.6 デフォルトのフォントを変えるには？ 
2.7 ダイアログテキストと選択肢を同時に表示するには？ 
2.8 テキストの中に変数値を入れるには？ 
2.9 逆転裁判のように、テキストが表示されるときにサウンドを鳴らすには？ 
3 見た目のカスタマイズ 
3.1 キャラクターが話すときにグラフィックを表示するには？ 
3.2 キャラクター名を専用枠で表示するには？ 
3.3 テキストを両端揃えで表示するには？ 
3.4 メインメニューをカスタマイズするには？ 
3.5 イメージマップを使うには？ 
3.5.1 ゲームメニューでイメージマップを利用するには？ 
3.6 テキストのセンタリングを行うには？ 
3.7 実行時に画像を拡大/縮小するには？ 
3.8 メニューボタンのテキストを変更するには？ 
3.9 プレイ情報（日付・スコアなど）を表示するには？ 
3.10 ゲームのアイコンを変えるには？ 
3.11 イメージマップを使わずにメインメニューをカスタマイズするには？ 
3.12 [あらゆるもの] (anything) の表示を変えるには？ 
3.12.1 スタイルの親子関係 
3.12.2 スタイルインスペクター 
4 ゲームデザイン 
4.1 Princess Makerのように、スケジュールのあるシミュレーションを作るには？ 
4.2 Fate Stay/Nightのように、画面全体にテキストを表示するには？ 
4.3 RPGを作るには？ 
4.4 Ren'Pyで作成したゲームを販売することはできますか？ 
4.5 版権素材を用いた二次創作ゲームは作れますか？ 
4.6 音楽や背景素材、キャラクター、その他のツールはどこで手に入りますか？ 
5 テクニカルな部分 
5.1 ゲーム終了後にメインメニューに戻るには？ 
5.2 メニューが表示されている間でも、テキストボックスが表示され続けるようにするには？ 
5.3 フェード (Fade) とディゾルブ (Dissolve) の違いは？ 
5.4 フェードやディゾルブのタイミングを調整するには？ 
5.5 ゲームスクリプトを複数のファイルに分割するには？ 
5.6 ロールバック機能を無効化するには？ 
5.7 ゲーム内メニューへのアクセスを無効化するには？ 
5.8 マウスの座標を取得するには？ 
5.9 セーブされたゲームデータを削除するには？ 
5.9.1 バージョン 6.9.3 以降 
5.9.2 バージョン 6.9.2 - 6.9.0 
5.9.3 バージョン 6.9.0 未満 
5.10 ゲームのリリース前に、セーブデータを消去する必要がありますか？ 
5.11 インデントの働きは？ブロックとは何ですか？ 
5.12 ゲームファイルを外から見えないようにするには？ 
6 互換性 
6.1 ユニコード文字 (中国語・日本語など) を使うには？ 
6.2 Ren'Py で Flash は使えますか？ 
6.3 Ren'Py でアニメーション GIF は使えますか？ 
6.4 手元のビデオや音楽が、Ren'Py で再生できないのですが？ 
6.5 Ren'Py は iPhone のような他のプラットフォームでも利用できますか？ 
7 トラブルシューティング 
7.1 "menuitem expects a non-empty block" とは？ 
7.2 アーカイブを行っても "archived" フォルダーが現れません！ 
7.3 "couldn't find file [yourfile.jpg]" が表示され続けるのですが？ 
7.3.1 ファイルの場所を正しく指定していますか？ 
7.3.2 コード中の名前と実際のファイル名が一致していますか？ 
7.3.3 拡張子は合っていますか？ 
7.4 コードは正しいのに、イメージマップが壊れて見えるのですが？ 
7.5 カスタマイズしたメインメニューにジャンプしないことがあるのですが？ 
 




テキスト表示のテクニック 
ナレーションテキストのスタイルを変えるには？ 
キャラクターを指定しないときのテキストのスタイルを設定するには、特殊なキャラクターである "narrator" を再定義します。キャラクター定義の第1引数にはキャラクター名が必要ですが、ここに "None" を設定することで、キャラクター名を表示しないようにできます。 


$ narrator = Character(None, window_left_padding=160)

これによって、話し手となるキャラクターが指定されないときの、テキストの表示方法をカスタマイズすることができます。次のようなスクリプトを書けば、カスタマイズした内容が反映されます。 

"このテキストは narrator キャラクターのスタイルで表示されます。"
bob "このテキストは bob のスタイルで表示されます。"

ダイアログにクオーテーションマーク (") を入れるには？ 
クオーテーションマークを画面上に表示するには、そのまえにバックスラッシュ (\) を挿入します。シングルクオーテーションマーク (') を用いる場合には、バックスラッシュを挿入する必要はありません。 


"\"君の記事はいいね！\" と彼は言った。"

行の途中で一時停止したり、改行したりするには？ 
特別なコマンドを使うことで、ダイアログの行の途中で一時停止したり、改行したりできます。とくに、{p}、 {w}、 \n は、よく使うコマンドです。 

\n を挿入すると、そのあとのテキストを次の行に送ります。 

e "買物に行きたいなあ。\nでも、お金も貯めたいし……。"

このスクリプトは、次のように表示されます。 

買物に行きたいなあ。
でも、お金も貯めたいし……。
テキスト表示の途中で一時停止するには、{p} または {w} を使ってください。 {w} はマウスクリックのあと、そのまま続けてテキストを表示します。 {p} を使うと、一時停止後に表示されるテキストは次の行に送られます。 

一時停止はデフォルトではプレイヤーがマウスをクリックするまで待ちますが、停止時間を指定して再開させることもできます。次のスクリプトは、"でも、お金も貯めたいし……。" を表示する前に1秒間停止したあと、行を改めて再開します。 


e "買物に行きたいなあ。{p=1.0)でも、お金も貯めたいし……。"

ダイアログの中に画像を埋め込むには？ 
{image=yourimage.jpg} と記述すると、ダイアログテキストの中に画像を埋め込むことができます。 "yourimage.jpg" の部分を、使いたい画像のパスに変えてください。 

ダイアログの中の一部分だけ色・サイズを変えるには？ 
もしあなたが一部の単語や文章だけを他と違う色やサイズで表示したいなら、テキストタグを使って変えることができます。 

文字の色を変えるには、{color} タグを使います。 

"{color=#000}この部分の色が変わります。{/color} ここは変わりません。"

"#000" の部分を、使いたい色に変えてください。 

文字のサイズを変えるには、{size} タグを使ってください。 

"{size=12}この部分のサイズが変わります。{/size} ここは変わりません。"

"12" の部分を、お好きなサイズに変えてください。 

文字サイズは相対的に変えることもできます。{size=+12} はそれまでより12ポイント大きいサイズで、{size=-12} は12ポイント小さいサイズで文字を表示します。 

"{size=+12}大きく表示します。{/size} {size=-12}小さく表示します。{/size}"

デフォルトのフォントを変えるには？ 
Ren'Pyには、あらかじめoption.rpyファイルの中に、ゲーム全体で使われるフォントを変更するためのコードが記述してあります。 

style.default.font = "fontname.ttf"

これを有効にするには、行の先頭にある"#"を消してコメントを無効化し、"fontname.ttf"の部分をお好きなフォントファイル名に置き換えてください。 

ダイアログテキストと選択肢を同時に表示するには？ 
ADVモードのデフォルトでは、選択肢はそれ単独で表示され、このときダイアログウィンドウは消えてしまいます。両方を同時に表示させるには、ダイアログテキストをmenuヘッダーの下にインデントして入れるだけです。 

menu:
    e "このセリフはダイアログウィンドウに表示されます。"
    "選択肢1":
        "Yep."
    "選択肢2":
        "Still yep."

テキストの中に変数値を入れるには？ 
テキストの中で変数を表示するには、変数名をブラケット ([) で囲います。 

$ pots = 4
"ポーションが [pots] つあります。"

$ food = "アップルソース"
"[food] でお願いします。"

もしあなたが古いバージョンのスクリプトを使っていて、以前のスタイルである%()sや%()dを使いたい場合は、次のスクリプトを追加しなければなりません。 

config.old_substitutions = True

同様に、新しいブラケットを用いたスタイルを使いたくなければ、これを無効にできます。 

config.new_substitutions = False

逆転裁判のように、テキストが表示されるときにサウンドを鳴らすには？ 
"typewriter" エフェクトを使うには、次のコードを使ってください。 

init python:
    def callback(event, **kwargs):
        if event == "show":
            renpy.music.play("godawful-beeping-noise.ogg", channel="sound")
        elif event == "slow_done" or event == "end":
            renpy.music.stop(channel="sound")

このコードをスクリプトの最初に置き、キャラクター定義のときにこれをコールバック関数として指定してください（ここでのコールバック関数名は"callback"です）。あとはいつものようにキャラクターに喋らせるだけです。 

init:
    $ pw = Character("Phoenix Wright", callback=callback)


label start:

    pw "どうして「逆転裁判」では人がいつも死んでしまうの？"
    pw "たぶん、あのビープ音が気を狂わせるからだよ！"

見た目のカスタマイズ 
キャラクターが話すときにグラフィックを表示するには？ 
サイドイメージ（いわゆる「顔グラ」）を表示したい、と思っている人がいるでしょう。これを実現するには、キャラクターを定義するときにshow_side_imageオプションでdisplayableオブジェクトを指定してください。 


$ eside = Character('Eileen',
                color="#c8ffc8",
                window_left_padding=160,
                show_side_image=Image("eileen_side.png", xalign=0.0, yalign=1.0))

 

このコードでは、画像が左寄せで表示されます。"xalign=1.0"とすれば、右寄せで表示できます。 
パディングを調整して、画像とテキストが重ならないように気をつけてください。 

もし表示されている別の画像をもとにしたサイドイメージを表示したいなら、ShowingSwitchが使えます。別の画像に依存せず、ひとつのサイドイメージ枠で画像を切り替えて使いたい場合は、ConditionSwitchを検討してください。 

キャラクター名を専用枠で表示するには？ 
いわゆる「名前ウィンドウ」を使いたいですか？もしキャラクター名をメインウィンドウの外側に表示させたいなら、キャラクター定義の際に次のように各必要があります。 

$ e = Character("Eileen", show_two_window=True)

キャラクター名ウィンドウの揃え位置、背景や他の属性を変更するには、次のようにします。 

    style.say_who_window.background = Frame("frame.png", 15, 15) #Background skin
    style.say_who_window.xalign = 0.0
    style.say_who_window.yalign = 1.0
    #style.say_who_window.xpos = 100 #For precise placement
    #style.say_who_window.ypos = 100 #For precise placement
    style.say_who_window.left_padding = 15
    style.say_who_window.top_padding = 15
    style.say_who_window.right_padding = 15
    style.say_who_window.bottom_padding = 15
    style.say_who_window.xminimum = 150
    style.say_who_window.yminimum = 15
    style.say_who_window.xfill = False




テキストを両端揃えで表示するには？ 
まず、両端揃えにするための専用のスタイルを定義しなければなりません。たとえば、justify_styleというスタイルを定義するとします。 


$ style.create("justify_style", "default", u"(text) 両端揃えスタイル")

最初の引数は新しいスタイルの名前です。2番目は親となるスタイルの名前か、上のようにdefaultを指定します。 

さらに、次のコードを記述します。 


$ style.justify_style.justify = True

構文は style.スタイル名.プロパティ名です。この場合、スタイル名はjustify_style、プロパティ名はjustifyです。 

上の例では、Pythonステートメントを表す$記号を用いて、両端揃えのスタイルを有効化しています。 

スタイルを使ったプロパティの設定方法は、次の場所で見ることができます。[1] 

最後に、スタイルをキャラクターに結びつけます。 


$ char = Character(what_style = "justify_style")

ここでは、justify_styleオプションだけを設定したキャラクタを定義しています。 


$ m = Character('Man', kind=char)
$ w = Character('Woman', kind=char)

justify_styleスタイルを用いて複数のキャラクターを定義したければ、Character関数の中で"kind=char"を使い、キャラクターを継承させます。 

メインメニューをカスタマイズするには？ 
メインメニューやゲームメニュー画面の背景画像を設定するには、options.rpyファイルに記述されているコードを利用します。 

mm_root = "mm_bg.jpg", #メインメニューの背景
gm_root = "gm_bg.jpg", #ゲームメニューの背景

もし単色塗りの背景を使いたければ、16進数の色コードを指定することもできます。 

もしメインメニューにBGMを追加したければ、options.rpy内の次のコードを見つけてください。 

## メインメニューで流れる曲

    config.main_menu_music = "main.mp3"

"main.mp3"の部分を、流したい曲のファイル名に変えてください。 

メインメニューに表示されるボタンの位置を変えたい場合は、screens.rpyファイルにある位置に関するコードを変更します (6.12+)。 

screen main_menu:

    # 他のメニュー画面も置き換える
    tag menu

    # メインメニューの背景
    window:
        style "mm_root"

    # メインメニューで表示されるボタン
    frame:
        style_group "mm"
        xalign .50
        yalign .75

        has vbox

        textbutton _("Start Game") action Start()
        textbutton _("Load Game") action ShowMenu("load")
        textbutton _("Extras") action ShowMenu("extras")
        textbutton _("Preferences") action ShowMenu("preferences")
        textbutton _("Help") action Help()
        textbutton _("Quit") action Quit(confirm=False)

これをたとえば、次のように変更します。 

# The main menu buttons.
    frame:
        style_group "mm"
        xalign .50
        yalign .75

0.5 は中央、0.75 は 3/4 の位置を表します。 


--------------------------------------------------------------------------------

もし古いバージョンのRen'Pyを使っている場合は、options.rpyを編集してメインフレームを調整できます。これはデフォルトではコメントアウトされています。 

style.mm_menu_frame.xpos = 0.5 #横位置、中央
style.mm_menu_frame.ypos = 0.75 #縦位置、上から3/4 
style.mm_menu_frame.xanchor = 0.5 #横アンカー、中央
style.mm_menu_frame.yanchor = 0.5 #縦アンカー、中央

イメージマップを使うには？ 
イメージマップは、二つの画像を組み合わせて、クリック可能な「ホットスポット」を持つひとつの画像を自動的に作りだす機能です。ホットスポットとは、マウスに反応する画像上の領域のことです。1枚目の画像はマウスによるイベントのない状態で表示される画像で、"Ground" imageと呼ばれます。2枚目の画像はマウスがホットスポット上に乗ったときに表示される画像で、"Hover" imageと呼びます。この例では、マウスを乗せることによって赤いボックスが黄色に変わります。コードは Screen Language (6.11+) にあるものを使っています。 


screen example_imagemap:
    imagemap:
        ground "Ground.jpg"
        hover "Hover.jpg"

        hotspot (8, 200, 78, 78) clicked Return("swim")
        hotspot (204, 50, 78, 78) clicked Return("science")
        hotspot (452, 79, 78, 78) clicked Return("art")
        hotspot (602, 316, 78, 78) clicked Return("go home")
        
label example:
    
    call screen example_imagemap
    
    $ result = _return
    
    if result == "swim":
        e "You picked swimming!"
    elif result == "science":
        e "You picked science!"
    elif result == "art":
        e "You picked art!"
    elif result == "go home":
        e "You went home!"

    return

 

"Ground" Image
 

"Hover" Image
"ground.jpg"と"hover.jpg"の部分に、あなたが使いたい2枚の画像を指定してください。このコードが動作するには、必ず2枚の画像が必要です (デフォルト用と、マウスが乗ったとき用)。 
hotspot のあとにある数字は、ホットスポットの座標です。この値は親ボックスを基準として、(左端の位置, 上端の位置, ホットスポットの幅, ホットスポットの高さ)を表します。 

イメージマップ上に配置されたホットスポットではいろいろなことができますが、基本的にはクリックされたときにある値を返すようになっています。クリックされたときの動作を決めるために、それぞれのホットスポットごとに適切な値を返すようにしてください。上の例では、"result"変数に、どのホットスポットがクリックされたかを表す値が格納されます。もしプレイヤーが"science"ホットスポットをクリックすれば、result変数には"science"が格納されます。その次の部分では、result変数に入っている値に応じて何をするかを決めています。 

イメージマップが提供している機能以上のことが必要なら、かわりに背景画像の上でのイメージボタン が利用できます。 

イメージマップについてのさらなる情報は、 ここを参照してください。 




ゲームメニューでイメージマップを利用するには？ 
一般的なメニューのカスタマイズ方法は、 ここを参照してください。 


--------------------------------------------------------------------------------

ゲームメニューでイメージマップを利用するのは、設定することが多いためやや大変です。カスタマイズの程度によって、必要な画像数は変わります。 

メニューレイアウトに必要な画像:   Ground  Idle  Hover  Idle (Selected)  Hover (Selected)  
メインメニュー画面  n/a  X  X  n/a  n/a  
はい/いいえ選択画面  X  X  X  n/a  n/a  
ロード/セーブ画面  X  X  X  X  X  
設定画面  X  X  X  X  X  
ナビゲーション画面  X  X  X  X  X  

 

Imagemap States
Ground: マウスイベントに関係のない、背景画像です。この後ろにはさらにoptions.rpyファイルの"gmroot"変数で指定した画像が表示されるので、ここで指定する画像は画面と同じサイズでなくても構いません。これはつまり、メニュー部分以外の領域が透明になっている画像を使うべきだということです。この画像はまた、ボタンが無効化 (disabled) されているときにも使われます。 

Idle: この画像は、ボタンやスイッチが選択されていない (unselected) 状態のときに使われます。「選択されていない」とは、ボタンの状態が「オン」ではないが、クリック可能であるということです。 

Hover: この画像は、ボタンやスイッチが選択されておらず、かつマウスがボタン上に乗っているとき (unselected and hovered over) に表示されます。もしマウスが乗った場合でも画像を変えたくなければ、Idleで指定した画像と同じものを指定してください。 

Selected Idle: この画像は、ボタンやスイッチが選択されている (selected) 状態のときに使われます。「選択されている」とは、ボタンがクリック可能で、かつ「オン」の状態のときです。 

Selected Hover: この画像は、ボタンやスイッチが選択されていて、かつマウスがボタン上に乗っているとき (selected and hovered over) に表示されます。もしマウスが乗った場合でも画像を変えたくなければ、Selected Idleで指定した画像と同じものを指定してください。 

ノート: ゲーム画面におけるナビゲーションバーは、メインメニューを除くメニュー画面の中で用いられるべきではありません。これはまた別のイメージマップとして、新たに実装する必要があります。ここを参照してください。 

テキストのセンタリングを行うには？ 
Ren'Py には、"centered" と呼ばれるデフォルトのキャラクターが存在します。これは次のように使用します。 

centered "このテキストは画面上でセンタリングされて表示されます。"

他の属性を付け加えるために、新たに別のキャラクターを定義することもできます（あるいは、centeredキャラクターをオーバーライドすることもできます）。 

    $ outline = Character(None,
                          what_size=20, #フォントサイズ
                          what_xalign=0.5, #テキストをウィンドウ中央に配置
                          window_xalign=0.5, #ウィンドウを横位置中央に配置
                          window_yalign=0.5, #ウィンドウを縦位置中央に配置
                          what_text_align=0.5, #テキストをウィンドウ中央に配置（念のため）
                          window_background=None,#ウィンドウを消してテキスト表示だけにする
                          what_outlines=[(3, "#000000", 2, 2), (3, "#282", 0, 0)],
                          #アウトライン
                          what_slow_cps=20 #テキスト表示速度
                          )

実行時に画像を拡大/縮小するには？ 
100を超える画像をすべてPhotoshopでリサイズするのは気の遠くなる話ですし、実行時に画像の拡大縮小ができれば、と思うことでしょう。では、その方法をお見せしましょう。 

理想的には、画像の変換には ATL を用いるべきです。 

show yourimage:
    zoom 0.5

これはyourimageを半分のサイズに縮小する方法ですが、次の方法も使えます。 


init:
    image cyan small = im.Scale("cyan.png", 16, 32)

この例では、image 文を使っており、"cyan.png" が読み込まれる画像のファイル名です。16はピクセル幅で、32が高さになります。 

im.FactorScaleを使って、1より小さい小数値を拡大率として指定することもできます。たとえば、画像を半分に縮小したいなら、次のようにします。 


init:
    image cyan small = im.FactorScale("cyan.png", .5, .5)

もし画像を拡大したい場合でも、im.Scaleを使ってピクセル単位で幅を指定するか、im.FactorScaleを使って拡大率を指定します。画像を2倍に引き延ばしたいなら、im.FactorScaleで幅と高さに2を指定してください。 

im.Scale と im.FactorScale は、プロパティとして bilinear=True を指定できます。この指定によって、拡大縮小の時の補間方法としてデフォルトのニアレストネイバー法（最近ピクセル補間）ではなく、バイリニア法（線形補間）を利用できます。詳しくは Wikipediaの記事 を参照してください。 

これらの機能についてのさらなる情報は、ドキュメント (im.Scale, im.FactorScale) を参照してください。 

メニューボタンのテキストを変更するには？ 
Ren'Py 6.12 以降では、screens.rpy に設定があります。 screen main_menu、あるいは screen navigation の記述を見つけ、その部分の設定を変更してください。 


--------------------------------------------------------------------------------

古いバージョンの Ren'Py を使っている場合は、次のコードをどこか適切な場所に挿入します。 

config.main_menu = [
        (u"はじめから", "start", "True"),
        (u"続きから", _intra_jumps("load_screen", "main_game_transition"), "True"),
        (u"環境設定", _intra_jumps("preferences_screen", "main_game_transition"), "True"),
        (u"終了", ui.jumps("_quit"), "True")
        ]

各行の最初にある値を、表示させたいテキストで置き換えてください。たとえば、"続きから"を"ロード"に置き換えることができます。そのほかの部分は、とくに意図しない限り変更しないでください。 

ゲーム中で表示されるメニューのボタンを変更するには、次のコードを使います。 

config.game_menu = [
        ( None, u"戻る", ui.jumps("_return"), 'True'),
        ( "preferences", u"環境設定", _intra_jumps("preferences_screen", "intra_transition"), 'True' ),
        ( "save", u"セーブ", _intra_jumps("save_screen", "intra_transition"), 'not main_menu' ),
        ( "load", u"続きから", _intra_jumps("load_screen", "intra_transition"), 'True'),
        ( None, u"メインメニュー", ui.callsinnewcontext("_main_menu_prompt"), 'not main_menu' ),
        ( None, u"終了", ui.callsinnewcontext("_quit_prompt"), 'True' ),
        ]

今度は各行の2番目の値を変更しますが、基本的には上と同じです。 

プレイ情報（日付・スコアなど）を表示するには？ 
Ren'Py には、デフォルトで3つのレイヤーがあります。最も上にあるレイヤーは、"overlay"と呼ばれています。 


show_date = True
month = "January"
day = 1

def date_overlay():
    if show_date:
        ui.text(month + " %d" % day, size=20, color="#ffffff")

config.overlay_functions.append(date_overlay)

この例では、"month" は現在の月の名前で、"day"は日付を表す整数値です。"if show_date" の部分で、日付表示のオン/オフを切り替えています。"show_date" が True か False かに関わらず、ゲーム開始時前にこの値を設定するようにしてください。 

ゲームのアイコンを変えるには？ 
ウィンドウの左上にあるアイコンを変えるには、次のコードを使用します。 

config.window_icon = "yourgameicon.png"

この画像は、MacOSX におけるドックやアプリケーション切り替えの際にも使われますので、256x256以上で透過背景の画像にすることを検討してください。 

もし実行ファイルのアイコンを変えたい場合には、画像ファイルを "icon.ico"、あるいは Mac の場合には "icon.icns" として保存し、ゲームディレクトリに配置してください (このディレクトリは "game" ディレクトリではなく、その一つ上のディレクトリです) 。 Ren'Py は頒布パッケージを作成する際に、このアイコンファイルを ".exe" ファイルに取り込みます。もしうまくいかなければ、resource explorer などを利用して手動で置き換えてください。Xcode のインストールされた MacOSX を使っているのであれば、Icon Composer ユーティリティで icon.ico と icon.icns の両方を生成できます。 

イメージマップを使わずにメインメニューをカスタマイズするには？ 
Ren'Py 6.12 以降では、ゲームを起動するときに screens.rpy が読み込まれます。このファイルはゲーム中で用いられるすべての画面のコードを含んでおり、スクリーン記述言語 (SL) を用いて編集できます。ファイル中の screen main_menu の記述を探して、編集を行ってください。 

古いバージョンでは、オリジナルの UI 関数を使うことができます（現在では推奨されていません）。 

label main_menu:
    scene mainmenu

    $ ui.vbox(xpos=0.5, ypos=0.5)
    $ ui.imagebutton("newgame1.png", "newgame2.png", clicked=ui.returns("start"))
    $ ui.imagebutton("loadgame1.png", "loadgame2.png", clicked=ui.returns("load"))
    $ ui.imagebutton("options1.png", "options2.png", clicked=ui.returns("prefs"))
    $ ui.imagebutton("exit1.png", "exit2.png", clicked=ui.returns("quit"))
    $ ui.close()
        
    
    $ result = ui.interact()
    
    if result == "start":
        hide mainmenu
        $ renpy.jump_out_of_context("start")
        
        
    elif result == "load":
        jump load_screen
        
    elif result == "prefs":
        jump preferences_screen
            
    elif result == "quit":
        $ renpy.quit()

    return

グラフィックと音楽の指定を置き換えるだけで、すぐに使うことができます！ 

[あらゆるもの] (anything) の表示を変えるには？ 
Ren'Py プロジェクトのすべての要素は、スタイル処理によって見た目を変えることができます。ボタン、ボックス、行やテキストはすべて、それがどのように見えるかを決めるための style プロパティを持っています。options.rpy や screens.rpy といったファイルを見れば、ゲーム起動時に読み込まれるスタイル指定を見つけることができます。たとえば、次のようなものです。 


style.default.size = 22

これらの文は、次の構文に従っています。 


style.スタイル名.プロパティ名 = 値

スタイル名: 変更したいスタイルの名前です。これについては、下のスタイルインスペクターの項も参照してください。 

プロパティ名: 指定したスタイルについて、何を変更したいかを指定します。プロパティの一覧は ここにあります。 

値: 数値、画像や音声のファイル名、色コードなど、プロパティとして設定する値です。 

スタイルの親子関係 
"default" は、ゲーム中のすべてのテキストが従うスタイルです。つまり、上のコードは、テキストフォントのサイズを22に変えていることになります。スタイルにはすべての要素が従うスタイル（"parent" style、親スタイル）と、それを継承しつつ一部のスタイルを変更したもの（"child" style、子スタイル）があります。スタイル変更を行うときには、親子関係をつねに考えておくべきです。 


style.button_text.text = 30
style.button_text.color = "#000"

style.pref_button_text.color = "#FFF"

"button_text" は親スタイル、"pref_button_text" は "button_text" から派生した子スタイルです。したがって、"button_text" と "pref_button_text" のテキストサイズは同じく30ですが、"button_text" のフォントカラーは黒で、"pref_button_text.color" では白になります。子スタイルで再定義されないプロパティは、すべて親スタイルから引き継がれます。 

スタイルインスペクター 
Ren'Py には、スタイルインスペクターと呼ばれる機能があります。config.developer を True にした状態（これがデフォルトです）でゲームを起動してください。そして、要素の上にマウスポインタを置きます。テキストの場合は線が細いので、少し難しいかもしれません。そうしたら、SHIFT + I キーを押してください。次のようなポップアップが表示されるはずです。 

 古いバージョンでは、このように表示されます。 

このスクリーンでは、マウスポインタのある要素に影響を及ぼしているすべてのスタイル指定を見ることができます。ほとんどの場合は、最後にあるスタイルを見ることになるでしょう。この例では、ダイアログボックスのキャラクター名ウィンドウを対象としました。キャラクター名の表示を変えているスタイルは、一番最後にある say_label だということがわかります。 

スタイルについてひととおり見てきたので、もうどんなプロパティでも編集することができますね。もしコードをどこに書くべきか分からなければ、とりあえずoptions.rpyの最後に書いてください。 

ゲームデザイン 
Princess Makerのように、スケジュールのあるシミュレーションを作るには？ 
 

DSE Framework
Dating-Sim framework が ここ から利用できます。必要に合わせて、カスタマイズを行ってください。このフレームワークについての情報は、 ここ を参照してください。 
Fate Stay/Nightのように、画面全体にテキストを表示するには？ 
 

NVL-mode Example
Ren'Py には、NVLと呼ばれる特別なテキストモードがあります。これについての詳しい情報は、ここを参照してください. 

RPGを作るには？ 
残念ながら、現時点ではロールプレイングゲームを作るためのフレームワークはありません。Ren'Pyはそのようなゲームのためにデザインされたわけではないので、戦闘システムや所持品リスト、そのほか必要なものすべてを自作しなければなりません。 

それでもRPGを作りたいと思うなら、CookbookのRPG Frameや、ParsonSyunOwenによるFighting Fantasy demoが、役に立つかもしれません。 

Ren'Pyで作成したゲームを販売することはできますか？ 
"The Ren'Py license does two things:

- Prevents you from claiming you wrote Ren'Py.
- Disclaims any warranty liability on my behalf.

The LGPL (which is the controlling license for distribution of Ren'Py games) also 
requires that you have a link to http://www.renpy.org/dl/lgpl/ as part of your game."

- PyTom
訳： 

"Ren'Pyは、次の二つを規定しています:

- あなた自身がRen'Pyを作成したと主張しないこと。
- 私にはいかなる保証責任もないこと。

Ren'Pyの配布ライセンスであるLGPLはさらに、ゲームの一部にhttp://www.renpy.org/dl/lgpl/へのリンクを含めることを求めています。"

-PyTom
版権素材を用いた二次創作ゲームは作れますか？ 
(次を参照してください: Can I sell my game?) 

音楽や背景素材、キャラクター、その他のツールはどこで手に入りますか？ 
OELVN wikiにはフリーで使える素材やその他諸々があるので、チェックするとよいでしょう。あるいは、Lemma Soft Recruitment forumsで質問することもできます。 

テクニカルな部分 
ゲーム終了後にメインメニューに戻るには？ 

$ renpy.full_restart()

このコードは、メインメニューにジャンプし、すべての音楽や効果音を停止するので、ゲームスクリプトの最後の最後にこれを記述してください。(訳注: おそらくこれを書いた人は、ゲームの最後以外でこれを使うことを望んでいません。関数名を見れば分かりますが、これはすべてをなかったことにしてゲームを再起動する関数です。) 

メニューが表示されている間でも、テキストボックスが表示され続けるようにするには？ 
次のように、"menu"ヘッダーの後ろにインデントされた行を挿入します。 

menu:
    "リンゴはどこ？"
    "あっちだよ":
        jump lie
    "ここにあるよ":
        jump truth

フェード (Fade) とディゾルブ (Dissolve) の違いは？ 
Ren'Py のデフォルトでは、一般にフェードと呼ばれる、画像の透明度を徐々に変える2つのタイプのトランジションが用意されています。 

ディゾルブ (Dissolve) 一枚の画像をフェードアウトさせます。これは背景またはキャラクターに対して適用されますが、"with dissolve" を利用した場合にはその画像だけがフェードイン/アウトします。 

show eileen with dissolve

フェード (Fade) ディゾルブをかける前に、スクリーン全体をブラックにします。もしキャラクターに対して "with fade" を適用した場合、スクリーン全体が消えてしまいます！ 

show bg forest with fade

フェードやディゾルブのタイミングを調整するには？ 
Dissolve ディゾルブを再定義するか、あるいは次のようにして新しいトランジションを作成できます。 

$ dissolve = Dissolve(0.5)

0.5という数値は、トランジションに何秒かけるかを表しています。この値を2.0とすれば、これは2秒間かけてディゾルブすることになります。 

Fade フェードを再定義するか、あるいは次のようにして新しいトランジションを作成できます。 

$ fade = Fade(0.5, 0, 0.5)

3つの数字は、フェードの段階ごとに何秒かけるかを示しています。3つの段階は、最初の画像のフェードアウト、ブラックスクリーン、次の画像のフェードインです。 

トランジションに違う名前をつけると、オリジナルのフェードやディゾルブを残したまま新しいトランジションを定義することもできます。新しいトランジションも、これまでと同じ方法で呼び出すことができます。 

$ slow_dissolve = Dissolve(3.0)

show Bunny with slow_dissolve

ゲームスクリプトを複数のファイルに分割するには？ 
複数のスクリプトファイルを扱うときには、2つのことを知っておく必要があります。ひとつは、gameディレクトリ下にある.rpyで終わるすべてのファイルを、Ren'Pyはスクリプトファイルとして扱うということです。そしてもうひとつは、Ren'Pyは複数のファイルを単にひとつの巨大なファイルとして扱うということです。 

これはつまり、あるスクリプトファイルで定義されたラベルや画像、変数は、別のスクリプトファイルでも利用できるということです。一つのファイルに書かれているときと同じように、異なるファイルに書かれたラベルへとジャンプしたり、コードを呼び出したりすることができます。 

二つのファイルに分かれた短いゲームをご紹介しましょう。まず、これが"script.rpy"の内容です。 


image bg script = "bg_script.jpg"
image bg day1 = "bg_day1.jpg"

label start:
    scene bg script

    "これはscript.rpyです。" 
    
    "クリックすると、違うファイルにジャンプします。"

    jump day1

そしてこれが、"day1.rpy"の内容です。 


label day1:

    "day1.rpyに来ました。"

    scene bg day1

    "このように、違うファイルで定義された画像や変数にもアクセスできます。"

    # ... さらに続く ...

ゲームスクリプトの構成方法は、個人個人の好みの問題です。あるゲームはひとつかふたつのスクリプトファイルで、またあるゲームは30を超えるスクリプトで構成されることもあります。 

ロールバック機能を無効化するには？
ロールバックはRen'Pyエンジンの高度な機能で、きちんとした理由があって実装されています。もしプレイヤーがどこまでもロールバックするのを防ぎたいなら、renpy.block_rollback関数を使うことができます。この関数がコールされると、プレイヤーはそれより以前へのロールバックができなくなります。 

一方、このコードは、ロールバック機能を完全に無効化します。このコードはinitブロックに記述してください。 

$ config.rollback_enabled = False

ゲーム内メニューへのアクセスを無効化するには？ 
デフォルトでは、ESCキーか右クリックすればいつでも、ロード/セーブや環境設定などを行うゲームメニューにアクセスできます。これを無効化するには、デフォルトメニュースクリーンにNoneをセットします。 

$_game_menu_screen = None

メニューを復活させたいときには、ポップアップするスクリーンの値をセットします（デフォルトでは、これはセーブメニューです）。 

$_game_menu_screen = "save_screen"

次のコードを使うと、右クリック/ESCキーを押したときに別のスクリーンへと飛ばすことができます。 

$_game_menu_screen = "custom_screen"

この例では、"custom_screen"ラベルがスクリプトのどこかに存在すると想定しています。 

マウスの座標を取得するには？ 
残念ながら、現時点ではマウスの座標を取得する方法はありません。Ren'Pyは多くのタイプのコントローラーに対応できるように設計されているからです。 

"... it is possible to get mouse coordinates in Ren'Py - just use a user-defined displayable."
-PyTom
訳: 

"... Ren'Pyでマウス座標を取得することはできます――ユーザー定義のdisplayableを使えば、の話ですが。"
-PyTom
イメージマップのホットスポットを利用すれば、ある程度マウスの位置を取得することはできます。あるいは知識が必要ですが、開発者ツール (Shift+D) の"Image Location Picker" を使うこともできます。この場合、マウス座標は画像の位置として取得されます。 

セーブされたゲームデータを削除するには？ 
バージョン 6.9.3 以降 
Ren'Py のランチャーで "Tools" を選択し、"Delete Persistent" を選びます。 

バージョン 6.9.2 - 6.9.0 
データが保存されたフォルダを手動で削除します。一般的なWindowsマシンでは、次の場所にあります。 

C:\Documents and Settings\YOURNAME\Application Data\RenPy
"YOURNAME"は、コンピューター上でのユーザー名です。このフォルダの中にあるデータを消してください。 

バージョン 6.9.0 未満
セーブデータはRen'Py内のゲームフォルダの中に、"Saves" フォルダとして存在します。このフォルダの中にあるデータを消してください。 

ゲームのリリース前に、セーブデータを消去する必要がありますか？ 
ありません。Ren'Py はスクリプトをコンパイルする際に、セーブデータや永続データをエクスポートしません。セーブデータの保存場所を "game" フォルダ内に変更しない限り、リリースの際にセーブデータを消す必要はありません。もし変更している場合は、"saves" フォルダーを見つけて、消去する必要があります。"game" フォルダ内に "saves" フォルダが存在しなければ、問題ありません。 

インデントの働きは？ブロックとは何ですか？ 
Ren'Py、そしてPythonのブロックがどう働くのかを理解するのは大変なことです、あなたがサンプルコードを自分のゲームに組み込もうとしているなら、とくにです。Ren'PyとPythonは、インデントについて細かい規則があります――ここでは、ブロックがどのように作られているかを見ていきます。 

 

上の画像では、いくつかの行をまとめた色の付いたラインが「ブロック」を表しています。このブロックは入れ子構造になっており、それぞれブロックの開始位置となる一行に「属して」います。 

たとえばこの例では、選択肢である "Say hello" と "igonore her" は、'menu:'の行に「属して」いることになります。 

ブロック内部の行はすべて、それを「所有する」行よりもさらに深くインデントされていなければなりません。上の例では、メニューに属する行はすべて "menu:" の行よりも深くインデントされています。もし二つの行が同じブロックに属し、同じレベルにあるなら、そのインデント量は等しくなければなりません。インデントやインデント解除はブロックの制御だけに用いられるので、もしそれまでに存在しないインデント量の、ブロック開始行でない行が出現すると、 Ren'PyやPythonはエラーを返します。 

ブロックを開始するための行は、常にコロン (':') で終わります。それ以外の行はコロン以外の文字で終わりますし、ブロック開始行以降の行はさらにインデントされなければなりません。 

ブロックは、その開始行と同じかそれより浅いインデントレベルの行が出てくるまで続きます。上の例では、"python:" で始まったブロックは "e" で始まる行の手前まで続き、会話に戻ります――なぜなら、"e" で始まる行は、"python:" で始まる行と同じインデントを持つからです。 

ブロックは、さらに別のブロックを含みます――上の例では、グレーのラインで表されたブロックはオレンジの "python:" のブロックに「含まれて」おり、さらにそれはブルーの "label start:" のブロックに含まれています。 

ブロックを用いる理由の一つは、.rpy ファイルが Ren'Py スクリプトと Python の、二つの種類のコードを含むからです。Python のコード*を記述するためにpython statement を使って Python のブロックを開始したら、その中では Python のコードを書かなければならず、"show eileen happy" や "menu:" といった通常の Ren'Py のスクリプトは使えません。Python コードの中から Ren'Py のスクリプトに戻る方法は、インデントを戻してブロックを終了することだけです。上の例でいえば、ピンクの部分は Python のブロックであり、Python のコードを記述しなければなりません。 

さらに、'$' マークを使って Ren'Py スクリプトのエリアで Python の一行コードを書くとき、'$' マークは使えません―― Python コードの中では、このマークは Ren'Py スクリプトとして解釈されないからです。 

* ここでいう Python のコードとは、"init python:" あるいは他の修飾詞付きの 'init' ブロックも含まれます。 

ゲームファイルを外から見えないようにするには？ 
ゲームをリリースする前に、ゲームで使うすべてのファイルをひとつのアーカイブファイルへとパッケージングすることができます。これを行うには Ren'Py ランチャーの中の "Archive Files" メニューを使用してください。このメニューをクリックすると、アーカイブファイルの名前と、どのファイルをアーカイブするかを指定できます。アーカイブして隠したいファイルの種類をここに追加してください。 

アーカイブ処理が終わると、"game" フォルダーにあったすべてのファイルが、"archived" フォルダーへと移動されます。もし再びファイルの修正が必要になったら、アーカイブを削除し、"archived" フォルダーの中身をすべて "game" フォルダーに戻してください。アーカイブを残したまま古いファイルを書き換えると、ふたつのバージョンのスクリプトが混在することになり、クラッシュを引き起こします。 

したがって、アーカイブ処理は、配布するための準備が完全に整ったあとに行うのが一番いいでしょう。 

互換性 
ユニコード文字 (中国語・日本語など) を使うには？ 
[renpy/doc/cookbook/Chinese_and_Japanese この記事] に、Ren'Py で特殊な文字を使うための方法があります。 

もしキャラクター名や他のタイトルなどでユニコード文字を使いたい場合は、単にクオーテーションマークの前に "u" をつけるだけです。 

config.window_title = u"尾張国の女"


$ h = DynamicCharacter("hname", color="#FCE1E8")
$ hname = u"はる"

さらに詳しい情報は、Cookbook の中の [renpy/doc/cookbook/Cookbook ローカリゼーション] を参照してください。 

Ren'Py で Flash は使えますか？ 
使えません。現状では、Ren'Py は Flash のファイルをサポートしていません。 

Ren'Py でアニメーション GIF は使えますか？ 
使えません。Ren'Py はアニメーション GIF をサポートしていませんし、サポートの予定もありません。アニメーションを使いたい場合は、Animation関数を使うか、理想的には複数の画像からアニメーションを構成する機能である ATL を用います。 

手元のビデオや音楽が、Ren'Py で再生できないのですが？ 
使用可能なコーデックのリストを参照して、そのファイルがあるかどうか探してください。もしなければ、適当なフォーマットに変換する必要があります。 

Ren'Py は iPhone のような他のプラットフォームでも利用できますか？ 
たぶん、いやきっと、無理でしょう。Apple EULA は iPhone や iPod, iPad などの自社製品上で Ren'Py を動かせないとしていますし(訳注: これはおそらく、Python のインタープリタを含んでいるからです)、NintendoDS などのデバイスでは、Ren'Py が動かせるほどのメモリを積んでいません。 

いまのところ、Android では動作します。 

トラブルシューティング 
"menuitem expects a non-empty block" とは？ 
メニューアイテムは、プレイヤーが選択したときの動作を表すコード（つまり、「ブロック」）をかならず含まなければなりません。このコードはかならずメニューアイテムの行よりも深くインデントされている必要があります。正しく整形されたメニューの例は、 http://www.renpy.org/wiki/renpy/doc/tutorials/Quickstart#Menus.2C_Labels.2C_and_Jumps を参照してください。 

アーカイブを行っても "archived" フォルダーが現れません！ 
"archived" フォルダーは、"game" フォルダーと同じく、プロジェクトディレクトリのひとつ下にできるはずです。もしこのフォルダーが見つからない場合は、OSによって隠されているかもしれません。Windows のデフォルトでは、「隠しフォルダ」のマークの付いたフォルダは表示されないため、アーカイブフォルダを表示するには、フォルダセッティングを変更する必要があるかもしれません。 

Windows Vista: フォルダ画面で Alt キーを押し、メニューバーを表示させます。ツール -> フォルダーオプションの「表示」タグを開き、「隠しファイル、隠しフォルダー、および隠しドライブを表示する」を選択します。 

"couldn't find file [yourfile.jpg]" が表示され続けるのですが？ 
何らかの問題により、Ren'Py がファイルを見つけられないのかもしれません。チェックリストを試してください。 

ファイルの場所を正しく指定していますか？ 
Ren'Py でクオーテーションを用いてファイルを指定した場合 ("trees.jpg") 、game フォルダの直下のみを検索します。もしそれ以外のフォルダにファイルを置いているなら、指定する際にそれを記述しなければなりません。たとえば、画像ファイルを "BG" フォルダの中に置いているなら、画像指定は "BG/trees.jpg" とします。 

コード中の名前と実際のファイル名が一致していますか？ 
ファイル名をコードに記述するときにはコピーアンドペーストを使い、目で見て写すのはやめましょう。つまらないミスを減らすためです。Ren'Py は大文字小文字を区別します (case-sensitive)。フォルダもファイルも同じように、同じキャピタリゼーションを使ってください。これはとくに、複数のOSで動くゲームを作るときに重要です。 

拡張子は合っていますか？ 
フォルダオプションを変更して、すべてのファイルの拡張子が見えるようにしてください。デフォルトではふつう、拡張子は見えないようになっています。ゲームを開発するときには拡張子は重要ですので、今すぐ設定をしましょう。 

もしあるファイルの拡張子が見えている（たとえば "trees.jpg" など）のに、他のファイルの拡張子が 見えない 場合、".jpg" はファイル名の一部であって、本当の拡張子ではないかもしれません！ 
 

拡張子の表示を切り替えるには、OSのフォルダオプションメニューを開き、「拡張子を隠す」オプションを無効にしてください。 

Windows Vista: Click "Organize" at the top of any folder view, and then "Folder and search options." Click the "View" tab, and untick "Hide extensions for known file types." You should now be able to see all the extension of your files within folders! 

Windows XP: Click "Tools", and then "Folder Options." Click the "View" tab, and untick "Hide extensions for known file types." You should now be able to see all the extension of your files within folders! 

Mac OS X: To enable this on a global basis, activate Finder, go to Finder -> Preferences... -> Advanced and check "Show all file extensions". Note that Mac OS X can also display filenames on a per-file basis, which is preferred to the global version; If a filename is not displayed, select the file, press Command+I (or right-click and select Show Info) and uncheck "Hide Extension". To do this for multiple files, select all of them and press Alt+Command+I instead. 

ここまでできたら、ファイルの拡張子が Ren'Py で指定したものと合っているかどうかを確認してください。よくある間違いは、".jpeg" と書くべきところを ".jpg" と書くことです。 

コードは正しいのに、イメージマップが壊れて見えるのですが？ 
最新の Ren'Py では、スペースを省くためにメニュー画像をキャッシュ使用とします。ゲームフォルダーの中をのぞくと、 "cache" という名前のフォルダーがあると思います。自分でメニューを作り直した場合、古いバージョンのキャッシュによって新しいバージョンの見え方がおかしくなることがあります。この場合は、"cache" フォルダーを削除すれば解決するはずです。 

次のコードによって、キャッシュを完全に無効にすることもできます。 

config.imagemap_cache = False

カスタマイズしたメインメニューにジャンプしないことがあるのですが？ 
もしカスタマイズしたメインメニューの他に Ren'Py のデフォルトのメニューを残しているなら、ふたつのバージョンが衝突しているため、どちらかを取り除く必要があります。Screen language の実装では、Ren'Py は screens.rpy に記述された構成を使ってゲームを開始します。もし自分の独自のメニューを使い、 screens.rpy のコードを使用しないのであれば、screen main_menu の部分をコメントアウトするか、コードを削除してください。 

Retrieved from "http://www.renpy.org/wiki/renpy/ja/doc/FAQ"
Views
Page 
page discussion 
View source 
Page History 
Personal tools
Log in / create account 
Navigation
Home Page 
Why Ren'Py? 
Download Ren'Py 
Ren'Py Games 
Launchpad 
Search
     
Documentation
Tutorials 
FAQ 
Cookbook 
Translations 
Reference 
Editors 
Frameworks 
Forum 
Wiki
What links here 
Related changes 
Special pages 
Printable version 
Permanent link 

This page was last modified on 27 July 2012, at 13:52. 
This page has been accessed 1,991 times. 

Most pages on this site are open for anyone (with an account) to edit. If you feel you can make things better, log in and click "edit".


--------------------------------------------------------------------------------
[2012-11-21 00:28]

