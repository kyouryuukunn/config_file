?? TITLE : C++ アルゴリズム

cppreference.com -> C++ アルゴリズム

C++ アルゴリズム

この項目はStandard Template Library プログラミング on the Webより引用しています。引用を快く許可してくれたεπιστημηさんに感謝します。
                                            STLの中心的存在がアルゴリズムです。
                                         コンテナ、イテレータ、関数オブジェクト
                                         はどれもアルゴリズムを機能させるために
                                             用意されたと言ってもいいでしょう。

アルゴリズムはコンテナに対する汎用的な操作を提供します。コンテナ(データ構造)とアルゴリズムはイテレータ(コンテナ内の要素にアクセスするためのオブジェクト)を介して結び付けられます。

STLのほとんどのアルゴリズムには入力となる要素の集合を2つのイテレータで指定します。ひとつは集合の先頭を指すイテレータfirst、もうひとつは集合の末尾の次を指すイテレータlastです。すなわちアルゴリズムはfirstから始まりlastに達しない範囲(first以上last未満)にある要素を入力とします。

末尾位置を指定するのに"末尾の次"を使うのは、

  * 要素数0の集合を与えることができるから
  * 要素数がlast-firstと一致するから

です。 アルゴリズムはおおまかに以下の４種類のカテゴリに分類されます。

  * 検索・走査アルゴリズム
  * 配列操作アルゴリズム
  * ソート関連アルゴリズム
  * その他のアルゴリズム

表の読み方
略記号  イテレータ種別(下にあるものは上のイテレータの機能も持つ)
I  input_iterator
O  output_iterator
F  forward_iterator
B  bidirectional_iterator
R  random_iterator
T  イテレータ以外の型

(I, I)というのは、一つの配列で、先頭と終端を表すinput_iteratorを引数に持つ。(I, I), Iは二組配列を示す。後者の配列はoutput_iterator以外の場合には前者と同じか、大きい要素数を持っている必要がある。(F, F), (F, F)は二組の配列の先頭と終端を表すforward_iteratorを二組、計４個引数にとるということを表している。配列のサイズは同じである必要はない。(F, F, F)のように３個のイテレータが指定されているものは、一つの配列を真ん中のイテレータを境に前半と後半に分けて２つの配列として扱うアルゴリズムである。

find----------------------------------------------------------------------------------


?? TITLE : 検索・走査アルゴリズム

cppreference.com -> C++ アルゴリズム -> 検索・走査アルゴリズム

検索・走査アルゴリズム

配列の値を一切変更しないアルゴリズムです。

※表の読み方

<algorithm>で定義されているもの

count()  (I, I)  値が一致する要素の数を返す
count_if()  (I, I)  条件に合う要素の数を返す
equal()  (I, I), I  ２つの配列を比較し、すべて一致したらtrueを返す
find_end()  (F, F), (F, F)  配列１の一部と配列２が部分一致したら、その最後の位置を返す
find()  (I, I)  配列を走査して値が最初に一致した要素の位置を返す
find_first_of()  (F, F), (F, F)  配列１の一部と配列２が部分一致したら、その最初の位置を返す
find_if()  (I, I)  配列を走査し、最初に条件に一致した位置を返す
for_each()  (I, I)  すべての要素に対して、指定された振る舞いを実行する
lexicographical_compare()  (I, I), (I, I)  ２つの配列を辞書順に比較し、前者が先ならtrueを返す
max_element()  (F, F)  配列の中の最大の要素の位置を返す
min_element()  (F, F)  配列の中の最小の要素の位置を返す
mismatch()  (I, I), I  ２つの配列の不一致箇所を見つける
search()  (F, F), (F, F)  配列１の一部と配列２が部分一致したら、その最初の要素の位置を返す
search_n()  (F, F)  連続した個数の要素を見つけ、その位置を返す


args-------------------------------------------------------------------------------------- 


?? TITLE : 配列操作アルゴリズム

cppreference.com -> C++ アルゴリズム -> 配列操作アルゴリズム

配列操作アルゴリズム

要素の追加、削除、変更を伴うアルゴリズムです。<algorithm>で提供されます。

※表の読み方

copy()  (I, I), O  配列をコピーする
copy_backward()  (B, B), B  配列を逆順にコピーする
fill()  (F, F)  配列を与えられた値で埋める
fill_n()  O  配列を与えられた個数分の指定値で埋める
generate()  (F, F)  配列を、与えられた関数の返値で埋める
generate_if()  O  配列を与えられた個数分、指定された関数の返値で埋める
iter_swap()  F, F  ２つのイテレータが指す要素を交換する
random_shuffle  (R, R)  配列をシャッフルする
remove()  (F, F)  配列の中の、与えられた値と同じ要素を削除する
remove_if()  (F, F)  配列の中の、条件に合う要素を削除する
remove_copy()  (I, I), O  与えられた値と同じ要素以外を新しい配列にコピーする
remove_copy_if()  (I, I), O  条件に合う要素以外を新しい配列にコピーする
replace()  (F, F)  配列の中の古い値を、新しい値に置換する
replace_if()  (F, F)  配列の中の条件に合う要素を、新しい値に置換する
replace_copy()  (I, I), O  配列の中の古い値を、新しい値に置換しながら新しい配列にコピーする
replace_copy_if()  (I, I), O  配列の中の条件に合う要素を、新しい値に置換しながら新しい配列にコピーする
reverse()  (B, B)  配列の要素を反転させる
reverse_copy()  (B, B), O  要素を反転させつつ、新しい配列にコピーする
rotate()  (F, F, F)  同じ配列内で、前半と後半を入れ替える
rotate_copy()  (F, F, F), O  前半と後半を入れ替えながら新しい配列にコピーする
swap_range()  (F, F), F  ２つの配列の内容を交換する
transform()  (I, I), O
(I, I), I, O  １つ、あるいは２つの配列に操作を加えながら、新しい配列に出力する。
unique()  (F, F)  隣接する同じ要素を削除する
unique_copy()  (I, I), O  隣接する同じ要素をのぞいて、新しい配列にコピーする

sort-------------------------------------------------------------------------------------- 


?? TITLE : ソート関連アルゴリズム

cppreference.com -> C++ アルゴリズム -> ソート関連アルゴリズム

ソート関連アルゴリズム

配列のソート、ソートの準備、ソート後の配列に対する操作などのアルゴリズムです。<algorithm>で提供されます。

※表の読み方

binary_search()  (F, F)  ソート済みの配列に対して二分検索を行い、与えられた値と同じものがあればtrueを返す
equal_range()  (F, F)  ソート済みの配列に対して、与えられた値と同じ値を持つ範囲を返す
includes()  (I, I), (I, I)  ソートされた配列同士を比較し、後者の配列のすべての要素が含まれていればtrueを返す
inplace_marge()  (B, B, B)  前半と後半がそれぞれソートされた配列マージソートする
lower_bound()  (F, F)  ソート済みの配列に対して、与えられた値と同じかそれより大きい最初の要素の位置を返す
make_heap()  (R, R)  与えられた配列を並べ替え、ヒープ化(親>子となる木構造)する
merge()  (I, I), (I, I), O  ２つのソート済み配列をマージソートして新しい配列に結果を書き出す
next_permutation()  (B, B)  配列を辞書順に並び替える
nth_element()  (R, R, R)  最初の状態のn番目の要素よりも大きい値の集合を前に、小さい値の集合を後ろに集める
partial_sort()  (R, R, R)  前半部分に小さい要素を集めてソートする。後半部分は不定
partial_sort_copy()  (I, I), (R, R)  配列の要素のうち、小さいものから別の配列にコピーする
partition()  (B, B)  条件に合う要素を配列の前半に集める
prev_permutation()  (B, B)  配列を辞書の反対(降順)に並び替える
pop_heap()  (R, R)  ヒープ化された配列の先頭の最大値の要素を削除して、ヒープを再構築する
push_heap()  (R, R)  ヒープ化された配列の最後尾に追加された要素を加えてヒープを再構築する
set_difference()  (I, I), (I, I), O  ソート済みの２つの配列の差集合を他の配列にコピーする
set_intersection()  (I, I), (I, I), O  ソート済みの２つの配列の積集合を他の配列にコピーする
set_union()  (I, I), (I, I), O  ソート済みの２つの配列の和集合を他の配列にコピーする
set_symmetric_difference()  (I, I), (I, I), O  ソート済みの２つの配列のどちらか一方にのみ存在する要素を他の配列にコピーする
sort()  (R, R)  配列をソートする
sort_heap()  (R, R)  ヒープ化された配列をソートする
stable_partition()  (B, B)  条件に合う要素を、最初の順序を守りながら前半に集める
stable_sort()  (R, R)  配列を、最初の順序を守りながらソートする
upper_bound()  (F, F)  ソート済みの配列に対して、与えられた値より大きい最初の要素の位置を返す

other--------------------------------------------------------------------------------- 


?? TITLE : その他のアルゴリズム

cppreference.com -> C++ アルゴリズム -> その他のアルゴリズム

その他のアルゴリズム

イテレータを必要とせず、汎用的な演算、操作を提供します。<algorithm>で提供されます。

※表の読み方

max()  T, T  大きい方の値を返す
min()  T, T  小さい方の値を返す
swap()  T, T  ２つの要素を交換する


