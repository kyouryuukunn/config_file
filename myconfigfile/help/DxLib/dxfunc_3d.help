-------------------------------------------------------------------------------
３Ｄ図形描画関数

宣言 int DrawLine3D( VECTOR Pos1, VECTOR Pos2, int Color ) ;

概略 ３Ｄ空間に線分を描画する

引数   VECTOR Pos1 ： 線分の始点の座標
VECTOR Pos2 ： 線分の終点の座標
int Color ： 線分の色
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に Pos1 と Pos2 の座標を結ぶ線分を Color で指定した色で描画します。

　引数 Pos1 と引数 Pos2 は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。


// 例：座標 ( 0.0f, 100.0f, 0.0f ) , ( 200.0f, 100.0f, 0.0f ) を結ぶ白色の線分を描画する
DrawLine3D( VGet( 0.0f, 100.0f, 0.0f ), VGet( 200.0f, 100.0f, 0.0f ), GetColor( 255,255,255 ) ) ;

　Colorの値は画面の色の表現できる色の数によってかわってきます。 この色の値はライブラリの関数『GetColor』を使って取得します。
サンプル

　　３Ｄ空間上に線分を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 100.0f, 0.0f ), VGet( 300.0f, 200.0f, 0.0f ), GetColor( 255,255,255 ) ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawTriangle3D( VECTOR Pos1, VECTOR Pos2, VECTOR Pos3, int Color, int FillFlag ) ;

概略 ３Ｄ空間に三角形を描画する

引数   VECTOR Pos1 ： 三角形を形成する頂点１の座標
VECTOR Pos2 ： 三角形を形成する頂点２の座標
VECTOR Pos3 ： 三角形を形成する頂点３の座標
int Color ： 三角形の色
int FillFlag ： 三角形の中身を塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に Pos1 と Pos2 と Pos3 を三頂点とする三角形を Color で指定した色で描画します。

　引数 Pos1、Pos2、Pos3 は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことが出来ます。


// 例：
// 座標 ( 100.0f, 100.0f,   0.0f ),
//      ( 200.0f, 200.0f,   0.0f ),
//      ( 200.0f, 250.0f, 100.0f ) を結ぶ三角形を描画する
DrawTriangle3D(
	VGet( 100.0f, 100.0f,   0.0f ),
	VGet( 200.0f, 200.0f,   0.0f ),
	VGet( 200.0f, 250.0f, 100.0f ), GetColor( 255,255,255 ), FALSE ) ;

　Colorの値は画面の色の表現できる色の数によってかわってきます。 この色の値はライブラリの関数『GetColor』を使って取得します。


サンプル

　　３Ｄ空間上に三角形を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() DrawTriangle3D(
		VGet(100.0f,100.0f,  0.0f),
		VGet(500.0f,400.0f,  0.0f),
		VGet(600.0f,100.0f,100.0f), GetColor( 255,255,255 ), FALSE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawSphere3D( VECTOR CenterPos, float r, int DivNum, int DifColor, int SpcColor, int FillFlag ) ;

概略 ３Ｄ空間に球を描画する

引数   VECTOR CenterPos ： 球の中心座標
float r ： 球の半径
int DivNum ： 球を形成するポリゴンの細かさ
int DifColor ： 球の頂点ディフューズカラー
int SpcColor ： 球の頂点スペキュラカラー
int FillFlag ： 球を塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に CenterPos を中心座標とした半径 r の球を描画します。

　DivNum は球を形成するポリゴンの細かさです。

　引数 CenterPos は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことが出来ます。


// 例：座標 ( 320.0f, 100.0f, 0.0f ) を中心に半径 80.0f の球を描画する
DrawSphere3D( VGet( 320.0f, 100.0f, 0.0f ), 80.0f, 16, GetColor( 255,0,0 ), GetColor( 0,0,0 ), FALSE ) ;

　引数 DifColor と SpcColor はそれぞれ球の頂点ディフューズカラーと頂点スペキュラカラーです、 この関数で描かれる球はライティング計算が行われるので、 ただの「描画カラー」ではなくライティング計算で使用される「頂点ディフューズカラー( 拡散光色 )」と「頂点スペキュラカラー( 反射光色 )」を指定します。
　この二つの色の値はライブラリの関数『GetColor』を使って取得します。
　尚、この引数で指定する値は球を描画する際に用意される頂点データに含まれるディフューズカラーとスペキュラカラーですので、 SetMaterialUseVertDifColor や SetMaterialUseVertSpcColor で頂点カラーを使用しない設定にした場合はこの引数の値は使用されず、 SetMaterialParam の引数で指定されたマテリアルのディフューズカラーとスペキュラカラーがそれぞれ使用されます。

　因みに球の中身を塗りつぶす場合、 ＺバッファとＺバッファへの書き込みをそれぞれ SetUseZBuffer3D 関数と SetWriteZBuffer3D 関数で有効にしておかないと手前の面を描画した後に後ろの面が描画されたりして正常な見た目になりませんので注意してください。

サンプル

　　３Ｄ空間上に球を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// ３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 320.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 255,0,0 ), GetColor( 255, 255, 255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawCapsule3D( VECTOR Pos1, VECTOR Pos2, float r, int DivNum, int DifColor, int SpcColor, int FillFlag ) ;

概略 ３Ｄ空間にカプセルを描画する

引数   VECTOR Pos1 ： カプセルを形成する二点中の一点の座標
VECTOR Pos2 ： カプセルを形成する二点中の一点の座標
float r ： カプセルの幅
int DivNum ： カプセルを形成するポリゴンの細かさ
int DifColor ： カプセルの頂点ディフューズカラー
int SpcColor ： カプセルの頂点スペキュラカラー
int FillFlag ： カプセルを塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間にカプセルを描画します。

　この関数は大きさ r の Pos1 と Pos2 を中心座標とするカプセルの外側を結んだような形のカプセルを描画します。
　DivNum はカプセルを形成するポリゴンの細かさです。

　引数 Pos1 と Pos2 は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことが出来ます。


// 例：
// 座標 ( 320.0f, 100.0f, 0.0f ) と ( 320.0f, 300.0f, 0.0f ) を２点とする
// 半径 40.0f のカプセルを描画する
DrawCapsule3D( VGet(320.0f,100.0f,0.0f), VGet(320.0f,300.0f,0.0f), 40.0f,8,GetColor(255,255,0), FALSE);

　引数 DifColor と SpcColor はそれぞれカプセルの頂点ディフューズカラーと頂点スペキュラカラーです、 この関数で描かれるカプセルはライティング計算が行われるので、 ただの「描画カラー」ではなくライティング計算で使用される「頂点ディフューズカラー( 拡散光色 )」と「頂点スペキュラカラー( 反射光色 )」を指定します。
　この二つの色の値はライブラリの関数『GetColor』を使って取得します。
　尚、この引数で指定する値はカプセルを描画する際に用意される頂点データに含まれるディフューズカラーとスペキュラカラーですので、 SetMaterialUseVertDifColor や SetMaterialUseVertSpcColor で頂点カラーを使用しない設定にした場合はこの引数の値は使用されず、 SetMaterialParam の引数で指定されたマテリアルのディフューズカラーとスペキュラカラーがそれぞれ使用されます。

　因みにカプセルの中身を塗りつぶす場合、 ＺバッファとＺバッファへの書き込みをそれぞれ SetUseZBuffer3D 関数と SetWriteZBuffer3D 関数で有効にしておかないと手前の面を描画した後に後ろの面が描画されたりして正常な見た目になりませんので注意してください。



サンプル

　　３Ｄ空間上にカプセルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// ３Ｄ空間上にカプセルを描画する
	DrawCapsule3D( VGet( 320.0f, 100.0f, 0.0f ), VGet( 320.0f, 300.0f, 0.0f ), 40.0f, 8, GetColor( 0,255,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawCone3D( VECTOR TopPos, VECTOR BottomPos, float r, int DivNum, int DifColor, int SpcColor, int FillFlag ) ;

概略 ３Ｄ空間に円錐を描画する

引数   VECTOR TopPos ： 円錐の頂点の座標
VECTOR BottomPos ： 円錐の底辺の中心座標
float r ： 円錐の底辺の半径
int DivNum ： 円錐を形成するポリゴンの細かさ
int DifColor ： 円錐の頂点ディフューズカラー
int SpcColor ： 円錐の頂点スペキュラカラー
int FillFlag ： 円錐を塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に TopPos を頂点、BottomPos を底辺の中心とした半径 r の円錐を描画します。
　DivNum はカプセルを形成するポリゴンの細かさです。

　引数 TopPos と BottomPos は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことが出来ます。


// 例：
// 座標 ( 320.0f, 400.0f, 0.0f ) を頂点
//      ( 320.0f, 100.0f, 0.0f ) を底辺の中心とした円錐を描画する
DrawCone3D( VGet(320.0f,400.0f,0.0f), VGet(320.0f,100.0f,0.0f),80.0f,8,GetColor(255,255,0), FALSE);

　引数 DifColor と SpcColor はそれぞれ円錐の頂点ディフューズカラーと頂点スペキュラカラーです、 この関数で描かれる円錐はライティング計算が行われるので、 ただの「描画カラー」ではなくライティング計算で使用される「頂点ディフューズカラー( 拡散光色 )」と「頂点スペキュラカラー( 反射光色 )」を指定します。
　この二つの色の値はライブラリの関数『GetColor』を使って取得します。
　尚、この引数で指定する値は円錐を描画する際に用意される頂点データに含まれるディフューズカラーとスペキュラカラーですので、 SetMaterialUseVertDifColor や SetMaterialUseVertSpcColor で頂点カラーを使用しない設定にした場合はこの引数の値は使用されず、 SetMaterialParam の引数で指定されたマテリアルのディフューズカラーとスペキュラカラーがそれぞれ使用されます。

　因みに円錐の中身を塗りつぶす場合、 ＺバッファとＺバッファへの書き込みをそれぞれ SetUseZBuffer3D 関数と SetWriteZBuffer3D 関数で有効にしておかないと手前の面を描画した後に後ろの面が描画されたりして正常な見た目になりませんので注意してください。



サンプル

　　３Ｄ空間上に円錐を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// ３Ｄ空間上に円錐を描画する
	DrawCone3D( VGet( 320.0f, 400.0f, 0.0f ), VGet( 320.0f, 100.0f, 0.0f ), 80.0f, 16, GetColor( 0,0,255 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawBillboard3D( VECTOR Pos, float cx, float cy, float Size, float Angle, int GrHandle, int TransFlag ) ;

概略 ３Ｄ空間に画像を描画する

引数   VECTOR Pos ： 画像を描画する座標
float cx, cy ： 描画する画像の中心座標( 0.0f ～ 1.0f )
float Size ： 描画する画像のサイズ
float Angle ： 描画する画像の回転角度( ラジアン単位 )
int GrHandle ： 描画する画像のハンドル
int TransFlag ： 透過色が有効か、フラグ（ TRUEで有効 FALSE で無効 ）
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に引数 Pos が示す座標に Size の大きさで画像を描画します。
　引数 Pos は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことが出来ます。

　cx, cy は画像の中心座標を指定する引数で、画像の中心を Pos の位置にしたい場合は cx, cy 共に 0.5f にします。
　Size は画像の横方向の大きさで、 もし縦と横の大きさが違う場合は縦方向の大きさは画像の縦横比から算出されます。
　Angle は画像を回転させたい場合に使用します。回転させない場合は 0.0f を指定します。回転の中心は cx, cy で指定した座標になります。
　GrHandle は描画する画像のハンドルで、LoadGraph 関数などで読み込んだ画像を使用します。
　TransFlag は透過色を使用するかどうかで、透過しない場合は FALSE、透過させる場合は TRUE を渡します。

サンプル

　　３Ｄ空間上に画像を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int GrHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() LoadGraph( "Test1.bmp" ) ;

	// ３Ｄ空間上に画像を描画
	DrawBillboard3D( VGet( 320.0f, 240.0f, 100.0f ), 0.5f, 0.5f, 120.0f, 0.0f, GrHandle, TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawModiBillboard3D( VECTOR Pos, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, int GrHandle, int TransFlag ) ;

概略 ３Ｄ空間に２次元的な変形を加えた画像を描画する

引数   VECTOR Pos ： 画像を描画する座標
float x1, y1, x2, y2
　　　x3, y3, x4, y4 ： x1から順に描画する画像の左上、右上、
　　　　　　　　　　　　　　　　　　右下、左下の頂点の座標
int GrHandle ： 描画する画像のハンドル
int TransFlag ： 透過色が有効か、フラグ（ TRUEで有効 FALSE で無効 ）
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に引数 Pos が示す座標に DrawModiGraph 関数で描画するような変形画像を描画します。
　x1, y1 ～ x4, y4 の基準となる座標を Pos で指定する、Y軸のプラスマイナスが逆、 ということ以外は DrawModiGraph 関数と同じですので、 解説については DrawModiGraph 関数の解説を参照してください。

サンプル

　　３Ｄ空間上に変形画像を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int GrHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() LoadGraph( "Test1.bmp" ) ;

	// ３Ｄ空間上に画像を描画
	DrawModiBillboard3D( VGet( 320.0f, 240.0f, 100.0f ),
		-100.0f,  200.0f,
		 100.0f,  200.0f,
		 100.0f, -200.0f,
		-100.0f, -200.0f, GrHandle, TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawPolygon3D( VERTEX3D *Vertex, int PolygonNum, int GrHandle, int TransFlag ) ;

概略 ３Ｄ空間に三角形ポリゴンの集合を描画する

引数   VERTEX3D *Vertex ： 三角形ポリゴンを形成する頂点配列のアドレス
int PolygonNum ： 描画する三角形ポリゴンの数
int GrHandle ： 描画するポリゴンに貼り付ける画像のハンドル( 画像を張らない場合は DX_NONE_GRAPH )
int TransFlag ： 透過色が有効か、フラグ（TRUEで有効FALSEで無効）
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に引数 Vertex が示す頂点配列を元に PolygonNum 個の三角形ポリゴンの集合を描画します。
　ポリゴン一つ辺りに３つの頂点が必要なので、Vertex が示す配列には PolygonNum × ３ 個の頂点データが必要になります。
　また、GrHandle で指定する画像は８以上の２のｎ乗のピクセルサイズ( 8, 16, 32, 64, 128, 256, 512, 1024 ... )である必要があり( 使える画像サイズの限界はハードウエアが扱えるサイズの限界ですので、2048 以上のピクセルサイズは避けた方が良いです )、 更に DerivationGraph で抜き出した画像や、LoadDivGraph 等の分割読込した画像を使用すると正常に動作しないという、使用できる画像に関して少し制限事項の多い関数です。

　頂点データ VERTEX3D は構造体で、内容は以下のようになっています。


// ３Ｄ描画に使用する頂点データ型
struct VERTEX3D
{
	// 座標
	VECTOR pos ;

	// 法線
	VECTOR norm ;

	// ディフューズカラー
	COLOR_U8 dif ;

	// スペキュラカラー
	COLOR_U8 spc ;

	// テクスチャ座標
	float u, v ;

	// サブテクスチャ座標
	float su, sv ;
} ;

VECTOR pos
　頂点の座標です。
　VECTOR は中に float x, y, z を持つ構造体です。
　float x, y, z を引数として取り、それをそのまま VECTOR 構造体に代入して戻り値として返してくる関数 VGet を使用すると代入処理を簡素に書くことができます。

VECTOR norm
　頂点の法線です。ライティング計算に使用されます。

COLOR_U8 dif
　頂点のディフューズカラー( 拡散光色 )です。基本的なポリゴンの色はこれになります。
　SetMaterialUseVertDifColor で頂点データのディフューズカラーを使用しない設定にしている場合はこの情報は無視され、代わりにマテリアルのディフューズカラーが使用されます。( 初期設定では頂点データのディフューズカラーが使用されます )
　COLOR_U8 は 中に unsigned char b, g, r, a を持つ構造体で、輝度をそれぞれ 0 ～ 255 で表現します。
　int b, g, r, a を引数として取り、それをそのまま COLOR_U8 構造体に代入して戻り値として返してくる関数 GetColorU8 を使用すると代入処理を簡素に書くことが出来ます。

COLOR_U8 spc
　頂点のスペキュラカラー( 反射光色 )です。
　SetMaterialUseVertSpcColor で頂点データのスペキュラカラーを使用しない設定にしている場合はこの情報は無視され、代わりにマテリアルのスペキュラカラーが使用されます。( 初期設定では頂点データのディフューズカラーが使用されます )

float u, v
　頂点のテクスチャ座標です。画像の左上端を u = 0.0f　v = 0.0f 右下端を u = 1.0f　v = 1.0f とした座標で指定します。

float su, sv
　頂点のサブテクスチャ座標です。今のバージョンでは使用しません。

サンプル

　　３Ｄ空間上にポリゴンを２つ描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VERTEX3D Vertex[ 6 ] ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 100.0f,  0.0f ) ;
	Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 0 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 0 ].u    = 0.0f ;
	Vertex[ 0 ].v    = 0.0f ;
	Vertex[ 0 ].su   = 0.0f ;
	Vertex[ 0 ].sv   = 0.0f ;

	Vertex[ 1 ].pos  = VGet( 250.0f, 100.0f,  0.0f ) ;
	Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 1 ].dif  = GetColorU8( 255,  0,255,255 ) ;
	Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 1 ].u    = 0.0f ;
	Vertex[ 1 ].v    = 0.0f ;
	Vertex[ 1 ].su   = 0.0f ;
	Vertex[ 1 ].sv   = 0.0f ;

	Vertex[ 2 ].pos  = VGet( 100.0f, 300.0f,  0.0f ) ;
	Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 2 ].dif  = GetColorU8(   0,255,255,255 ) ;
	Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 2 ].u    = 0.0f ;
	Vertex[ 2 ].v    = 0.0f ;
	Vertex[ 2 ].su   = 0.0f ;
	Vertex[ 2 ].sv   = 0.0f ;


	Vertex[ 3 ].pos  = VGet( 400.0f, 200.0f,  0.0f ) ;
	Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 3 ].dif  = GetColorU8(   0,255,255,255 ) ;
	Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 3 ].u    = 0.0f ;
	Vertex[ 3 ].v    = 0.0f ;
	Vertex[ 3 ].su   = 0.0f ;
	Vertex[ 3 ].sv   = 0.0f ;

	Vertex[ 4 ].pos  = VGet( 600.0f, 400.0f,  0.0f ) ;
	Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
	Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 4 ].u    = 0.0f ;
	Vertex[ 4 ].v    = 0.0f ;
	Vertex[ 4 ].su   = 0.0f ;
	Vertex[ 4 ].sv   = 0.0f ;

	Vertex[ 5 ].pos  = VGet( 500.0f,  50.0f,  0.0f ) ;
	Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 5 ].dif  = GetColorU8( 255,  0,255,255 ) ;
	Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 5 ].u    = 0.0f ;
	Vertex[ 5 ].v    = 0.0f ;
	Vertex[ 5 ].su   = 0.0f ;
	Vertex[ 5 ].sv   = 0.0f ;

	// ２ポリゴンの描画
	DrawPolygon3D( Vertex, 2, DX_NONE_GRAPH, FALSE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DrawPolygonIndexed3D( VERTEX3D *Vertex, int VertexNum, unsigned short *Indices, int PolygonNum, int GrHandle, int TransFlag ) ;

概略 ３Ｄ空間に三角形ポリゴンの集合を描画する(インデックス)

引数   VERTEX3D *Vertex ： 三角形ポリゴンを形成する頂点配列のアドレス
int VertexNum ： 使用する頂点の数
unsigned short *Indices ： 頂点インデックス配列へのアドレス
int PolygonNum ： 描画する三角形ポリゴンの数
int GrHandle ： 描画するポリゴンに貼り付ける画像のハンドル( 画像を張らない場合は DX_NONE_GRAPH )
int TransFlag ： 透過色が有効か、フラグ（TRUEで有効FALSEで無効）
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に引数 Vertex が示す頂点配列と引数 Indices が示す頂点インデックスを元に PolygonNum 個の三角形ポリゴンの集合を描画します。
　DrawPolygon3D では一つのポリゴンに付き３つの頂点データを用意していましたが、 多くの場合複数のポリゴンで同じ頂点を使用しますのでポリゴン毎に独立した３頂点を用意すると無駄が生じます、 それを回避するためにこの関数では頂点データと共に「どの三頂点を使用してポリゴンを形成するか」という頂点インデックスデータを用いてポリゴンを描画します。 ( 例えば Vertex 配列の０番目と２番目と５番目の頂点データを用いてポリゴンを形成したい場合は、インデックス情報は 0, 2, 5 となります )
　ポリゴン一つ辺りに３つの頂点インデックスが必要なので、Indices が示す配列には PolygonNum × ３ 個の頂点インデックスデータが必要になります。
　尚、頂点インデックスは型が unsigned short なので、使用できる頂点データの数は最大で 65536個となります。

　また、GrHandle で指定する画像は８以上の２のｎ乗のピクセルサイズ( 8, 16, 32, 64, 128, 256, 512, 1024 ... )である必要があり( 使える画像サイズの限界はハードウエアが扱えるサイズの限界ですので、2048 以上のピクセルサイズは避けた方が良いです )、 更に DerivationGraph で抜き出した画像や、LoadDivGraph 等の分割読込した画像を使用すると正常に動作しないという、使用できる画像に関して少し制限事項の多い関数です。 　頂点データ VERTEX3D の内容については DrawPolygon3D 関数の解説をご参照ください。

サンプル

　　３Ｄ空間上に４つの頂点データを使用してポリゴンを２つ描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VERTEX3D Vertex[ 4 ] ;
	WORD Index[ 6 ] ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 100.0f,  0.0f ) ;
	Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 0 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 0 ].u    = 0.0f ;
	Vertex[ 0 ].v    = 0.0f ;
	Vertex[ 0 ].su   = 0.0f ;
	Vertex[ 0 ].sv   = 0.0f ;

	Vertex[ 1 ].pos  = VGet( 250.0f, 100.0f,  0.0f ) ;
	Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 1 ].dif  = GetColorU8( 255,  0,255,255 ) ;
	Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 1 ].u    = 0.0f ;
	Vertex[ 1 ].v    = 0.0f ;
	Vertex[ 1 ].su   = 0.0f ;
	Vertex[ 1 ].sv   = 0.0f ;

	Vertex[ 2 ].pos  = VGet( 100.0f, 300.0f,  0.0f ) ;
	Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 2 ].dif  = GetColorU8(   0,255,255,255 ) ;
	Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 2 ].u    = 0.0f ;
	Vertex[ 2 ].v    = 0.0f ;
	Vertex[ 2 ].su   = 0.0f ;
	Vertex[ 2 ].sv   = 0.0f ;

	Vertex[ 3 ].pos  = VGet( 400.0f, 200.0f,  0.0f ) ;
	Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 3 ].dif  = GetColorU8(   0,255,255,255 ) ;
	Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 3 ].u    = 0.0f ;
	Vertex[ 3 ].v    = 0.0f ;
	Vertex[ 3 ].su   = 0.0f ;
	Vertex[ 3 ].sv   = 0.0f ;

	// ２ポリゴン分のインデックスデータをセット
	Index[ 0 ] = 0 ;
	Index[ 1 ] = 1 ;
	Index[ 2 ] = 2 ;
	Index[ 3 ] = 3 ;
	Index[ 4 ] = 2 ;
	Index[ 5 ] = 1 ;

	// ２ポリゴンの描画
	DrawPolygonIndexed3D( Vertex, 4, Index, 2, DX_NONE_GRAPH, FALSE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetMaterialUseVertDifColor( int UseFlag ) ;

概略 ３Ｄ図形描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する

引数   int UseFlag ： 頂点データのディフューズカラーを使用するかどうか
　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　DrawSphere3D, DrawCapsule3D, DrawCone3D, DrawPolygon3D, DrawPolygonIndexed3D の３Ｄ図形描画関数で描画処理をする際のライティング計算に頂点データのディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定します。( 初期設定では使用します )

　「使用する」場合は SetMaterialParam 関数の引数で指定するディフューズカラー( MATERIALPARAM 構造体のメンバ変数 Diffuse )は無視され、 代わりに頂点データのディフューズカラー( VERTEX3D 構造体のメンバ変数 dif )がライティング計算に使用されます。

　「使用しない」場合は SetMaterialParam 関数の引数で指定するディフューズカラーがライティング計算に使用され、 頂点データのディフューズカラーは無視されます。

　尚、SetUseLighting 関数でライティング計算をしない設定にした場合は、 この関数の設定に関係なく頂点データのディフューズカラーが使用されます。

サンプル

　　３Ｄ空間上に標準の設定( 頂点データのディフューズカラーを使用する )で球を描画した後、
　頂点データのディフューズカラーを使用しない設定にして、マテリアルのディフューズカラーを
　黄色にした上で再度球を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATERIALPARAM Material ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// デフォルトの設定で３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 160.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 255,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// 頂点データのディフューズカラーを使用しないようにする
	SetMaterialUseVertDifColor( FALSE ) ;

	// マテリアルのディフューズカラーを黄色にする
	Material.Diffuse  = GetColorF( 1.0f, 1.0f, 0.0f, 1.0f ) ;
	Material.Specular = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Ambient  = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Emissive = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Power    = 20.0f ;
	SetMaterialParam( Material ) ;

	// 再度３Ｄ空間上に球を描画する( 引数 DifColor の値は無視されます )
	DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 255,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetMaterialUseVertSpcColor( int UseFlag ) ;

概略 ３Ｄ図形描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する

引数   int UseFlag ： 頂点データのスペキュラカラーを使用するかどうか
　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　DrawSphere3D, DrawCapsule3D, DrawCone3D, DrawPolygon3D, DrawPolygonIndexed3D の３Ｄ図形描画関数で描画処理をする際のライティング計算に頂点データのスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定します。( 初期設定では使用します )

　「使用する」場合は SetMaterialParam 関数の引数で指定するスペキュラカラー( MATERIALPARAM 構造体のメンバ変数 Specular )は無視され、 代わりに頂点データのスペキュラカラー( VERTEX3D 構造体のメンバ変数 spc )がライティング計算に使用されます。

　「使用しない」場合は SetMaterialParam 関数の引数で指定するスペキュラカラーがライティング計算に使用され、 頂点データのスペキュラカラーは無視されます。

　尚、SetUseLighting 関数でライティング計算をしない設定にした場合は、 この関数の設定に関係なく頂点データのスペキュラカラーが使用されます。

サンプル

　　３Ｄ空間上に標準の設定( 頂点データのスペキュラカラーを使用する )で球を描画した後、
　頂点データのスペキュラカラーを使用しない設定にして、マテリアルのスペキュラカラーを
　黄色にした上で再度球を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATERIALPARAM Material ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// デフォルトの設定で３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 160.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// 頂点データのスペキュラカラーを使用しないようにする
	SetMaterialUseVertSpcColor( FALSE ) ;

	// マテリアルのスペキュラカラーを黄色にする
	Material.Diffuse  = GetColorF( 0.0f, 0.0f, 0.0f, 1.0f ) ;
	Material.Specular = GetColorF( 1.0f, 1.0f, 0.0f, 0.0f ) ;
	Material.Ambient  = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Emissive = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Power    = 20.0f ;
	SetMaterialParam( Material ) ;

	// 再度３Ｄ空間上に球を描画する( 引数 SpcColor の値は無視されます )
	DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetMaterialParam( MATERIALPARAM Material ) ;

概略 ３Ｄ図形描画のライティング計算に使用するマテリアルパラメータを設定する

引数   MATERIALPARAM Material ： マテリアルパラメータ
戻り値 　０：成功
　 －１：エラー発生

解説  　DrawSphere3D, DrawCapsule3D, DrawCone3D, DrawPolygon3D, DrawPolygonIndexed3D の３Ｄ図形描画関数で描画処理をする際のライティング計算に使用するマテリアルパラメータを設定します。

　設定に使用する MATERIALPARAM 構造体は以下のメンバ変数を持っています。

ディフューズカラー
COLOR_F Diffuse ;
　　拡散光色です。ライトのディフューズカラーと掛け合わされてライティング計算に使用されます。
　　この値は SetMaterialUseVertDifColor 関数で頂点データのディフューズカラーを使用しない設定にしていた場合のみ使用されます。( 初期状態では頂点データのディフューズカラーが使用され、この値は無視されます )

アンビエントカラー
COLOR_F Ambient ;
　　環境光色です。ライトのアンビエントカラーと掛け合わされてライティング計算に使用されます。

スペキュラカラー
COLOR_F Specular ;
　　反射光色です。ライトのスペキュラカラーと掛け合わされてライティング計算に使用されます。
　　この値は SetMaterialUseVertSpcColor 関数で頂点データのスペキュラカラーを使用しない設定にしていた場合のみ使用されます。( 初期状態では頂点データのスペキュラカラーが使用され、この値は無視されます )

エミッシブカラー
COLOR_F Emissive ;
　　自己発光色です。ライトが無くても、この値が０以外になっていると自己発光します。

スペキュラの強さ
float Power ;
　　スペキュラハイライトの角度範囲を決定する値です。
　　値が小さいほど範囲が広くなります。10.0f ～ 20.0f 辺りが丁度いい範囲です。

　尚、SetUseLighting 関数でライティング計算をしない設定にした場合は、 この関数の設定は一切無視されます。

サンプル

　　マテリアルの設定で自己発光色を暗い青色にした上で球を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATERIALPARAM Material ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// マテリアルの自己発光色を暗い青色にする
	Material.Diffuse  = GetColorF( 0.0f, 0.0f, 0.0f, 1.0f ) ;
	Material.Specular = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Ambient  = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
	Material.Emissive = GetColorF( 0.0f, 0.0f, 0.5f, 0.0f ) ;
	Material.Power    = 20.0f ;
	SetMaterialParam( Material ) ;

	// デフォルトの設定で３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 320.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetUseZBuffer3D( int Flag ) ;

概略 Ｚバッファを使用するかどうかを設定する

引数   int Flag ： Ｚバッファを使用するかどうかのフラグ
　　　　　　( TRUE：使用する FALSE：使用しない( 初期設定 ) )
戻り値 　０：成功
　 －１：エラー発生

解説  　DrawSphere3D, DrawCapsule3D, DrawCone3D, DrawPolygon3D, DrawPolygonIndexed3D の３Ｄ図形描画関数で描画処理をする際にＺバッファを使用するかどうかを設定します。

　Ｚバッファは主に３Ｄ空間に存在する物を前後関係を意識せずに都合の良い順番で描画するために使用するもので、 これを使用することで立体物を描画する際に画面( フレームバッファ )に色情報の他に描画したピクセルが「カメラ( 画面 )からどれだけ離れているか」という奥行き情報も一緒に書き込み、 その後画面上の同じ場所( ピクセル )に別のものが書かれようとしたときは以前書いたものよりカメラ( 画面 )との距離が短いかどうかを判定して、 以前書いたものより遠くにある場合は後から書こうとしたものを書き込まず、 以前書いたものをそのまま残す、 つまりどんな順序で立体物を描画しても必ずカメラに近い物が最終描画結果として画面の前面に表示されるようになります。 ( 逆にＺバッファを使用しない場合は描画物同士の前後関係は無視され、 通常の描画どおり「後から書いたものが今まで書いてあったものを上書きする」ので、 立体物を前後関係を無視して都合の良い順番で描画すると後ろにあるはずのものが手前のものより前面に表示されるというおかしな描画結果になります )

　この関数はそのＺバッファを使うかどうかを設定する関数で、 使用する場合は TRUE を、使用しない場合は FALSE を渡します。

　因みにこの関数は書き込みの際にＺバッファに「既に書き込まれているカメラ( 画面 )からの距離」と「これから書き込むピクセルのカメラからの距離」を比較して、 「既に書き込まれているカメラとの距離」より「これから書くもの( ピクセル )のカメラからの距離」の方が長かった場合は書き込まない、 という処理をするかどうかを設定するだけで、 書き込むという判断が決定した後Ｚバッファに「これから書くもの( ピクセル )のカメラからの距離」を書き込むかどうかの設定は SetWriteZBuffer3D 関数で行います。 ( 初期設定では「書き込まない」になっています )

　尚、この関数の設定はモデルの描画には影響を与えません。 モデルの描画時にＺバッファを使用するかどうかは MV1SetUseZBuffer 関数で設定します。

サンプル

　　Ｚバッファを有効にしない状態で球を描画した後、Ｚバッファを有効にして
　更にＺバッファへの書き込みも行う設定にして再度球を描画します。
　　Ｚバッファを有効にしない状態では球の奥の面が手前の面より後に描画される関係で
　正しい描画結果が得られません。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() DrawSphere3D( VGet( 160.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// Ｚバッファを有効にする
	SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// Ｚバッファを有効にした状態で再度３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetWriteZBuffer3D( int Flag ) ;

概略 Ｚバッファに書き込みを行うかどうかを設定する

引数   int Flag ： Ｚバッファに書き込みを行うかどうかのフラグ
　　　　　　( TRUE：書き込む FALSE：書き込まない( 初期設定 ) )
戻り値 　０：成功
　 －１：エラー発生

解説  　Ｚバッファを使用する設定になっている状態で描画処理が行われた際に、 Ｚバッファへの書き込みを行うかどうかの設定を変更する関数です。 ( Ｚバッファの説明については SetUseZBuffer3D 関数の解説を参照してください )

　この関数に TRUE を渡した場合はＺバッファの判定後「書き込む」ことになった場合に画面( フレームバッファ )に対して色情報と共にカメラと描画物との距離も記録されます。
　FALSE を渡した場合はＺバッファの判定後「書き込む」ことになった場合に画面( フレームバッファ )に対して色情報のみ記録されます。 ( 初期状態は FALSE( 書き込まない ) です )

　尚、この関数の設定はモデルの描画には影響を与えません。 モデルの描画時にＺバッファを使用するかどうかは MV1SetUseZBuffer 関数で設定します。

サンプル

　　Ｚバッファを有効にしない状態で球を描画した後、Ｚバッファを有効にして
　再度球を描画します。
　　Ｚバッファを有効にしない状態では球の奥の面が手前の面より後に描画される関係で
　正しい描画結果が得られません。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() DrawSphere3D( VGet( 160.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// Ｚバッファを有効にする
	SetUseZBuffer3D( TRUE ) ;

	// Ｚバッファへの書き込みを有効にする
	SetWriteZBuffer3D( TRUE ) ;

	// Ｚバッファを有効にした状態で再度３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetUseBackCulling( int Flag ) ;

概略 ポリゴンのバックカリングを使用するかどうかを設定する

引数   int Flag ： バックカリングを行うかどうかのフラグ
　　　　　　( TRUE：行う FALSE：行わない( 初期設定 ) )
戻り値 　０：成功
　 －１：エラー発生

解説  　DrawTriangle3D, DrawSphere3D, DrawCapsule3D, DrawCone3D, DrawPolygon3D, DrawPolygonIndexed3D でポリゴンを描画する際にバックカリングを行うかどうかを設定します。

　バックカリングとは裏面になっているポリゴンを書かない処理のことです。
　例えば DrawSphere3D 関数で球を描画する場合、 球の画面の方を向いていない面は常に画面の方を向いている面に隠れて画面には表示されないことになりますが、 バックカリングを行わない場合は必ず隠れることが分かっている面も画面への描画処理が行われるのでその分描画負荷が高くなります。
　このような場合にバックカリングを行うようにすると画面に対して後ろを向いている面を描画しない( カリング )ようになるので、 裏面の描画負荷のぶん処理が高速になります。

　因みに裏面かどうかは、ポリゴンを画面に映した際のポリゴンを形成する３頂点を頂点の指定順にスクリーン座標をなぞった場合に、 右回りになっているか左回りになっているかで判断します。( 左回りの場合に裏面だと判断され、カリングが有効な場合はカリングされます )
　DrawPolygon3D や DrawPolygonIndexed3D で直接頂点を扱ってポリゴンを描画する場合にバックカリングを使用する場合には形成するポリゴンの向きを意識する必要がありますので注意してください。

　尚、この関数の設定はモデルの描画には影響を与えません。 ( モデルはデフォルトではバックカリングＯＮになっていて、 ツール上でメッシュ単位でカリングを行うかどうかを設定することができます )

サンプル

　　画面右側にバックカリングを無効の状態で、画面左側にバックカリングを有効にした状態でそれぞれ球を描画します。
　　Ｚバッファを使用しない状態なのでバックカリングを有効にしていない画面右側の球は裏面のポリゴンが表面のポリゴンの
　後に描画されるという現象が発生するので見た目が破綻しますが、バックカリングを有効にした状態で描画している画面左側の
　球は裏面のポリゴンが描画されないのでＺバッファを有効にしていない状態でも正常な見た目で描画されます。
　( 因みにバックカリングを行うことで見た目的に正常な描画結果が得られるのは描画するポリゴン集合にへこんだ部分がない場合のみです )
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリの初期化
	if( DxLib_Init() DrawSphere3D( VGet( 500.0f, 200.0f, 0.0f ), 80.0f, 8, GetColor( 255,0,0 ), GetColor( 255, 255, 255 ), TRUE ) ;

	// バックカリングを有効にする
	SetUseBackCulling( TRUE ) ;

	// バックカリングありで３Ｄ空間上に球を描画する
	DrawSphere3D( VGet( 140.0f, 200.0f, 0.0f ), 80.0f, 8, GetColor( 255,0,0 ), GetColor( 255, 255, 255 ), TRUE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetTextureAddressModeUV( int ModeU, int ModeV ) ;

概略 テクスチャアドレスモードを設定する

引数   int ModeU ： Ｕ値のテクスチャアドレスモード
int ModeV ： Ｖ値のテクスチャアドレスモード
戻り値 　０：成功
　 －１：エラー発生

解説  　DrawPolygon3D, DrawPolygonIndexed3D でポリゴンを描画する際に使用されるテクスチャアドレスモードを設定します。

　アドレスモードとは画像サイズ以上のテクスチャ座標が指定された場合にどう表示するかというもので、以下の３種類があります。


DX_TEXADDRESS_WRAP

　画像サイズ以上のテクスチャ座標の部分は素直に繰り返します。


DX_TEXADDRESS_MIRROR

　画像サイズ以上のテクスチャ座標の部分は鏡に映されたように反転する表示と、もとの反転していない表示とを繰り返します。
　例えば４倍のテクスチャ座標が指定された場合　通常の見た目・反転した見た目・通常の見た目・反転した見た目　という風になります。


DX_TEXADDRESS_CLAMP

　他のモードと違って画像が繰り返されず、画像サイズ以上のテクスチャ座標の部分は画像の端のピクセルが引き伸ばされたような見た目になります。


　アドレスモードはＵ方向とＶ方向で別々に指定することができます。
　初期状態ではＵ，Ｖ共に DX_TEXADDRESS_CLAMP です。

サンプル

　　テクスチャのアドレスモードをＵ方向を DX_TEXADDRESS_WRAP に、Ｖ方向を DX_TEXADDRESS_MIRROR にした上で
　テクスチャサイズの３倍のテクスチャ座標を使ってポリゴンを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VERTEX3D Vertex[ 6 ] ;
	int GrHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() LoadGraph( "Kao.bmp" ) ;

	// テクスチャのアドレスモードをＵ方向を DX_TEXADDRESS_WRAP に
	// Ｖ方向を DX_TEXADDRESS_MIRROR に設定
	SetTextureAddressModeUV( DX_TEXADDRESS_WRAP, DX_TEXADDRESS_MIRROR ) ;

	// ２ポリゴン分の頂点のデータをセット
	Vertex[ 0 ].pos  = VGet( 100.0f, 400.0f,  0.0f ) ;
	Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 0 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 0 ].u    = 0.0f ;
	Vertex[ 0 ].v    = 0.0f ;
	Vertex[ 0 ].su   = 0.0f ;
	Vertex[ 0 ].sv   = 0.0f ;

	Vertex[ 1 ].pos  = VGet( 500.0f, 400.0f,  0.0f ) ;
	Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 1 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 1 ].u    = 3.0f ;
	Vertex[ 1 ].v    = 0.0f ;
	Vertex[ 1 ].su   = 0.0f ;
	Vertex[ 1 ].sv   = 0.0f ;

	Vertex[ 2 ].pos  = VGet( 100.0f, 100.0f,  0.0f ) ;
	Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 2 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 2 ].u    = 0.0f ;
	Vertex[ 2 ].v    = 3.0f ;
	Vertex[ 2 ].su   = 0.0f ;
	Vertex[ 2 ].sv   = 0.0f ;

	Vertex[ 3 ].pos  = VGet( 500.0f, 100.0f,  0.0f ) ;
	Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 3 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 3 ].u    = 3.0f ;
	Vertex[ 3 ].v    = 3.0f ;
	Vertex[ 3 ].su   = 0.0f ;
	Vertex[ 3 ].sv   = 0.0f ;

	Vertex[ 4 ].pos  = VGet( 100.0f, 100.0f,  0.0f ) ;
	Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 4 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 4 ].u    = 0.0f ;
	Vertex[ 4 ].v    = 3.0f ;
	Vertex[ 4 ].su   = 0.0f ;
	Vertex[ 4 ].sv   = 0.0f ;

	Vertex[ 5 ].pos  = VGet( 500.0f, 400.0f,  0.0f ) ;
	Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
	Vertex[ 5 ].dif  = GetColorU8( 255,255,255,255 ) ;
	Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
	Vertex[ 5 ].u    = 3.0f ;
	Vertex[ 5 ].v    = 0.0f ;
	Vertex[ 5 ].su   = 0.0f ;
	Vertex[ 5 ].sv   = 0.0f ;

	// ２ポリゴンの描画
	DrawPolygon3D( Vertex, 2, GrHandle, FALSE ) ;

	// キー入力待ちをする
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetFogEnable( int Flag ) ;

概略 フォグを有効にするかどうかを設定する

引数   int Flag ： フォグを使用するかどうかのフラグ
　　　　　　( TRUE：使用する　FALSE：使用しない( 初期設定 ) )
戻り値 　０：成功
　 －１：エラー発生

解説  　フォグ機能を使用するかどうかを設定します。
　フォグ機能とは言葉通り立体空間で霧を表現する手段の一つです。
　具体的には、カメラ( 画面 )から一定距離離れた物体に霧が掛かったように任意の色を合成することができます。

　これを使用することで空気が淀んでいる日に遠くのものを見ようとすると白く霧が掛かったようになってよく見えない、 というような空気遠近法も再現することができます。
　因みにこの機能はカメラ( 画面 )から一定距離以上離れたものを描画しなくても済むようにする目的で使用することもできます。 ( フォグ終了距離以降の部分はフォグ色のみとなるため )

　デフォルトではフォグの機能はＯＦＦになっていますので、 フォグの機能を使用する場合はこの関数でフォグを有効にする必要があります、 また、フォグの色やフォグの開始距離・終了距離の設定はそれぞれ SetFogColor 関数、SetFogStartEnd 関数を使用します。

サンプル

　　フォグ機能を有効にした状態でモデルを画面から徐々に離しながら４体描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, i ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetFogColor( 255, 255, 0 ) ;

	// フォグの開始距離を０、終了距離を１５００にする
	SetFogStartEnd( 0.0f, 1500.0f ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// 画面を黄色で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 255, 255, 0 ), TRUE ) ;

	// ３Ｄモデルを徐々に画面から離しながら４体描画する
	for( i = 0 ; i MV1SetPosition( ModelHandle, VGet( 700.0f, -300.0f, 200.0f + i * 400.0f ) ) ;
		
		// モデルを描画
		MV1DrawModel( ModelHandle ) ;
	}

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetFogColor( int Red, int Green, int Blue ) ;

概略 フォグの色を変更する

引数   int Red ： 設定したいフォグの色の赤成分の輝度( ０ ～ ２５５ )
int Green ： 設定したいフォグの色の緑成分の輝度( ０ ～ ２５５ )
int Blue ： 設定したいフォグの色の青成分の輝度( ０ ～ ２５５ )
戻り値 　０：成功
　 －１：エラー発生

解説  　フォグの色を設定します。
　暗い色も指定できますので、一定距離以降が暗闇、といった表現も可能です。

サンプル

　　フォグ機能を有効にした状態でモデルを画面から徐々に離しながら４体描画します。
　　フォグの色を黒にしているので徐々に暗闇に消えていくように見えます
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, i ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetFogEnable( TRUE ) ;

	// フォグの色を黒色にする
	SetFogColor( 0, 0, 0 ) ;

	// フォグの開始距離を０、終了距離を１５００にする
	SetFogStartEnd( 0.0f, 1500.0f ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ３Ｄモデルを徐々に画面から離しながら４体描画する
	for( i = 0 ; i MV1SetPosition( ModelHandle, VGet( 700.0f, -300.0f, 200.0f + i * 400.0f ) ) ;
		
		// モデルを描画
		MV1DrawModel( ModelHandle ) ;
	}

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetFogStartEnd( float start, float end ) ;

概略 フォグが始まる距離と終了する距離を設定する

引数   float start ： フォグの効果が開始する画面からの距離
float end ： フォグの効果が終了する( フォグ色の濃さが１００％になる )画面からの距離
戻り値 　０：成功
　 －１：エラー発生

解説  　フォグの効果が始まる画面からの距離と、 描画物がフォグの色のみになる画面からの距離を設定します。

　開始距離と終了距離の間に存在する描画物はフォグの色と描画物の色とがブレンドされる形になります。

サンプル

　　フォグ機能を有効にした状態でフォグの開始距離を１０００、終了距離を３５００に変更した上で
　モデルを画面から徐々に離しながら８体描画します。
　　SetFogEnable のサンプルプログラムと違い、フォグの色が掛かり始めるのが３体目からになっています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, i ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetFogEnable( TRUE ) ;

	// フォグの色を黄色にする
	SetFogColor( 255, 255, 0 ) ;

	// フォグの開始距離を１０００、終了距離を３５００にする
	SetFogStartEnd( 1000.0f, 3500.0f ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// 画面を黄色で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 255, 255, 0 ), TRUE ) ;

	// ３Ｄモデルを画面から徐々に離しながら８体描画する
	for( i = 0 ; i MV1SetPosition( ModelHandle, VGet( 700.0f, -300.0f, 200.0f + i * 400.0f ) ) ;
		
		// モデルを描画
		MV1DrawModel( ModelHandle ) ;
	}

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F GetColorF( float Red, float Green, float Blue, float Alpha ) ;

概略 不動小数点型のカラー値を取得する

引数   float Red ： 取得したいカラー値の赤成分の輝度( 0.0f ～ 1.0f )
float Green ： 取得したいカラー値の緑成分の輝度( 0.0f ～ 1.0f )
float Blue ： 取得したいカラー値の青成分の輝度( 0.0f ～ 1.0f )
float Alpha ： 取得したいカラー値のアルファ成分( 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　COLOR_F 構造体の値を簡単に作成するための関数です。

　例えば MV1SetDifColorScale 関数の第二引数は COLOR_F 構造体ですが、 この引数をこの関数を使用せずに渡そうとした場合は以下のようにローカル変数として COLOR_F 構造体を使用する必要があります。


	// GetColorF 関数を使用しない場合
	COLOR_F Color ;

	Color.r = 1.0f ;
	Color.g = 1.0f ;
	Color.b = 0.0f ;
	Color.a = 1.0f ;
	MV1SetDifColorScale( ModelHandle, Color ) ;

　関数に引数を渡そうとする度にローカル変数を使用するのはプログラムも煩雑になりますし面倒でもあります。
　そんなときにこの COLOR_F 構造体を戻り値に返す関数を使用すれば以下のように記述することができます。


	// GetColorF 関数を使用する場合
	MV1SetDifColorScale( ModelHandle, GetColorF( 1.0f, 1.0f, 0.0f, 1.0f ) ) ;


サンプル

　　GetColorF 関数を使用している関数 SetLightDifColor 等のサンプルを参照してください。



宣言 COLOR_U8 GetColorU8( int Red, int Green, int Blue, int Alpha ) ;

概略 符号なし整数８ビットのカラー値を取得する

引数   int Red ： 取得したいカラー値の赤成分の輝度( 0 ～ 255 )
int Green ： 取得したいカラー値の緑成分の輝度( 0 ～ 255 )
int Blue ： 取得したいカラー値の青成分の輝度( 0 ～ 255 )
int Alpha ： 取得したいカラー値のアルファ成分( 0 ～ 255 )
戻り値 　０：成功
　 －１：エラー発生

解説  　COLOR_U8 構造体の値を簡単に作成するための関数です。

　今のところ VERTEX3D 構造体のメンバ変数で COLOR_U8 構造体である dif や spc に値を代入する際にのみ使用します。
　例えば VERTEX3D 構造体のメンバ変数 dif にこの関数を使用せずに値を代入しようとした場合以下のような記述になります。


	// GetColorU8 関数を使用しない場合
	VERTEX3D Vertex ;

	Vertex.dif.r = 255 ;
	Vertex.dif.g = 255 ;
	Vertex.dif.b = 0 ;
	Vertex.dif.a = 255 ;

　あまり大きな差ではありませんが、 COLOR_U8 構造体を戻り値として返す GetColorU8 関数を使用すると以下のように記述することができます。


	// GetColorU8 関数を使用する場合
	VERTEX3D Vertex ;
	
	Vertex.dif = GetColorU8( 255, 255, 0, 255 ) ;


サンプル

　　GetColorU8 関数を使用している関数 DrawPolygon3D 等のサンプルを参照してください。



カメラ関数

宣言 int SetCameraNearFar( float Near, float Far ) ;

概略 カメラの 手前クリップ距離と 奥クリップ距離を設定する

引数   float Near ： 手前( Near )クリップ距離( 0.0f より大きく Farより小さな値 )
float Far ： 奥( Far )クリップ距離( Nearより小さな値 )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ空間に何かを描画する際に、カメラからどれだけ離れたところ( Near )から、 どこまで( Far )のものを描画するかを設定します。

　この関数の設定値はかなり重要で、Ｚバッファの精度にも関わってきますので使用する３Ｄ空間の範囲に合わせて適切な値を設定する必要があります。
　例えば人間モデル１つの大きさが 200.0f くらいで大体画面奥方向に 10000.0f くらいまで移動して、 背景は画面奥方向に 15000.0f くらいまで存在して、かつカメラから 100.0f より近くに来たら見えないようにしたい場合は


SetCameraNearFar( 100.0f, 15000.0f ) ;

　とします。

　人間モデル一つの大きさがもっと小さく、1.0f くらいで、背景モデルも画面奥方向に 150.0f くらいまで描画できればよい場合は


SetCameraNearFar( 1.0f, 150.0f ) ;

　とします。

　因みに、Ｚバッファの仕様の関係で Far の設定値も重要ですが Near の設定値はより重要で、 例えば「なるべくカメラに近くても描画したい」という考えから


SetCameraNearFar( 0.00001f, 15000.0f ) ;

　としてしまったりすると大変です、環境によってはカメラから 100.0f 以上離れると描画されなくなったりします。
　なので、Near の値は不都合が無い範囲でなるべく大きな値を、Far の値は描画したい最奥のモノのより少し大きな値を設定するようにしてください。

＜注意＞なお、この関数の設定はSetDrawScreen、SetGraphMode、ChangeWindowMode のいずれかを使用したときにリセットされます。

サンプル

　　モデルファイル SimpleModel.mqo を画面奥方向に座標をずらして８つ描画して、
　方向キーの上下で Far の値を、左右で Near の値を変更できるサンプルプログラムです。
　　クリップ値を変更することで描画される範囲が変わるのが分かります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, i ;
	float Near, Far ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// Near Far 値の初期化
	Near = 100.0f ;
	Far = 2000.0f ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 上下のキー入力で Far を操作
		if( CheckHitKey( KEY_INPUT_UP ) == 1 )
		{
			Far += 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
		{
			Far -= 20.0f ;
		}

		// 左右のキーで Near を操作
		if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
		{
			Near -= 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
		{
			Near += 20.0f ;
		}

		// Near の値が 0.0f 以下になっていたら補正
		if( Near MV1SetPosition( ModelHandle, VGet( 320.0f, 180.0f, 100.0f + i * 400.0f ) ) ;

			// モデルの描画
			MV1DrawModel( ModelHandle ) ;
		}

		// 画面左上に Near の値と Far の値を描画
		DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Near %f  Far %f", Near, Far ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetCameraPositionAndTarget_UpVecY( VECTOR Position, VECTOR Target ) ;

概略 カメラの視点、注視点を設定する( 上方向はＹ軸から算出 )

引数   VECTOR Position ： カメラの位置
VECTOR Target ： カメラの注視点( 見ている座標 )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄソフトと言えば視点がグリグリ変わります、 この関数はその視点の位置と見ているものを指定する関数です。

　カメラの姿勢は、視点、注視点と、あとカメラの上方向があれば決まりますが、 この関数はカメラの上方向をＹ軸のプラス方向を基本的なカメラの上方向として姿勢を算出します。

　因みに、ＤＸライブラリでは初期状態では視点の位置が x = 320.0f, y = 240.0f, z = ( 画面のサイズによって変化 )、 注視点の位置は x = 320.0f, y = 240.0f, z = 1.0f、カメラの上方向は x = 0.0f, y = 1.0f, z = 0.0f、 つまり画面のＸＹ平面上の中心に居てＺ軸のプラス方向を見るようなカメラになっています。

　引数 Position と引数 Target は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　モデルファイル SimpleModel.mqo を原点に描画した状態で、カメラの位置を方向キーで
　操作できるようにしたサンプルプログラムです。
カメラは常に原点を注視点としていますのでモデルは常に画面中心に表示されますが、
　キー入力によって見える角度が変わります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	VECTOR CameraPos ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラの座標を初期化
	CameraPos.x = 0.0f ;
	CameraPos.y = 0.0f ;
	CameraPos.z = -800.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 方向キーでカメラの座標を移動
		if( CheckHitKey( KEY_INPUT_UP ) == 1 )
		{
			CameraPos.y += 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
		{
			CameraPos.y -= 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
		{
			CameraPos.x -= 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
		{
			CameraPos.x += 20.0f ;
		}

		// カメラの位置と注視点をセット、注視点は原点
		SetCameraPositionAndTarget_UpVecY( CameraPos, VGet( 0.0f, 0.0f, 0.0f ) ) ;

		// モデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetCameraPositionAndTargetAndUpVec( VECTOR Position, VECTOR Target, VECTOR Up ) ;

概略 カメラの視点、注視点、上方向を設定する

引数   VECTOR Position ： カメラの位置
VECTOR Target ： カメラの注視点( 見ている座標 )
VECTOR Up ： カメラの上方向
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄソフトと言えば視点がグリグリ変わります、 この関数はその視点の位置と注視点とカメラの上方向を指定する関数です。 ( カメラの姿勢は、視点、注視点と、カメラの上方向があれば決まります )

　因みに、ＤＸライブラリでは初期状態では視点の位置が x = 320.0f, y = 240.0f, z = ( 画面のサイズによって変化 )、注視点の位置は x = 320.0f, y = 240.0f, z = 1.0f、カメラの上方向は x = 0.0f, y = 1.0f, z = 0.0f、 つまり画面のＸＹ平面上の中心に居てＺ軸のプラス方向を見るようなカメラになっています。

　引数 Position と引数 Target は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　モデルファイル SimpleModel.mqo を原点に配置して、左右キーでそのモデルを見ている
　カメラの上の方向を回転できるようにしたサンプルプログラムです。
-------------------------------------------------------------------------------


#include "DxLib.h"
#include <math.h>

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float Roll ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラの視線の回転値を初期化
	Roll = 0.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 左右キーでカメラの回転値を変更
		if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
		{
			Roll -= PHI_F / 60.0f ;
		}
		if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
		{
			Roll += PHI_F / 60.0f ;
		}

		// カメラの位置と注視点をセット
		// 視点はＺ軸のマイナス800の位置
		// 注視点は原点
		// 上方向は Roll の値から算出
		SetCameraPositionAndTargetAndUpVec( 
			VGet( 0.0f, 0.0f, -800.0f ),
			VGet( 0.0f, 0.0f, 0.0f ),
			VGet( sin( Roll ), cos( Roll ), 0.0f ) ) ;

		// モデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetCameraPositionAndAngle( VECTOR Position, float VRotate, float HRotate, float TRotate ) ;

概略 カメラの視点、垂直回転角度、水平回転角度、捻り回転角度を設定する

引数   VECTOR Position ： カメラの位置
float VRotate ： 垂直回転角度( 単位：ラジアン )
float HRotate ： 水平回転角度( 単位：ラジアン )
float TRotate ： 捻り回転角度( 単位：ラジアン )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄソフトと言えば視点がグリグリ変わります、 この関数は視点の位置と垂直回転角度、水平回転角度、捻り回転角度でカメラの位置を向きを設定する関数です。

　例えばカメラが見ている方向を上下( 垂直 )方向に変えたい場合は VRotate の値を変化させて、 左右( 水平 )方向に変えたい場合は HRotate の値を変化させて、 見ている方向に捻りを加えたい場合は TRotate の値を変化させて、といった感じです。

　引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

カメラの向きを上下左右キーで変えられるようにしたサンプルです。
　　回転していることを確認できるようにモデルファイル SimpleModel.mqo をカメラを囲むように
　４個描画しています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float VRotate, HRotate, TRotate ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラの回転値を初期化
	VRotate = 0.0f ;
	HRotate = 0.0f ;
	TRotate = 0.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 左シフトキーを押しているかどうかで処理を分岐
		if( CheckHitKey( KEY_INPUT_LSHIFT ) == 1 )
		{
			// 左右キーでカメラの捻り方向回転値を変更
			if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
			{
				TRotate -= PHI_F / 60.0f ;
			}
			if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
			{
				TRotate += PHI_F / 60.0f ;
			}
		}
		else
		{
			// 左右キーでカメラの水平方向回転値を変更
			if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
			{
				HRotate -= PHI_F / 60.0f ;
			}
			if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
			{
				HRotate += PHI_F / 60.0f ;
			}
		}

		// 上下キーでカメラの垂直方向回転値を変更
		if( CheckHitKey( KEY_INPUT_UP ) == 1 )
		{
			VRotate += PHI_F / 60.0f ;
		}
		if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
		{
			VRotate -= PHI_F / 60.0f ;
		}

		// カメラの位置と回転値をセット、カメラの位置は原点
		SetCameraPositionAndAngle( VGet( 0.0f, 0.0f, 0.0f ), VRotate, HRotate, TRotate ) ;

		// モデルをカメラを囲むように４個描画
		MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, 800.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, -800.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet( 800.0f, 0.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet( -800.0f, 0.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetCameraViewMatrix( MATRIX ViewMatrix ) ;

概略 ビュー行列を直接設定する

引数   MATRIX ViewMatrix ： ビュー行列
戻り値 　０：成功
　 －１：エラー発生

解説  　SetCameraPositionAndTarget_UpVecY などの関数を使用せずに直接ビュー行列を設定したいときに使用する関数です。

　SetCameraPositionAndTarget_UpVecY などの関数を使用する場合は使用しません。

サンプル

カメラの向きを左右キーで変えられるようにしたサンプルです。
　　回転していることを確認できるようにモデルファイル SimpleModel.mqo をカメラを囲むように
　４個描画しています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float Rotate ;
	MATRIX Matrix ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラの回転値を初期化
	Rotate = 0.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 左右キーでカメラの回転値を変更
		if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
		{
			Rotate -= PHI_F / 60.0f ;
		}
		if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
		{
			Rotate += PHI_F / 60.0f ;
		}

		// 回転値を使用してＹ軸の回転行列を作成
		Matrix = MGetRotY( Rotate ) ;

		// 回転行列をビュー行列としてセット
		SetCameraViewMatrix( Matrix ) ;

		// モデルをカメラを囲むように４個描画
		MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, 800.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, -800.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet( 800.0f, 0.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet( -800.0f, 0.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetupCamera_Perspective( float Fov ) ;

概略 遠近法カメラをセットアップする

引数   float Fov ： 視野角( 単位：ラジアン )
戻り値 　０：成功
　 －１：エラー発生

解説  　カメラを遠近法を使用したものにします。
　遠近法を使用したカメラはカメラから遠い物ほど小さく見えるので、 現実での立体空間の見え方に一番近い表示法です。( ＤＸライブラリの初期設定は遠近法です )

　引数の Fov は視野角で値が大きければ大きいほど視野が広くなります、初期設定では 60度( ラジアンでは約 1.0472 )です。

　尚、この関数と SetupCamera_Ortho や SetupCamera_ProjectionMatrix はそれぞれ排他関係にありますので注意してください。

サンプル

カメラの視野角を左右キーで変えられるようにしたサンプルです。
　　視野角が変化していることを確認できるようにモデルファイル SimpleModel.mqo をカメラの前方に
　３個描画しています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float Fov ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 視野角を初期化
	Fov = 60.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 左右キーで視野角の値を変更
		if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
		{
			Fov -= 2.0f ;
		}
		if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
		{
			Fov += 2.0f ;
		}

		// 視野角が 8.0f 以下になったら補正
		if( Fov  170.0f ) Fov = 170.0f ;

		// 遠近法のセットアップ( ラジアン値に変換しています )
		SetupCamera_Perspective( Fov * PHI_F / 180.0f ) ;

		// カメラの前方にモデルを３個描画
		MV1SetPosition( ModelHandle, VGet( -1400.0f + 320.0f, 240.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet(     0.0f + 320.0f, 240.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		MV1SetPosition( ModelHandle, VGet(  1400.0f + 320.0f, 240.0f, 0.0f ) ) ;
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetupCamera_Ortho( float Size ) ;

概略 正射影カメラをセットアップする

引数   float Size ： 画面垂直方向の表示範囲
戻り値 　０：成功
　 －１：エラー発生

解説  　カメラを正射影法を使用したものにします。
　正射影を使用したカメラはカメラから遠い物ものでも近いものでも同じ大きさに見えます、 現実での立体空間の見え方は遠くの物ほど小さく見えるので、 少し不思議な見え方になります。

　引数の Size は画面の下端から上端の間に表示される空間の範囲です、 値が大きければ大きいほど沢山の範囲が画面内に映ります。

　尚、この関数と SetupCamera_Perspective や SetupCamera_ProjectionMatrix はそれぞれ排他関係にありますので注意してください。

サンプル

表示方式を正射影に変えてからカメラの前方に奥行き値の違うモデルを３つ描画します。
　　正射影なので奥行き的に何処に位置していても同じ大きさで描画されます。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// カメラを正射影に変更
	SetupCamera_Ortho( 2000.0f ) ;

	// カメラの前方に奥行き座標の違うモデルを３個描画
	MV1SetPosition( ModelHandle, VGet( -700.0f + 320.0f, 240.0f, 0.0f ) ) ;
	MV1DrawModel( ModelHandle ) ;

	MV1SetPosition( ModelHandle, VGet(    0.0f + 320.0f, 240.0f, 500.0f ) ) ;
	MV1DrawModel( ModelHandle ) ;

	MV1SetPosition( ModelHandle, VGet(  700.0f + 320.0f, 240.0f, 1000.0f ) ) ;
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetupCamera_ProjectionMatrix( MATRIX ProjectionMatrix ) ;

概略 射影行列を設定する

引数   MATRIX ProjectionMatrix ： 射影行列
戻り値 　０：成功
　 －１：エラー発生

解説  　射影行列を直接設定する場合に使用します。
　SetupCamera_Perspective や SetupCamera_Ortho を使用する場合は使いません。

サンプル

ありません



宣言 int SetCameraDotAspect( float DotAspect ) ;

概略 カメラのドットアスペクトを設定する

引数   float DotAspect ： ドットアスペクト比( 横 / 縦 )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ描画を使用した際に画面に描画される映像の縦横比を設定します。
　値は 横 / 縦 で指定して、値が 1.0f 以上なら見え方が横長に、 0.0f 以上 1.0f 以下なら縦長になります。

　特殊な演出をしたい場合以外は恐らく使用しない関数です。

サンプル

ドットアスペクト比の設定を縦２倍にしてからモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ドット比を縦に２倍に変更
	SetCameraDotAspect( 0.5f ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 0.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR ConvWorldPosToScreenPos( VECTOR WorldPos ) ;

概略 ワールド座標をスクリーン座標に変換する

引数   VECTOR WorldPos ： ワールド( ３Ｄ )座標
戻り値 スクリーン座標

解説   　引数 WorldPos で渡すワールド( ３Ｄ )座標をスクリーン座標に変換します。
　３Ｄ空間上に存在する物が画面上のどの座標に位置するのかを取得したい場合に使用します。

　尚、指定のワールド座標とカメラの視線方向との距離が SetCameraNearFar で設定した範囲から外れていた場合は戻り値のＺが 0.0f以下又は1.0f以上になり、その際のＸ、Ｙはスクリーン座標とは無関係の値となります。( なので戻り値のＺが 0.0f 以下若しくは 1.0f 以上の場合はＸ，Ｙの値は無効だと判断してください )

サンプル

DxChara.x の０番目のモーションを再生しながら、フレーム番号２６の座標に２Ｄの四角形を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex ;
	float TotalTime, PlayTime ;
	VECTOR ScreenPos ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの０番目のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, 0, -1, FALSE ) ;

	// アタッチしたアニメーションの総再生時間を取得する
	TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;

	// 再生時間の初期化
	PlayTime = 0.0f ;

	// 何かキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 再生時間を進める
		PlayTime += 100.0f ;

		// 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
		if( PlayTime >= TotalTime )
		{
			PlayTime = 0.0f ;
		}

		// 再生時間をセットする
		MV1SetAttachAnimTime( ModelHandle, AttachIndex, PlayTime ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// ナンバー２６のフレームの画面上での座標を取得する
		ScreenPos = ConvWorldPosToScreenPos( MV1GetFramePosition( ModelHandle, 26 ) ) ;

		// 取得したスクリーン座標に四角形を描画
		DrawBox( ScreenPos.x - 2, ScreenPos.y - 2, ScreenPos.x + 2, ScreenPos.y + 2, GetColor( 255,0,0 ), TRUE ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR ConvScreenPosToWorldPos( VECTOR ScreenPos ) ;

概略 スクリーン座標をワールド座標に変換する

引数   VECTOR ScreenPos ： スクリーン座標
戻り値 ワールド座標

解説   　引数 ScreenPos で渡すスクリーン座標をワールド座標に変換します。
　マウスでクリックした座標に存在する３Ｄ空間上のオブジェクトを検出したりする処理に使用します。

　尚、スクリーン座標には奥行きの情報がありませんので、画面上からどれだけ奥まった３Ｄ空間上の座標を取得するのかのを ScreenPos のメンバ変数 z で指定します。 ただ、この z はワールド空間上での距離ではなく、指定できる値の範囲は 0.0f から 1.0f です。
　z が 0.0f の場合は SetCameraNearFar 関数で設定した Near と同じだけカメラ座標から離れた位置、1.0f の場合は Far と同じだけカメラ座標から離れた位置のワールド座標が返ってきます。

サンプル

　　画面上に表示されているモデルファイル SimpleModel.mqo のポリゴンとマウスポインタの位置から
　画面奥へ伸びる線分とで当たり判定を行い、線分に接触したポリゴンを黄色で描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	VECTOR StartPos, EndPos ;
	MV1_COLL_RESULT_POLY HitPoly ;
	int Mx, My ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ３Ｄモデルを見える位置に移動する
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// モデル全体のコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, -1, 8, 8, 8 ) ;

	// ウインドウが閉じられるか何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// マウスの座標を取得
		GetMousePoint( &Mx, &My ) ;

		// マウスポインタがある画面上の座標に該当する３Ｄ空間上の Near 面の座標を取得
		StartPos = ConvScreenPosToWorldPos( VGet( Mx, My, 0.0f ) ) ;

		// マウスポインタがある画面上の座標に該当する３Ｄ空間上の Far 面の座標を取得
		EndPos = ConvScreenPosToWorldPos( VGet( Mx, My, 1.0f ) ) ;

		// モデルと線分との当たり判定
		HitPoly = MV1CollCheck_Line( ModelHandle, -1, StartPos, EndPos ) ;

		// 当たったかどうかで処理を分岐
		if( HitPoly.HitFlag == 1 )
		{
			// 当たった場合は衝突の情報を描画する

			// 当たったポリゴンを黄色で描画する
			DrawTriangle3D( HitPoly.Position[ 0 ], HitPoly.Position[ 1 ], HitPoly.Position[ 2 ], GetColor( 255,255,0 ), TRUE ) ;

			// 交差した座標を描画
			DrawFormatString( 0, 0, GetColor( 255,255,255 ),  "Hit Pos   %f  %f  %f",
				HitPoly.HitPosition.x, HitPoly.HitPosition.y, HitPoly.HitPosition.z ) ;

			// 当たったポリゴンが含まれるフレームの番号を描画
			DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Frame     %d", HitPoly.FrameIndex ) ;

			// 当たったポリゴンが使用しているマテリアルの番号を描画
			DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Material  %d", HitPoly.MaterialIndex ) ;

			// 当たったポリゴンを形成する三頂点の座標を描画
			DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Position  %f  %f  %f",
				HitPoly.Position[ 0 ].x, HitPoly.Position[ 0 ].y, HitPoly.Position[ 0 ].z ) ;
			DrawFormatString( 0, 64, GetColor( 255,255,255 ), "          %f  %f  %f",
				HitPoly.Position[ 1 ].x, HitPoly.Position[ 1 ].y, HitPoly.Position[ 1 ].z ) ;
			DrawFormatString( 0, 80, GetColor( 255,255,255 ), "          %f  %f  %f",
				HitPoly.Position[ 2 ].x, HitPoly.Position[ 2 ].y, HitPoly.Position[ 2 ].z ) ;

			// 当たったポリゴンの法線を描画
			DrawFormatString( 0, 96, GetColor( 255,255,255 ), "Normal    %f  %f  %f",
				HitPoly.Normal.x, HitPoly.Normal.y, HitPoly.Normal.z ) ;
		}
		else
		{
			// 当たらなかった場合は衝突しなかった旨だけ描画する
			DrawString( 0, 0, "NO HIT", GetColor( 255,255,255 ) ) ;
		}

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetCameraScreenCenter( float x, float y ) ;

概略 画面上でのカメラが見ている映像の中心座標を設定する

引数   float x ： ３Ｄ空間の消失点となるスクリーンＸ座標
float y ： ３Ｄ空間の消失点となるスクリーンＹ座標
戻り値 　０：成功
　 －１：エラー発生

解説  　画面上でのカメラが見ている映像の中心座標( 消失点 )を引数で渡されるスクリーン座標にする関数です。
　主な用途は１プレイヤー用と２プレイヤー用で画面を上下に分けたいときや、画面の一部を３Ｄ表現したい場合などです。 ( 消失点は初期状態では常に画面の中心なので、消失点を変更しないまま画面を上下や左右に分けようとすると大変です )

　尚、この関数の設定は SetDrawArea、ChangeWindowMode、SetDrawScreen の何れかを使用するとリセットされますので注意してください。

サンプル

カメラの消失点を画面右側に変更してから立方体を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

#define X1	100.0f
#define X2	540.0f
#define Y1	100.0f
#define Y2	380.0f
#define Z1	0.0f
#define Z2	1000.0f

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int Color ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラの注視点の画面上の位置を右寄りにする
	SetCameraScreenCenter( 480.0f, 240.0f ) ;

	// 直方体を描画する
	Color = GetColor( 255,255,255 ) ;
	DrawLine3D( VGet( X1, Y1, Z1 ), VGet( X2, Y1, Z1 ), Color ) ;
	DrawLine3D( VGet( X2, Y1, Z1 ), VGet( X2, Y2, Z1 ), Color ) ;
	DrawLine3D( VGet( X2, Y2, Z1 ), VGet( X1, Y2, Z1 ), Color ) ;
	DrawLine3D( VGet( X1, Y2, Z1 ), VGet( X1, Y1, Z1 ), Color ) ;
	DrawLine3D( VGet( X1, Y1, Z2 ), VGet( X2, Y1, Z2 ), Color ) ;
	DrawLine3D( VGet( X2, Y1, Z2 ), VGet( X2, Y2, Z2 ), Color ) ;
	DrawLine3D( VGet( X2, Y2, Z2 ), VGet( X1, Y2, Z2 ), Color ) ;
	DrawLine3D( VGet( X1, Y2, Z2 ), VGet( X1, Y1, Z2 ), Color ) ;
	DrawLine3D( VGet( X1, Y1, Z1 ), VGet( X1, Y1, Z2 ), Color ) ;
	DrawLine3D( VGet( X2, Y1, Z1 ), VGet( X2, Y1, Z2 ), Color ) ;
	DrawLine3D( VGet( X2, Y2, Z1 ), VGet( X2, Y2, Z2 ), Color ) ;
	DrawLine3D( VGet( X1, Y2, Z1 ), VGet( X1, Y2, Z2 ), Color ) ;

	// 裏画面の内容を表画面に反映
	ScreenFlip() ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int CheckCameraViewClip( VECTOR CheckPos ) ;

概略 指定の座標がカメラの視界に入っていないかどうかを判定する

引数   VECTOR CheckPos ： 視界に入っていないかどうかをチェックするワールド座標
戻り値 　TRUE：視界に入っていない
　 FALSE：視界に入っている

解説   　指定のワールド座標が視界に入っていないかどうかをチェックする関数です。
　３Ｄの描画処理は処理負荷が高いので、この関数で視界に入っていない( 画面内に映っていない )場合は描画処理を行わない、などの処理をする際に使用します。
サンプル

３Ｄ空間内を左右に飛び回る点がカメラに入っているかどうかを画面左上に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Position ;
	float XAdd ;

	// ウインドウモードで起動
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init()  740.0f )
		{
			XAdd = -XAdd ;
		}

		// 画面内に座標が入っていないかどうかを描画する
		if( CheckCameraViewClip( Position ) == TRUE )
		{
			DrawString( 0, 0, "Screen Out:Yes", GetColor( 255,255,255 ) ) ;
		}
		else
		{
			DrawString( 0, 0, "Screen Out:No", GetColor( 255,255,255 ) ) ;
		}

		// 点を描画する
		DrawPixel3D( Position, GetColor( 255,255,255 ) ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int CheckCameraViewClip_Box( VECTOR BoxPos1, VECTOR BoxPos2 ) ;

概略 二つの座標で表されるボックスがカメラの視界に入っていないかどうかを判定する

引数   VECTOR BoxPos1 ： ボックスを表すワールド座標１
VECTOR BoxPos2 ： ボックスを表すワールド座標２
戻り値 　TRUE：視界に入っていない
　 FALSE：視界に入っている

解説   　二つの座標で表されるボックスが視界に入っていないかどうかをチェックする関数です。
　３Ｄの描画処理は処理負荷が高いので、この関数で視界に入っていない( 画面内に映っていない )場合は描画処理を行わない、などの処理をする際に使用します。
サンプル

３Ｄ空間内を左右に飛び回るボックスがカメラに入っているかどうかを画面左上に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Position ;
	VECTOR BoxPos1, BoxPos2 ;
	float XAdd ;

	// ウインドウモードで起動
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init()  840.0f )
		{
			XAdd = -XAdd ;
		}

		// ボックスを現す２点の座標を準備
		BoxPos1 = VSub( Position, VGet( 10.0f, 10.0f, 10.0f ) ) ;
		BoxPos2 = VAdd( Position, VGet( 10.0f, 10.0f, 10.0f ) ) ;

		// 画面内にボックスが入っていないかどうかを描画する
		if( CheckCameraViewClip_Box( BoxPos1, BoxPos2 ) == TRUE )
		{
			DrawString( 0, 0, "Screen Out:Yes", GetColor( 255,255,255 ) ) ;
		}
		else
		{
			DrawString( 0, 0, "Screen Out:No", GetColor( 255,255,255 ) ) ;
		}

		// ボックスを描画する
		DrawCube3D( BoxPos1, BoxPos2, GetColor( 255,255,255 ), GetColor( 0,0,0 ), TRUE ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------






ライト関数

宣言 int SetUseLighting( int Flag ) ;

概略 ライティング計算処理を使用するかどうかを設定する

引数   int Flag ： ライティング計算処理を使用するかどうか( TRUE：使用する　FALSE：使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　３Ｄ描画をする際にライティング計算を行うかどうかを設定します。( 初期状態では計算します )
　計算処理をしない設定にした場合はモデルは頂点カラーとテクスチャカラーを掛け合わせるだけの色計算を行うようになり、 あらゆるライトの設定もマテリアルの設定も無視されます。

　計算負荷は軽くなりますので、 背景等事前にライトの計算を行って頂点カラーに落とし込んだモデルなどを描画する際などにライティング計算をＯＦＦにします。

サンプル

DxChara.x をライティング計算をＯＦＦにして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ライティングの計算をしないように設定を変更
	SetUseLighting( FALSE ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetGlobalAmbientLight( COLOR_F Color ) ;

概略 グローバルアンビエントライトカラーを設定する

引数   COLOR_F Color ： グローバルアンビエントライトカラー( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　すべてのモデルに適用されるアンビエントカラー( 環境光色 )を設定します。
　各ライトの設定にもアンビエントカラーはありますが、 この値はその値に加算されます。( 初期値は真っ黒( Color のメンバ変数 r g b がすべて 0.0f )です )

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

　値を大きくすればするほど、マテリアルに設定されたアンビエントカラーの影響が大きくなります。
　逆に、この値を何にしてもマテリアルのアンビエントカラーが真っ黒だとなにも見た目は変わりません。

サンプル

グローバルアンビエントカラーを赤にしてモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// グローバルアンビエントカラーを赤色に変更
	SetGlobalAmbientLight( GetColorF( 1.0f, 0.0f, 0.0f, 0.0f ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 0.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


標準ライト関数

宣言 int ChangeLightTypeDir( VECTOR Direction ) ;

概略 標準ライトのタイプをディレクショナルライトにする

引数   VECTOR Direction ： ライトの方向
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのタイプを引数 Direction で示される方向の光を放つディレクショナルライトにします。( Direction は正規化されている必要はありません )

　ディレクショナルライトとは位置を持たず方向だけを設定するライトで、 太陽の光などの光源が遠すぎて何処に居ても同じ方向から照らされるライト効果などに使用します。
　因みにＤＸライブラリの初期設定では標準ライトはディレクショナルライトとなっています。

　計算負荷も最も軽いので、一番よく使うライトタイプです。

　尚、引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の向き指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　標準ライトの方向をＸ軸のマイナス方向にしてモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// Ｘ軸のマイナス方向のディレクショナルライトに変更
	ChangeLightTypeDir( VGet( -1.0f, 0.0f, 0.0f  ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 0.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int ChangeLightTypePoint( VECTOR Position, float Range, float Atten0, float Atten1, float Atten2 ) ;

概略 標準ライトのタイプをポイントライトにする

引数   VECTOR Position ： ライトの位置
float Range ： ライトの有効距離
float Atten0 ： 距離減衰パラメータ０
float Atten1 ： 距離減衰パラメータ１
float Atten2 ： 距離減衰パラメータ２
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのタイプを位置と距離減衰パラメータを持つポイントライトにします。
　ディレクショナルライトの次に使用頻度の高い、 指定した位置から全方向に光を放つライトです。

　引数の説明をします。

VECTER Position
　ポイントライトの位置です。

float Range
　ポイントライトの影響最大距離です。
　この引数で指定する距離以上の座標にある頂点は、 例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。

float Atten0
float Atten1
float Atten2
　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。
　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。
　その計算式は以下のようなものです。


d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )

　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、 Atten1 はライトの距離に比例して減衰する率、 Atten2 はライトの距離の二乗に比例して減衰する率となります。
　率を除算する値ですので、 非常に小さな値でも物凄くライトの影響範囲が狭まります。 なので引数に渡す値はこの式を理解してから決定してください。

　尚、引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　標準ライトをポイントライトにして、Ｄ～Ｈ、Ｃ～Ｎまでのキーを使用して
　各パラメータを変更できるようにしたサンプルです。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float Range, Atten0, Atten1, Atten2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 各パラメータを初期化
	Range = 2000.0f ;
	Atten0 = 0.0f ;
	Atten1 = 0.0006f ;
	Atten2 = 0.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ＤＣキーでライトの影響範囲を変更
		if( CheckHitKey( KEY_INPUT_D ) == 1 )
		{
			Range += 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_C ) == 1 )
		{
			Range -= 20.0f ;
		}

		// ＦＶキーでライトの距離減衰パラメータ０の値を変更
		if( CheckHitKey( KEY_INPUT_F ) == 1 )
		{
			Atten0 += 0.001f ;
		}
		if( CheckHitKey( KEY_INPUT_V ) == 1 )
		{
			Atten0 -= 0.001f ;
		}

		// ＧＢキーでライトの距離減衰パラメータ１の値を変更
		if( CheckHitKey( KEY_INPUT_G ) == 1 )
		{
			Atten1 += 0.00001f ;
		}
		if( CheckHitKey( KEY_INPUT_B ) == 1 )
		{
			Atten1 -= 0.00001f ;
		}

		// ＨＮキーでライトの距離減衰パラメータ２の値を変更
		if( CheckHitKey( KEY_INPUT_H ) == 1 )
		{
			Atten2 += 0.0000001f ;
		}
		if( CheckHitKey( KEY_INPUT_N ) == 1 )
		{
			Atten2 -= 0.0000001f ;
		}

		// 影響距離の値を補正
		if( Range ChangeLightTypePoint(
			VGet( 320.0f, 1000.0f, 200.0f ),
			Range,
			Atten0,
			Atten1,
			Atten2 ) ;

		// モデルをカメラの映る位置に移動
		MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 200.0f ) ) ;

		// モデルを描画
		MV1DrawModel( ModelHandle ) ;

		// パラメータの内容を画面に表示
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),  "Key:D.C  Range  %f", Range ) ;
		DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Key:F.V  Atten0 %f", Atten0 ) ;
		DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Key:G.B  Atten1 %f", Atten1 ) ;
		DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Key:H.N  Atten2 %f / 100.0f", Atten2 * 100.0f ) ;

		// 裏画面の内容を表画面に反映する
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int ChangeLightTypeSpot( VECTOR Position, VECTOR Direction, float OutAngle, float InAngle, float Range, float Atten0, float Atten1, float Atten2 ) ;

概略 標準ライトのタイプをスポットライトにする

引数   VECTOR Position ： ライトの位置
VECTOR Direction ： ライトの向き
float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )
float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )
float Range ： ライトの有効距離
float Atten0 ： 距離減衰パラメータ０
float Atten1 ： 距離減衰パラメータ１
float Atten2 ： 距離減衰パラメータ２
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのタイプを位置、方向、角度範囲、距離減衰パラメータを持つスポットライトにします。
　一番計算負荷が高く、 また頂点単位のライティングではポリゴンを細かく分割しておかないと思ったような結果が出ないなど扱いが難しいタイプのライトです。

　引数の説明をします。

VECTER Position
　スポットライトの位置です。

VECTOR Direction
　スポットライトの向きです

float OutAngle
　スポットライトの影響角度です。
　スポットライトの向きに対してこの引数で指定する角度以上の頂点にはライトの影響はありません。
　有効な値は 0.0f ～ PHI_F までです。

float InAngle
　スポットライトの影響が減衰を始める角度です。
　スポットライトが OutAngle の角度まで１００％の影響を与えて、 そこから急に影響が無い状態になりますと不自然に見えるかもしれません。
　そんなときはこの引数でスポットライトの影響が弱まり始める角度を指定します。
　スポットライトの向きに対してこの引数で指定する角度以上で且つ OutAngle 以下の場合はライトの影響が１００％ではなくなります。
　有効な値は 0.0f ～ OutAngle までです。

float Range
　スポットライトの影響最大距離です。
　この引数で指定する距離以上の座標にある頂点は、 例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。

float Atten0
float Atten1
float Atten2
　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。
　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。
　その計算式は以下のようなものです。


d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )

　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、 Atten1 はライトの距離に比例して減衰する率、 Atten2 はライトの距離の二乗に比例して減衰する率となります。
　率を除算する値ですので、 非常に小さな値でも物凄くライトの影響範囲が狭まります。 なので引数に渡す値はこの式を理解してから決定してください。

　尚、引数 Position と Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の座標や向きを指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　標準ライトをスポットライトにして、Ａ～Ｈ、Ｚ～Ｎまでのキーを使用して
　各パラメータを変更できるようにしたサンプルです。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float OutAngle, InAngle, Range, Atten0, Atten1, Atten2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 各パラメータを初期化
	OutAngle = 90.0f ;
	InAngle = 45.0f ;
	Range = 2000.0f ;
	Atten0 = 0.0f ;
	Atten1 = 0.0006f ;
	Atten2 = 0.0f ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ＡＺキーで OutAngle の値を変更
		if( CheckHitKey( KEY_INPUT_A ) == 1 )
		{
			OutAngle += 1.0f ;
		}
		if( CheckHitKey( KEY_INPUT_Z ) == 1 )
		{
			OutAngle -= 1.0f ;
		}

		// ＳＸキーで InAngle の値を変更
		if( CheckHitKey( KEY_INPUT_S ) == 1 )
		{
			InAngle += 1.0f ;
		}
		if( CheckHitKey( KEY_INPUT_X ) == 1 )
		{
			InAngle -= 1.0f ;
		}

		// ＤＣキーでライトの影響範囲を変更
		if( CheckHitKey( KEY_INPUT_D ) == 1 )
		{
			Range += 20.0f ;
		}
		if( CheckHitKey( KEY_INPUT_C ) == 1 )
		{
			Range -= 20.0f ;
		}

		// ＦＶキーでライトの距離減衰パラメータ０の値を変更
		if( CheckHitKey( KEY_INPUT_F ) == 1 )
		{
			Atten0 += 0.001f ;
		}
		if( CheckHitKey( KEY_INPUT_V ) == 1 )
		{
			Atten0 -= 0.001f ;
		}

		// ＧＢキーでライトの距離減衰パラメータ１の値を変更
		if( CheckHitKey( KEY_INPUT_G ) == 1 )
		{
			Atten1 += 0.00001f ;
		}
		if( CheckHitKey( KEY_INPUT_B ) == 1 )
		{
			Atten1 -= 0.00001f ;
		}

		// ＨＮキーでライトの距離減衰パラメータ２の値を変更
		if( CheckHitKey( KEY_INPUT_H ) == 1 )
		{
			Atten2 += 0.0000001f ;
		}
		if( CheckHitKey( KEY_INPUT_N ) == 1 )
		{
			Atten2 -= 0.0000001f ;
		}

		// 角度の値を補正
		if( OutAngle  180.0f ) OutAngle = 180.0f ;
		if( InAngle  OutAngle ) InAngle = OutAngle ;

		// 影響距離の値を補正
		if( Range ChangeLightTypeSpot(
			VGet( 320.0f, 1000.0f, 200.0f ),
			VGet( 0.0f, -1.0f, 0.0f  ),
			OutAngle * PHI_F / 180.0f,
			InAngle * PHI_F / 180.0f,
			Range,
			Atten0,
			Atten1,
			Atten2 ) ;

		// モデルをカメラの映る位置に移動
		MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 200.0f ) ) ;

		// モデルを描画
		MV1DrawModel( ModelHandle ) ;

		// パラメータの内容を画面に表示
		DrawFormatString( 0, 0,  GetColor( 255,255,255 ), "Key:A.Z  OutAngle( 度 ) %f", OutAngle ) ;
		DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Key:S.X  InAngle( 度 )  %f", InAngle ) ;
		DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Key:D.C  Range          %f", Range ) ;
		DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Key:F.V  Atten0         %f", Atten0 ) ;
		DrawFormatString( 0, 64, GetColor( 255,255,255 ), "Key:G.B  Atten1         %f", Atten1 ) ;
		DrawFormatString( 0, 80, GetColor( 255,255,255 ), "Key:H.N  Atten2         %f / 100.0f", Atten2 * 100.0f ) ;

		// 裏画面の内容を表画面に反映する
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightEnable( int EnableFlag ) ;

概略 標準ライトの有効、無効をセットする

引数   int EnableFlag ： 標準ライトを有効にするかどうか( TRUE：有効にする　FALSE：無効にする )
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトを有効にするかどうかを設定します。
　SetUseLighting と似ていますが、無効にした場合もライティング計算をしなくなるわけではなく、 ただ単に標準ライトだけが無効になるのでグローバルアンビエントライトやハンドルタイプのライトによるライティング計算が行われます。

サンプル

　　SimpleModel.mqo を普通に描画した後、標準ライトを無効にした状態で画面右側に描画します。
　標準ライトのディレクショナルライトは当たらず、自己発光色の灰色のみになっているのが確認できます。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 0.0f, 240.0f, 600.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// 標準ライトを無効にする
	SetLightEnable( FALSE ) ;

	// モデルの位置を変更
	MV1SetPosition( ModelHandle, VGet( 700.0f, 240.0f, 600.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightDifColor( COLOR_F Color ) ;

概略 標準ライトのディフューズカラーを設定する

引数   COLOR_F Color ： 標準ライトディフューズカラー
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのディフューズカラーを設定します。
　この関数で設定した値は描画対象のマテリアルのディフューズカラーと掛け合わされます。

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

サンプル

　　標準ライトのディフューズカラーを青色にした状態で SimpleModel.mqo を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 標準ライトのディフューズカラーを青色にする
	SetLightDifColor( GetColorF( 0.0f, 0.0f, 1.0f, 0.0f ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 300.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightSpcColor( COLOR_F Color ) ;

概略 標準ライトのスペキュラカラーを設定する

引数   COLOR_F Color ： 標準ライトスペキュラカラー
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのスペキュラカラーを設定します。
　この関数で設定した値は描画対象のマテリアルのスペキュラカラーと掛け合わされます。

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

サンプル

　　標準ライトのスペキュラカラーを黄色にした状態で SimpleModel.mqo を描画します。
　( スペキュラカラーの変化が変わりやすいようにディフューズカラーの色を黒にしています )
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// スペキュラカラーの変化がわかりやすいように標準ライトのディフューズカラーを真っ黒にする
	SetLightDifColor( GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ) ;

	// 標準ライトのスペキュラカラーを黄色にする
	SetLightSpcColor( GetColorF( 1.0f, 1.0f, 0.0f, 0.0f ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 300.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightAmbColor( COLOR_F Color ) ;

概略 標準ライトのアンビエントカラーを設定する

引数   COLOR_F Color ： 標準ライトアンビエントカラー
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのアンビエントカラーを設定します。
　この関数で設定した値は描画対象のマテリアルのアンビエントカラーと掛け合わされます。

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

サンプル

　　標準ライトのアンビエントカラーを暗い緑色にした状態で SimpleModel.mqo を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 標準ライトのアンビエントカラーを暗い緑色にする
	SetLightAmbColor( GetColorF( 0.0f, 0.2f, 0.0f, 0.0f ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 300.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightDirection( VECTOR Direction ) ;

概略 標準ライトの方向を設定する

引数   VECTOR Direction ： 標準ライトの方向
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトの向きを設定します。
　ChangeLightTypeDir や ChangeLightTypeSpot の引数 Direction の値だけを変更する関数です。
　ポイントライトにはライトの向きはないので、 ポイントライトに対してこの関数を使用しても何もおきません。

　尚、引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の向きを指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　標準ライトの向きをＸ軸のプラス方向にした状態で SimpleModel.mqo を描画します。
　( 標準ライトの初期タイプはディレクショナルライトです )
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 標準ライトの方向をＸ軸のプラス方向にする
	SetLightDirection( VGet( 1.0f, 0.0f, 0.0f ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 300.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightPosition( VECTOR Position ) ;

概略 標準ライトの位置を設定する

引数   VECTOR Position ： 標準ライトの位置
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトの位置を設定します。
　ChangeLightTypePoint や ChangeLightTypeSpot の引数 Position の値だけを変更する関数です。
　ディレクショナルライトにはライトの位置はないので、 ディレクショナルライトに対してこの関数を使用しても何もおきません。

　尚、引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の位置を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　標準ライトをポイントライトに変更した後、ライトの位置をモデルの上側に移動した状態で
　モデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 300.0f ) ) ;

	// 標準ライトをポイントライトにする
	ChangeLightTypePoint( VGet( 0.0f, 0.0f, 0.0f ), 2000.0f, 0.0f, 0.002f, 0.0f ) ;

	// 標準ライトの位置をモデルの上に移動する
	SetLightPosition( VGet( 320.0f, 1000.0f, 0.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightRangeAtten( float Range, float Atten0, float Atten1, float Atten2 ) ;

概略 標準ライトの有効距離と距離減衰パラメータを設定する

引数   float Range ： ライトの有効距離
float Atten0 ： 距離減衰パラメータ０
float Atten1 ： 距離減衰パラメータ１
float Atten2 ： 距離減衰パラメータ２
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトの距離減衰パラメータを設定します。
　ChangeLightTypePoint や ChangeLightTypeSpot の同名の引数の値を変更するだけの関数です。
　各パラメータの解説については ChangeLightTypePoint と ChangeLightTypeSpot 関数の解説を参照してください。
　ディレクショナルライトには距離減衰はないので、 ディレクショナルライトに対してこの関数を使用しても何もおきません。

サンプル

ありません



宣言 int SetLightAngle( float OutAngle, float InAngle ) ;

概略 標準ライトの照射角度パラメータを設定する

引数   float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )
float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトの照射角度パラメータを設定します。
　ChangeLightTypeSpot の同名の引数の値を変更するだけの関数です。
　各パラメータの解説については ChangeLightTypeSpot 関数の解説を参照してください。

サンプル

ありません



宣言 int GetLightType( void ) ;

概略 標準ライトのタイプを取得する

引数   なし
戻り値 －１以外：標準ライトのタイプ
　 －１：エラー発生

解説  　標準ライトのタイプを取得します。
　戻り値は以下のいずれかです。

DX_LIGHTTYPE_POINT
　　ポイントライト

DX_LIGHTTYPE_SPOT
　　スポットライト

DX_LIGHTTYPE_DIRECTIONAL
　　ディレクショナルライト

サンプル

　　標準ライトの情報を画面に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	char *TypeName ;
	COLOR_F Color ;
	VECTOR Vector ;
	float Range, Atten0, Atten1, Atten2 ;
	float InAngle, OutAngle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() DrawFormatString( 0, 0, GetColor( 255,255,255 ),   "LightType       %s", TypeName ) ;

	// ライトが有効かどうかを描画
	DrawFormatString( 0, 16, GetColor( 255,255,255 ),  "Enable          %d", GetLightEnable() ) ;

	// ディフューズカラーを描画
	Color = GetLightDifColor() ;
	DrawFormatString( 0, 32, GetColor( 255,255,255 ),  "Diffuse Color   %f %f %f", Color.r, Color.g, Color.b ) ;

	// スペキュラカラーを描画
	Color = GetLightSpcColor() ;
	DrawFormatString( 0, 48, GetColor( 255,255,255 ),  "Specular Color  %f %f %f", Color.r, Color.g, Color.b ) ;

	// アンビエントカラーを描画
	Color = GetLightAmbColor() ;
	DrawFormatString( 0, 64, GetColor( 255,255,255 ),  "Ambient Color   %f %f %f", Color.r, Color.g, Color.b ) ;

	// 向きを描画
	Vector = GetLightDirection() ;
	DrawFormatString( 0, 80, GetColor( 255,255,255 ),  "Direction       %f %f %f", Vector.x, Vector.y, Vector.z ) ;

	// 位置を描画
	Vector = GetLightPosition() ;
	DrawFormatString( 0, 96, GetColor( 255,255,255 ),  "Position        %f %f %f", Vector.x, Vector.y, Vector.z ) ;

	// 有効距離と距離減衰パラメータを描画する
	GetLightRangeAtten( &Range, &Atten0, &Atten1, &Atten2 ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Range           %f", Range ) ;
	DrawFormatString( 0, 128, GetColor( 255,255,255 ), "Attenuation0    %f", Atten0 ) ;
	DrawFormatString( 0, 144, GetColor( 255,255,255 ), "Attenuation1    %f", Atten1 ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "Attenuation2    %f", Atten2 ) ;

	// 照射角度パラメータを描画する
	GetLightAngle( &OutAngle, &InAngle ) ;
	DrawFormatString( 0, 176, GetColor( 255,255,255 ), "In  Angle       %f", InAngle ) ;
	DrawFormatString( 0, 192, GetColor( 255,255,255 ), "Out Angle       %f", OutAngle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int GetLightEnable( void ) ;

概略 標準ライトの有効、無効を取得する

引数   なし
戻り値 TRUE：標準ライトは有効
　 FALSE：標準ライトは無効

　 －１：エラー発生

解説  　標準ライトが有効かどうかを取得します。
　　　戻り値が TRUE の場合は有効で、FALSE の場合は無効です。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 COLOR_F GetLightDifColor( void ) ;

概略 標準ライトのディフューズカラーを取得する

引数   なし
戻り値 ディフューズカラー
解説  　標準ライトのディフューズカラーを取得します。
　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。
　ライトのカラーでは a の値は使いません。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 COLOR_F GetLightSpcColor( void ) ;

概略 標準ライトのスペキュラカラーを取得する

引数   なし
戻り値 スペキュラカラー
解説  　標準ライトのスペキュラカラーを取得します。
　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。
　ライトのカラーでは a の値は使いません。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 COLOR_F GetLightAmbColor( void ) ;

概略 標準ライトのアンビエントカラーを取得する

引数   なし
戻り値 アンビエントカラー
解説  　標準ライトのアンビエントカラーを取得します。
　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。
　ライトのカラーでは a の値は使いません。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 VECTOR GetLightDirection( void ) ;

概略 標準ライトの向きを取得する

引数   なし
戻り値 標準ライトの向き
解説  　標準ライトの向きを取得します。
　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 VECTOR GetLightPosition( void ) ;

概略 標準ライトの位置を取得する

引数   なし
戻り値 標準ライトの位置
解説  　標準ライトの位置を取得します。
　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 int GetLightRangeAtten( float *Range, float *Atten0, float *Atten1, float *Atten2 ) ;

概略 標準ライトの有効距離と距離減衰パラメータを取得する

引数   float *Range ： 有効距離を代入する変数のアドレス
float *Atten0 ： 距離減衰パラメータ０を代入する変数のアドレス
float *Atten1 ： 距離減衰パラメータ１を代入する変数のアドレス
float *Atten2 ： 距離減衰パラメータ２を代入する変数のアドレス
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトの有効距離と距離減衰パラメータを取得します。

サンプル

　GetLightType関数 のサンプルを参照してください。



宣言 int GetLightAngle( float *OutAngle, float *InAngle ) ;

概略 標準ライトの照射角度パラメータを取得する

引数   float *OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )を代入する変数のアドレス
float *InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )を代入する変数のアドレス
戻り値 　０：成功
　 －１：エラー発生

解説  　標準ライトのスポットライトコーンの角度を取得します。

サンプル

　GetLightType関数 のサンプルを参照してください。



ライトハンドル関数

宣言 int CreateDirLightHandle( VECTOR Direction ) ;

概略 ディレクショナルタイプのライトハンドルを作成する

引数   VECTOR Direction ： ライトの方向
戻り値 ０以上：ライトハンドル
　 －１：エラー発生

解説  　ディレクショナルタイプのライトハンドルを作成します。 ( ディレクショナルライトとは位置を持たず方向だけを設定するライトで、 太陽の光などの光源が遠すぎて何処に居ても同じ方向から照らされるライト効果などに使用します )

　この関数は戻り値にライトハンドル( int 型の数値 )を返してきます。
　ライトハンドルの設定を変更したり、 不要になったライトハンドルを削除したりする際に必要になりますので戻り値は必ず何かしらの変数に保存しておくようにしてください。

　引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の向き指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

　尚、ライトハンドル系の関数は一つしかない標準ライト以外にライトを使用したい場合に使用します。 ( とはいえ同時に有効にできるのは標準ライトを含めて３つまでですが・・・ )

サンプル

　　Ｘ軸にマイナス方向のディレクショナルライトハンドルを作成して、
　効果がわかり易いように標準ライトを無効にした上でモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, LightHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// Ｘ軸にマイナス方向のディレクショナルタイプのライトの作成
	LightHandle = CreateDirLightHandle( VGet( -1.0f, 0.0f, 0.0f ) ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int CreatePointLightHandle( VECTOR Position, float Range, float Atten0, float Atten1, float Atten2 ) ;

概略 ポイントタイプのライトハンドルを作成する

引数   VECTOR Position ： ライトの位置
float Range ： ライトの有効距離
float Atten0 ： 距離減衰パラメータ０
float Atten1 ： 距離減衰パラメータ１
float Atten2 ： 距離減衰パラメータ２
戻り値 ０以上：ライトハンドル
　 －１：エラー発生

解説  　ポイントタイプのライトハンドルを作成します。 ( ポイントライトは指定した位置から全方向に光を放つライトです )

　この関数は戻り値にライトハンドル( int 型の数値 )を返してきます。
　ライトハンドルの設定を変更したり、 不要になったライトハンドルを削除したりする際に必要になりますので戻り値は必ず何かしらの変数に保存しておくようにしてください。

　引数の説明をします。

VECTER Position
　ポイントライトの位置です。

float Range
　ポイントライトの影響最大距離です。
　この引数で指定する距離以上の座標にある頂点は、 例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。

float Atten0
float Atten1
float Atten2
　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。
　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。
　その計算式は以下のようなものです。


d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )

　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、 Atten1 はライトの距離に比例して減衰する率、 Atten2 はライトの距離の二乗に比例して減衰する率となります。
　率を除算する値ですので、 非常に小さな値でも物凄くライトの影響範囲が狭まります。 なので引数に渡す値はこの式を理解してから決定してください。

　引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の向き指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

　尚、ライトハンドル系の関数は一つしかない標準ライト以外にライトを使用したい場合に使用します。 ( とはいえ同時に有効にできるのは標準ライトを含めて３つまでですが・・・ )

サンプル

　　読み込んだモデルの上側にポイントライトを作成して、
　効果がわかり易いように標準ライトを無効にした上でモデルを描画します。

　　ポイントライトの各パラメータを変化させるとどのような変化があるのかは
　ChangeLightTypePoint関数 のサンプルで確認できます。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, LightHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// モデルの上側にポイントタイプのライトを作成
	LightHandle = CreatePointLightHandle(
					VGet( 320.0f, 1000.0f, 600.0f ),
					2000.0f,
					0.0f,
					0.002f,
					0.0f ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int CreateSpotLightHandle( VECTOR Position, VECTOR Direction, float OutAngle, float InAngle, float Range, float Atten0, float Atten1, float Atten2 ) ;

概略 スポットタイプのライトハンドルを作成する

引数   VECTOR Position ： ライトの位置
VECTOR Direction ： ライトの向き
float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )
float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )
float Range ： ライトの有効距離
float Atten0 ： 距離減衰パラメータ０
float Atten1 ： 距離減衰パラメータ１
float Atten2 ： 距離減衰パラメータ２
戻り値 ０以上：ライトハンドル
　 －１：エラー発生

解説  　スポットタイプのライトハンドルを作成します。 ( スポットライトは指定した位置から指定の方向に全方向に光を放つライトです )

　この関数は戻り値にライトハンドル( int 型の数値 )を返してきます。
　ライトハンドルの設定を変更したり、 不要になったライトハンドルを削除したりする際に必要になりますので戻り値は必ず何かしらの変数に保存しておくようにしてください。

　引数の説明をします。

VECTER Position
　スポットライトの位置です。

VECTOR Direction
　スポットライトの向きです

float OutAngle
　スポットライトの影響角度です。
　スポットライトの向きに対してこの引数で指定する角度以上の頂点にはライトの影響はありません。
　有効な値は 0.0f ～ PHI_F までです。

float InAngle
　スポットライトの影響が減衰を始める角度です。
　スポットライトが OutAngle の角度まで１００％の影響を与えて、 そこから急に影響が無い状態になりますと不自然に見えるかもしれません。
　そんなときはこの引数でスポットライトの影響が弱まり始める角度を指定します。
　スポットライトの向きに対してこの引数で指定する角度以上で且つ OutAngle 以下の場合はライトの影響が１００％ではなくなります。
　有効な値は 0.0f ～ OutAngle までです。

float Range
　スポットライトの影響最大距離です。
　この引数で指定する距離以上の座標にある頂点は、 例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。

float Atten0
float Atten1
float Atten2
　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。
　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。
　その計算式は以下のようなものです。


d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )

　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、 Atten1 はライトの距離に比例して減衰する率、 Atten2 はライトの距離の二乗に比例して減衰する率となります。
　率を除算する値ですので、 非常に小さな値でも物凄くライトの影響範囲が狭まります。 なので引数に渡す値はこの式を理解してから決定してください。

　引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の向き指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

　尚、ライトハンドル系の関数は一つしかない標準ライト以外にライトを使用したい場合に使用します。 ( とはいえ同時に有効にできるのは標準ライトを含めて３つまでですが・・・ )

サンプル

　　読み込んだモデルの上側に下向きの光を放つスポットライトを作成して、
　効果がわかり易いように標準ライトを無効にした上でモデルを描画します。

　　スポットライトの各パラメータを変化させるとどのような変化があるのかは
　ChangeLightTypeSpot関数 のサンプルで確認できます。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, LightHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// モデルをカメラの映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// モデルの上側に下向きのスポットタイプのライトを作成
	LightHandle = CreateSpotLightHandle(
					VGet( 320.0f, 1000.0f, 600.0f ),
					VGet( 0.0f, -1.0f, 0.0f ),
					PHI_F / 2.0f,
					PHI_F / 4.0f,
					2000.0f,
					0.0f,
					0.002f,
					0.0f ) ;

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DeleteLightHandle( int LHandle ) ;

概略 ライトハンドルを削除する

引数   int LHandle ： 削除するライトハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　CreateDirLightHandle, CreatePointLightHandle, CreateSpotLightHandle で作成したライトハンドルを削除します。

　作成できるライトハンドルの数には限界がありますので、 不要になったライトハンドルは必ずこの関数で削除してください。

　因みに DxLib_End を使用すると自動的にすべてのライトが削除されますので、 DxLib_End の前にすべてのライトハンドルを削除しておかなければならないということはありません。

サンプル

　　ディレクショナルライトを作成してすぐ削除します。
　　削除関数を使うサンプルプログラムなので実行しても何も起きません。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() CreateDirLightHandle( VGet( 1.0f, 0.0f, 0.0f ) ) ;

	// 直後に削除
	DeleteLightHandle( LightHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DeleteLightHandleAll( void ) ;

概略 ライトハンドルを全て削除する

引数   なし
戻り値 　０：成功
　 －１：エラー発生

解説  　CreateDirLightHandle, CreatePointLightHandle, CreateSpotLightHandle で作成したライトハンドルを全て削除します。

　作成できるライトハンドルの数には限界がありますので、 ライトハンドルが不要になった際は必ずこの関数で削除してください。

　因みに DxLib_End を使用すると自動的にすべてのライトが削除されますので、 DxLib_End の前にこの関数を呼んでおかなければならないということはありません。

サンプル

ありません



宣言 int SetLightTypeHandle( int LHandle, int LightType ) ;

概略 ライトハンドルのタイプを変更する

引数   int LHandle ： ライトハンドル
int LightType ： ライトタイプ
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトタイプを変更します。
　ライトタイプに指定できる値は以下の３つです。

DX_LIGHTTYPE_DIRECTIONAL
　　ディレクショナルライト

DX_LIGHTTYPE_POINT
　　ポイントライト

DX_LIGHTTYPE_SPOT
　　スポットライト

サンプル

　　ディレクショナルタイプのライトを作成した後、それをポイントタイプのライトに変更して
　ポイントライトとしてのパラメータを設定した後モデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle, ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ディレクショナルタイプのライトハンドルの作成
	LightHandle = CreateDirLightHandle( VGet( 1.0f, 0.0f, 0.0f ) ) ;

	// ライトのタイプをポイントライトに変更
	SetLightTypeHandle( LightHandle, DX_LIGHTTYPE_POINT ) ;

	// 位置を設定
	SetLightPositionHandle( LightHandle, VGet( 320.0f, 1000.0f, 600.0f ) ) ;

	// 有効距離と距離減衰パラメータを設定
	SetLightRangeAttenHandle( LightHandle, 2000.0f, 0.0f, 0.002f, 0.0f ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightEnableHandle( int LHandle, int EnableFlag ) ;

概略 ライトハンドルのライトの有効、無効を設定する

引数   int LHandle ： ライトハンドル
int EnableFlag ： 標準ライトを有効にするかどうか( TRUE：有効にする　FALSE：無効にする )
戻り値 　０：成功
　 －１：エラー発生

解説  　指定のライトハンドルのライトを有効にするかどうかを設定します。
　同時に有効にできる数は標準ライトを含めて３つまでです。

　既に３つ有効なライトがある状態でライトを有効にすると、どのライトが有効になるかは不定となります。

サンプル

　　３つのディレクショナルタイプのライトハンドルを作成した後、各ライトを５０％の確率で
　無効にして、そのあとモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle[ 3 ], ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ディレクショナルタイプのライトハンドルを３つ作成
	LightHandle[ 0 ] = CreateDirLightHandle( VGet( 1.0f, 0.0f, 0.0f ) ) ;
	LightHandle[ 1 ] = CreateDirLightHandle( VGet( 0.0f, 1.0f, 0.0f ) ) ;
	LightHandle[ 2 ] = CreateDirLightHandle( VGet( 0.0f, 0.0f, 1.0f ) ) ;

	// 各ライトを５０％の確率で無効にする
	if( GetRand( 99 ) >= 50 )
	{
		SetLightEnableHandle( LightHandle[ 0 ], FALSE ) ;
	}

	if( GetRand( 99 ) >= 50 )
	{
		SetLightEnableHandle( LightHandle[ 1 ], FALSE ) ;
	}

	if( GetRand( 99 ) >= 50 )
	{
		SetLightEnableHandle( LightHandle[ 2 ], FALSE ) ;
	}

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightDifColorHandle( int LHandle, COLOR_F Color ) ;

概略 ライトハンドルのライトのディフューズカラーを設定する

引数   int LHandle ： ライトハンドル
COLOR_F Color ： ディフューズカラー
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのディフューズカラーを設定します。
　この関数で設定した値は描画対象のマテリアルのディフューズカラーと掛け合わされます。

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

サンプル

　　ライトハンドルのディフューズカラーを青色にした状態で SimpleModel.mqo を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle, ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ディレクショナルタイプのライトハンドルを作成
	LightHandle = CreateDirLightHandle( VGet( 1.0f, -1.0f, 1.0f ) ) ;

	// ライトハンドルのディフューズカラーを青色にする
	SetLightDifColorHandle( LightHandle, GetColorF( 0.0f, 0.0f, 1.0f, 0.0f ) ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightSpcColorHandle( int LHandle, COLOR_F Color ) ;

概略 ライトハンドルのライトのスペキュラカラーを設定する

引数   int LHandle ： ライトハンドル
COLOR_F Color ： スペキュラカラー
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのスペキュラカラーを設定します。
　この関数で設定した値は描画対象のマテリアルのスペキュラカラーと掛け合わされます。

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

サンプル

　　ライトハンドルのスペキュラカラーを赤色にした状態で SimpleModel.mqo を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle, ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ディレクショナルタイプのライトハンドルを作成
	LightHandle = CreateDirLightHandle( VGet( 1.0f, -1.0f, 1.0f ) ) ;

	// スペキュラカラーの変更がわかり易いようにディフューズカラーを黒にする
	SetLightDifColorHandle( LightHandle, GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ) ;

	// ライトハンドルのスペキュラカラーを赤色にする
	SetLightSpcColorHandle( LightHandle, GetColorF( 1.0f, 0.0f, 0.0f, 0.0f ) ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightAmbColorHandle( int LHandle, COLOR_F Color ) ;

概略 ライトハンドルのライトのアンビエントカラーを設定する

引数   int LHandle ： ライトハンドル
COLOR_F Color ： アンビエントカラー
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのアンビエントカラーを設定します。
　この関数で設定した値は描画対象のマテリアルのアンビエントカラーと掛け合わされます。

　引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。 ( 因みにライト関係の関数では a の値は使われません )

サンプル

　　ライトハンドルのアンビエントカラーを暗い緑色にした状態で SimpleModel.mqo を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle, ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ディレクショナルタイプのライトハンドルを作成
	LightHandle = CreateDirLightHandle( VGet( 1.0f, -1.0f, 1.0f ) ) ;

	// ライトハンドルのアンビエントカラーを暗い緑色にする
	SetLightAmbColorHandle( LightHandle, GetColorF( 0.0f, 0.2f, 0.0f, 0.0f ) ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightDirectionHandle( int LHandle, VECTOR Direction ) ;

概略 ライトハンドルのライトの方向を設定する

引数   int LHandle ： ライトハンドル
VECTOR Direction ： 標準ライトの方向
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトの向きを設定します。
　CreateDirLightHandle や CreateSpotLightHandle の引数 Direction の値だけを変更する関数です。
　ポイントライトにはライトの向きはないので、 ポイントライトに対してこの関数を使用しても何もおきません。

　尚、引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の向きを指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　ライトハンドルのライトの向きをＸ軸のプラス方向にした状態で SimpleModel.mqo を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle, ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ディレクショナルタイプのライトハンドルを作成
	LightHandle = CreateDirLightHandle( VGet( 1.0f, -1.0f, 1.0f ) ) ;

	// ライトハンドルの方向をＸ軸のプラス方向にする
	SetLightDirectionHandle( LightHandle, VGet( 1.0f, 0.0f, 0.0f ) ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightPositionHandle( int LHandle, VECTOR Position ) ;

概略 ライトハンドルのライトの位置を設定する

引数   int LHandle ： ライトハンドル VECTOR Position ： 標準ライトの位置
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトの位置を設定します。
　CreatePointLightHandle や CreateSpotLightHandle の引数 Position の値だけを変更する関数です。
　ディレクショナルライトにはライトの位置はないので、 ディレクショナルライトに対してこの関数を使用しても何もおきません。

　尚、引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、 この３要素を使用して３次元の位置を指定します。
　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、 引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 VGet を使用することで簡素に引数を渡すことができます。

サンプル

　　ポイントタイプのライトを作成した後、ライトの位置をモデルの上側に移動してから
　モデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int LightHandle, ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
	SetLightEnable( FALSE ) ;

	// ポイントタイプのライトハンドルを作成
	LightHandle = CreatePointLightHandle(
					VGet( 320.0f, 1000.0f, 600.0f ),
					2000.0f,
					0.0f,
					0.002f,
					0.0f ) ;

	// ライトハンドルの位置をモデルの上側に移動
	SetLightPositionHandle( LightHandle, VGet( 320.0f, 1000.0f, 600.0f ) ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int SetLightRangeAttenHandle( int LHandle, float Range, float Atten0, float Atten1, float Atten2 ) ;

概略 ライトハンドルのライトの有効距離と距離減衰パラメータを設定する

引数   int LHandle ： ライトハンドル
float Range ： ライトの有効距離
float Atten0 ： 距離減衰パラメータ０
float Atten1 ： 距離減衰パラメータ１
float Atten2 ： 距離減衰パラメータ２
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトの距離減衰パラメータを設定します。
　CreatePointLightHandle や CreateSpotLightHandle の同名の引数の値を変更するだけの関数です。
　各パラメータの解説については CreatePointLightHandle と CreateSpotLightHandle 関数の解説を参照してください。
　ディレクショナルライトには距離減衰はないので、 ディレクショナルライトに対してこの関数を使用しても何もおきません。

サンプル

ありません



宣言 int SetLightAngleHandle( int LHandle, float OutAngle, float InAngle ) ;

概略 ライトハンドルのライトの照射角度パラメータを設定する

引数   int LHandle ： ライトハンドル
float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )
float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトの照射角度パラメータを設定します。
　CreateSpotLightHandle の同名の引数の値を変更するだけの関数です。
　各パラメータの解説については CreateSpotLightHandle 関数の解説を参照してください。

サンプル

ありません



宣言 int GetLightTypeHandle( int LHandle ) ;

概略 ライトハンドルのライトのタイプを取得する

引数   int LHandle ： ライトハンドル
戻り値 －１以外：ライトのタイプ
　 －１：エラー発生

解説  　ライトハンドルのライトのタイプを取得します。
　戻り値は以下のいずれかです。

DX_LIGHTTYPE_POINT
　　ポイントライト

DX_LIGHTTYPE_SPOT
　　スポットライト

DX_LIGHTTYPE_DIRECTIONAL
　　ディレクショナルライト

サンプル

　　スポットライトを作成して、そのライトの情報を画面に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	char *TypeName ;
	COLOR_F Color ;
	VECTOR Vector ;
	float Range, Atten0, Atten1, Atten2 ;
	float InAngle, OutAngle ;
	int LightHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() CreateSpotLightHandle(
					VGet( 320.0f, 1000.0f, 600.0f ),
					VGet( 0.0f, -1.0f, 0.0f ),
					PHI_F / 2.0f,
					PHI_F / 4.0f,
					2000.0f,
					0.0f,
					0.002f,
					0.0f ) ;

	// 画面に標準ライトのタイプを描画
	switch( GetLightTypeHandle( LightHandle ) )
	{
	case DX_LIGHTTYPE_DIRECTIONAL : TypeName = "Directional" ; break ;
	case DX_LIGHTTYPE_POINT :       TypeName = "Point" ;       break ;
	case DX_LIGHTTYPE_SPOT :        TypeName = "Spot" ;        break ;
	}
	DrawFormatString( 0, 0, GetColor( 255,255,255 ),   "LightType       %s", TypeName ) ;

	// ライトが有効かどうかを描画
	DrawFormatString( 0, 16, GetColor( 255,255,255 ),  "Enable          %d", GetLightEnableHandle( LightHandle ) ) ;

	// ディフューズカラーを描画
	Color = GetLightDifColorHandle( LightHandle ) ;
	DrawFormatString( 0, 32, GetColor( 255,255,255 ),  "Diffuse Color   %f %f %f", Color.r, Color.g, Color.b ) ;

	// スペキュラカラーを描画
	Color = GetLightSpcColorHandle( LightHandle ) ;
	DrawFormatString( 0, 48, GetColor( 255,255,255 ),  "Specular Color  %f %f %f", Color.r, Color.g, Color.b ) ;

	// アンビエントカラーを描画
	Color = GetLightAmbColorHandle( LightHandle ) ;
	DrawFormatString( 0, 64, GetColor( 255,255,255 ),  "Ambient Color   %f %f %f", Color.r, Color.g, Color.b ) ;

	// 向きを描画
	Vector = GetLightDirectionHandle( LightHandle ) ;
	DrawFormatString( 0, 80, GetColor( 255,255,255 ),  "Direction       %f %f %f", Vector.x, Vector.y, Vector.z ) ;

	// 位置を描画
	Vector = GetLightPositionHandle( LightHandle ) ;
	DrawFormatString( 0, 96, GetColor( 255,255,255 ),  "Position        %f %f %f", Vector.x, Vector.y, Vector.z ) ;

	// 有効距離と距離減衰パラメータを描画する
	GetLightRangeAttenHandle( LightHandle, &Range, &Atten0, &Atten1, &Atten2 ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Range           %f", Range ) ;
	DrawFormatString( 0, 128, GetColor( 255,255,255 ), "Attenuation0    %f", Atten0 ) ;
	DrawFormatString( 0, 144, GetColor( 255,255,255 ), "Attenuation1    %f", Atten1 ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "Attenuation2    %f", Atten2 ) ;

	// 照射角度パラメータを描画する
	GetLightAngleHandle( LightHandle, &OutAngle, &InAngle ) ;
	DrawFormatString( 0, 176, GetColor( 255,255,255 ), "In  Angle       %f", InAngle ) ;
	DrawFormatString( 0, 192, GetColor( 255,255,255 ), "Out Angle       %f", OutAngle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int GetLightEnableHandle( int LHandle ) ;

概略 ライトハンドルのライトの有効、無効を取得する

引数   int LHandle ： ライトハンドル
戻り値 TRUE：ライトは有効
　 FALSE：ライトは無効

　 －１：エラー発生

解説  　ライトハンドルのライトが有効かどうかを取得します。
　　　戻り値が TRUE の場合は有効で、FALSE の場合は無効です。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 COLOR_F GetLightDifColorHandle( int LHandle ) ;

概略 ライトハンドルのライトのディフューズカラーを取得する

引数   int LHandle ： ライトハンドル
戻り値 ディフューズカラー
解説  　ライトハンドルのライトのディフューズカラーを取得します。
　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。
　ライトのカラーでは a の値は使いません。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 COLOR_F GetLightSpcColorHandle( int LHandle ) ;

概略 ライトハンドルのライトのスペキュラカラーを取得する

引数   int LHandle ： ライトハンドル
戻り値 スペキュラカラー
解説  　ライトハンドルのライトのスペキュラカラーを取得します。
　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。
　ライトのカラーでは a の値は使いません。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 COLOR_F GetLightAmbColorHandle( int LHandle ) ;

概略 ライトハンドルのライトのアンビエントカラーを取得する

引数   int LHandle ： ライトハンドル
戻り値 アンビエントカラー
解説  　ライトハンドルのライトのアンビエントカラーを取得します。
　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。
　ライトのカラーでは a の値は使いません。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 VECTOR GetLightDirectionHandle( int LHandle ) ;

概略 ライトハンドルのライトの方向を取得する

引数   int LHandle ： ライトハンドル
戻り値 ライトの向き
解説  　ライトハンドルのライトの向きを取得します。
　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 VECTOR GetLightPositionHandle( int LHandle ) ;

概略 ライトハンドルのライトの位置を取得する

引数   int LHandle ： ライトハンドル
戻り値 ライトの位置
解説  　ライトハンドルのライトの位置を取得します。
　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 int GetLightRangeAttenHandle( int LHandle, float *Range, float *Atten0, float *Atten1, float *Atten2 ) ;

概略 ライトハンドルのライトの有効距離と距離減衰パラメータを取得する

引数   int LHandle ： ライトハンドル
float *Range ： 有効距離を代入する変数のアドレス
float *Atten0 ： 距離減衰パラメータ０を代入する変数のアドレス
float *Atten1 ： 距離減衰パラメータ１を代入する変数のアドレス
float *Atten2 ： 距離減衰パラメータ２を代入する変数のアドレス
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトの有効距離と距離減衰パラメータを取得します。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



宣言 int GetLightAngleHandle( int LHandle, float *OutAngle, float *InAngle ) ;

概略 ライトハンドルのライトの照射角度パラメータを取得する

引数   int LHandle ： ライトハンドル
float *OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )を代入する変数のアドレス
float *InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )を代入する変数のアドレス
戻り値 　０：成功
　 －１：エラー発生

解説  　ライトハンドルのライトのスポットライトコーンの角度を取得します。

サンプル

　GetLightTypeHandle関数 のサンプルを参照してください。



算術演算関数

宣言 VECTOR VGet( float x, float y, float z ) ;

概略 ベクトルを取得する

引数   float x ： 取得するベクトルのＸ成分
float y ： 取得するベクトルのＹ成分
float z ： 取得するベクトルのＺ成分
戻り値 引数 x,y,z を代入したVECTOR 構造体
解説  　引数 x, y, z を VECTOR 構造体のメンバ変数 x, y, z に代入して返すだけの関数です。


戻り値.x = x ;
戻り値.y = y ;
戻り値.z = z ;

サンプル

　　VECTOR 構造体 Vect に値を代入します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 400.0f ) ;

	// Vect の内容を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;  

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VAdd( VECTOR In1, VECTOR In2 ) ;

概略 二つのベクトルを加算する

引数   VECTOR In1 ： 加算されるベクトル
VECTOR In2 ： 加算するベクトル
戻り値 In1 と In2 の値を加算した VECTOR 構造体
解説  　引数 In1 と In2 の x, y, z 成分を加算した結果を戻り値として返す関数です。


戻り値.x = In1.x + In2.x ;
戻り値.y = In1.y + In2.y ;
戻り値.z = In1.z + In2.z ;

サンプル

　　VECTOR 構造体 Vect1 と Vect2 を加算して、結果を Vect1 に代入します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;
	Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

	// Vect1 と Vect2 を加算して結果を Vect1 に代入
	Vect1 = VAdd( Vect1, Vect2 ) ;

	// Vect1 の内容を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VSub( VECTOR In1, VECTOR In2 ) ;

概略 二つのベクトルを減算する

引数   VECTOR In1 ： 減算されるベクトル
VECTOR In2 ： 減算するベクトル
戻り値 In1 から In2 の値を減算した VECTOR 構造体
解説  　引数 In1 から In2 の x, y, z 成分を減算した結果を戻り値として返す関数です。


戻り値.x = In1.x - In2.x ;
戻り値.y = In1.y - In2.y ;
戻り値.z = In1.z - In2.z ;

サンプル

　　VECTOR 構造体 Vect1 から Vect2 を減算して、結果を Vect1 に代入します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;
	Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

	// Vect1 から Vect2 を減算して結果を Vect1 に代入
	Vect1 = VSub( Vect1, Vect2 ) ;

	// Vect1 の内容を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float VDot( VECTOR In1, VECTOR In2 ) ;

概略 二つのベクトルの内積を取得する

引数   VECTOR In1 ： 内積するベクトル１
VECTOR In2 ： 内積するベクトル２
戻り値 In1 と In2 の内積値
解説  　引数 In1 と In2 の内積を返す関数です。


戻り値 = In1.x * In2.x + In1.y * In2.y + In1.z * In2.z ;

サンプル

　　VECTOR 構造体 Vect1 と Vect2 の内積を画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;
	Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

	// Vect1 と Vect2 の内積を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Dot  %f", VDot( Vect1, Vect2 ) ) ;  

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VCross( VECTOR In1, VECTOR In2 ) ;

概略 二つのベクトルの外積を取得する

引数   VECTOR In1 ： 外積するベクトル１
VECTOR In2 ： 外積するベクトル２
戻り値 In1 と In2 の外積値
解説  　引数 In1 と In2 の外積を返す関数です。


戻り値.x = In1.y * In2.z - In1.z * In2.y ;
戻り値.y = In1.z * In2.x - In1.x * In2.z ;
戻り値.z = In1.x * In2.y - In1.y * In2.x ;

サンプル

　　VECTOR 構造体 Vect1 と Vect2 の外積を画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;
	Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

	// Vect1 と Vect2 の外戚を Vect1 に代入
	Vect1 = VCross( Vect1, Vect2 ) ;

	// Vect1 の内容を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VScale( VECTOR In, float Scale ) ;

概略 ベクトルのスケーリングをする

引数   VECTOR In ： スケーリングをするベクトル
float Scale ： スケーリング値
戻り値 スケーリングした結果の VECTOR 構造体
解説  　引数 In のベクトルを Scale 倍して返す関数です。


戻り値.x = In.y * Scale ;
戻り値.y = In.z * Scale ;
戻り値.z = In.x * Scale ;

サンプル

　　VECTOR 構造体 Vect の内容を 8.0f 倍して、その結果を画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;

	// Vect を 8.0f 倍して、その結果を Vect に代入
	Vect = VScale( Vect, 8.0f ) ;

	// Vect の内容を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;  

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float VSize( VECTOR In ) ;

概略 ベクトルのサイズを取得する

引数   VECTOR In ： サイズを取得したいベクトル
戻り値 ベクトルのサイズ
解説  　引数 In のベクトルのサイズを取得する関数です。


戻り値 = sqrt( In1.x * In1.x + In1.y * In1.y + In1.z * In1.z ) ;

サンプル

　　VECTOR 構造体 Vect のサイズを画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;

	// Vect のサイズを画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Size  %f", VSize( Vect ) ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float VSquareSize( VECTOR In ) ;

概略 ベクトルのサイズの２乗を取得する

引数   VECTOR In ： サイズの二乗を取得したいベクトル
戻り値 ベクトルのサイズの二乗
解説  　引数 In のベクトルのサイズの二乗を取得する関数です。

　ベクトルのサイズを算出するには処理負荷の高い平方根計算を行わなければならないので、 二つのサイズの比較等、 サイズの二乗でも処理に支障が発生しない場合はこちらの関数を使用したほうが処理負荷が低くて済みます。


戻り値 = In1.x * In1.x + In1.y * In1.y + In1.z * In1.z ;

サンプル

　　VECTOR 構造体 Vect のサイズの二乗を画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;

	// Vect のサイズの二乗を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Size  %f", VSquareSize( Vect ) ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VNorm( VECTOR In ) ;

概略 正規化ベクトルを取得する

引数   VECTOR In ： 正規化したいベクトル
戻り値 正規化したベクトル
解説  　引数 In を正規化したベクトルを取得する関数です。
　正規化とはベクトルの方向は変えずにサイズを１にすることで、 ベクトルの方向成分だけを取得したい場合などに行います。


float size ;
size =  VSize( In ) ;
戻り値.x = In1.x / size ;
戻り値.y = In1.y / size ;
戻り値.z = In1.z / size ;

サンプル

　　VECTOR 構造体 Vect を正規化した値を画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;

	// Vect の値を正規化して、その結果を Vect に代入する
	Vect = VNorm( Vect ) ;

	// Vect の値を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VTransform( VECTOR InV, MATRIX InM ) ;

概略 行列を使ったベクトルの変換

引数   VECTOR InV ： 変換処理を行いたいベクトル
MATRIX InM ： 変換処理に使用するベクトル
戻り値 変換後のベクトル
解説  　引数 InV のベクトルを引数 InM の行列を使用して変換処理を行います。
　計算的には InV を１ｘ４行列として扱い( 4つめの要素は 1.0f とします ) InM の行列の左から乗算した結果を返します。


戻り値.x = InV.x * InM.m[0][0] + InV.y * InM.m[1][0] + InV.z * InM.m[2][0] + InM.m[3][0] ;
戻り値.y = InV.x * InM.m[0][1] + InV.y * InM.m[1][1] + InV.z * InM.m[2][1] + InM.m[3][1] ;
戻り値.z = InV.x * InM.m[0][2] + InV.y * InM.m[1][2] + InV.z * InM.m[2][2] + InM.m[3][2] ;

サンプル

　　VECTOR 構造体 Vect をスケーリング行列を使用して 0.5f 倍します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;
	MATRIX Matrix ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;

	// 0.5倍スケーリングを行う行列を作成
	Matrix = MGetScale( VGet( 0.5f, 0.5f, 0.5f ) ) ;

	// 0.5倍スケーリングを行う行列を使用してベクトルのサイズを0.5倍した結果を Vect に代入する
	Vect = VTransform( Vect, Matrix ) ;

	// Vect の値を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR VTransformSR( VECTOR InV, MATRIX InM ) ;

概略 行列を使ったベクトルの変換( スケーリング＋回転成分のみ )

引数   VECTOR InV ： 変換処理を行いたいベクトル
MATRIX InM ： 変換処理に使用するベクトル
戻り値 変換後のベクトル
解説  　引数 InV のベクトルを引数 InM の行列を使用して変換処理を行います。
　計算的には InV を１ｘ４行列として扱い( 4つめの要素は 0.0f とします ) InM の行列の左から乗算した結果を返します。
　VTransform と違い InV を行列として見立てた際の第４要素が 0.0f なので MGetTranslate 等の第４要素の 1.0f と乗算することで平行移動を実現している効果が反映されません。


戻り値.x = InV.x * InM.m[0][0] + InV.y * InM.m[1][0] + InV.z * InM.m[2][0] ;
戻り値.y = InV.x * InM.m[0][1] + InV.y * InM.m[1][1] + InV.z * InM.m[2][1] ;
戻り値.z = InV.x * InM.m[0][2] + InV.y * InM.m[1][2] + InV.z * InM.m[2][2] ;

サンプル

　　VECTOR 構造体 Vect をスケーリング行列を使用して 0.5f 倍します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	VECTOR Vect ;
	MATRIX Matrix ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 200.0f, 500.0f ) ;

	// 0.5倍スケーリングを行う行列を作成
	Matrix = MGetScale( VGet( 0.5f, 0.5f, 0.5f ) ) ;

	// 0.5倍スケーリングを行う行列を使用してベクトルのサイズを0.5倍した結果を Vect に代入する
	Vect = VTransformSR( Vect, Matrix ) ;

	// Vect の値を画面に表示
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetIdent( void ) ;

概略 単位行列を取得する

引数   なし
戻り値 単位行列
解説  　単位行列を戻り値として返してくる関数です。


戻り値行列
m[0][0]=1.0f m[0][1]=0.0f m[0][2]=0.0f m[0][3]=0.0f
m[1][0]=0.0f m[1][1]=1.0f m[1][2]=0.0f m[1][3]=0.0f
m[2][0]=0.0f m[2][1]=0.0f m[2][2]=1.0f m[2][3]=0.0f
m[3][0]=0.0f m[3][1]=0.0f m[3][2]=0.0f m[3][3]=1.0f

サンプル

　　単位行列を取得して画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() DrawFormatString( 0,  0, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetScale( VECTOR Scale ) ;

概略 拡大行列を取得する

引数   VECTOR Scale ： 拡大値
戻り値 拡大行列
解説  　引数 Scale で指定された拡大値で拡大する行列を戻り値として返してくる関数です。
　拡大行列は VTransform 関数でベクトルに対して変換を行うと、 変換対象のベクトルがこの関数の引数 Scale で指定した分だけ拡大します。


戻り値行列
m[0][0]=Scale.x m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=Scale.z m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=Scale.z m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f

サンプル

　　拡大行列を取得してベクトルの拡大変換を行います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 8.0f, 56.0f ) ;

	// 拡大行列を Matrix に代入
	Matrix = MGetScale( VGet( 2.0f, 5.0f, 8.0f ) ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "拡大行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetTranslate( VECTOR Trans ) ;

概略 平行移動行列を取得する

引数   VECTOR Trans ： 平行移動値
戻り値 平行移動行列
解説  　引数 Trans で指定された平行移動を行う行列を戻り値として返してくる関数です。
　平行移動行列は VTransform 関数でベクトルに対して変換を行うと、 変換対象のベクトルがこの関数の引数 Trans で指定した分だけ移動し( 値が加算され )ます。


戻り値行列
m[0][0]=1.0f    m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=1.0f    m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=1.0f    m[2][3]=0.0f
m[3][0]=Trans.x m[3][1]=Trans.y m[3][2]=Trans.z m[3][3]=1.0f

サンプル

　　平行移動行列を使用してベクトルの平行移動変換を行います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 8.0f, 56.0f ) ;

	// 平行移動行列を Matrix に代入
	Matrix = MGetTranslate( VGet( 100.0f, 80.0f, 85.0f ) ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "平行移動行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetRotX( float XAxisRotate ) ;

概略 Ｘ軸回転行列を取得する

引数   float XAxisRotate ： 回転値( 単位：ラジアン )
戻り値 Ｘ軸回転行列
解説  　引数 XAxisRotate で指定された回転値分だけＸ軸回転する回転行列を戻り値として返してくる関数です。
　Ｘ軸回転行列は VTransform 関数でベクトルに対して変換を行うと、 変換対象のベクトルがこの関数の引数 XAxisRotate で指定した分だけＸ軸回転します。


戻り値行列
float Sin, Cos ;
Sin = sin( XAxisRotate ) ;
Cos = cos( XAxisRotate ) ;
m[0][0]=1.0f    m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]= Cos    m[1][2]=Sin     m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=-Sin    m[2][2]=Cos     m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f

サンプル

　　Ｘ軸回転行列を使用してベクトルのＸ軸回転を行います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 8.0f, 56.0f ) ;

	// Ｘ軸回転行列を Matrix に代入( 45度回転する行列 )
	Matrix = MGetRotX( PHI_F / 4.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "Ｘ軸回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetRotY( float YAxisRotate ) ;

概略 Ｙ軸回転行列を取得する

引数   float YAxisRotate ： 回転値( 単位：ラジアン )
戻り値 Ｙ軸回転行列
解説  　引数 YAxisRotate で指定された回転値分だけＹ軸回転する回転行列を戻り値として返してくる関数です。
　Ｙ軸回転行列は VTransform 関数でベクトルに対して変換を行うと、 変換対象のベクトルがこの関数の引数 YAxisRotate で指定した分だけＹ軸回転します。


戻り値行列
float Sin, Cos ;
Sin = sin( YAxisRotate ) ;
Cos = cos( YAxisRotate ) ;
m[0][0]=Cos     m[0][1]=0.0f    m[0][2]=-Sin    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=1.0f    m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=Sin     m[2][1]=0.0f    m[2][2]= Cos    m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f

サンプル

　　Ｙ軸回転行列を使用してベクトルのＹ軸回転を行います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 8.0f, 56.0f ) ;

	// Ｙ軸回転行列を Matrix に代入( 45度回転する行列 )
	Matrix = MGetRotY( PHI_F / 4.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "Ｙ軸回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetRotZ( float ZAxisRotate ) ;

概略 Ｚ軸回転行列を取得する

引数   float ZAxisRotate ： 回転値( 単位：ラジアン )
戻り値 Ｚ軸回転行列
解説  　引数 ZAxisRotate で指定された回転値分だけＺ軸回転する回転行列を戻り値として返してくる関数です。
　Ｚ軸回転行列は VTransform 関数でベクトルに対して変換を行うと、 変換対象のベクトルがこの関数の引数 ZAxisRotate で指定した分だけＺ軸回転します。


戻り値行列
float Sin, Cos ;
Sin = sin( ZAxisRotate ) ;
Cos = cos( ZAxisRotate ) ;
m[0][0]= Cos    m[0][1]=Sin     m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=-Sin    m[1][1]=Cos     m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=1.0f    m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f

サンプル

　　Ｚ軸回転行列を使用してベクトルのＺ軸回転を行います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 8.0f, 56.0f ) ;

	// Ｚ軸回転行列を Matrix に代入( 45度回転する行列 )
	Matrix = MGetRotZ( PHI_F / 4.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "Ｚ軸回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetRotAxis( VECTOR RotateAxis, float Rotate ) ;

概略 指定軸で指定角度回転する行列を取得する

引数   VECTOR RotateAxis ： 回転軸 float Rotate ： 回転値( 単位：ラジアン )
戻り値 回転行列
解説  　引数 RotateAxis を回転軸として、引数 Rotate で指定された回転値分だけ回転する回転行列を戻り値として返してくる関数です。
　MGetRotY や MGetRotX はそれぞれ回転軸を Ｙ軸、Ｘ軸としていますが、 時には基本軸以外を軸として回転したい場合があります、この関数はそんなときに使用します。

サンプル

　　MGetRotAxis 関数を使用して敢えてＹ軸回転行列を作成します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 100.0f, 8.0f, 56.0f ) ;

	// MGetRotAxis を使用して敢えてＹ軸回転行列を Matrix に代入( 45度回転する行列 )
	Matrix = MGetRotAxis( VGet( 0.0f, 1.0f, 0.0f ), PHI_F / 4.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "Ｙ軸回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetRotVec2( VECTOR In1, VECTOR In2 ) ;

概略 ある向きからある向きへ変換する回転行列を取得する

引数   VECTOR In1 ： ある向きのベクトル VECTOR In2 ： ある向きを変換後のベクトル
戻り値 回転行列
解説  　引数 In1 の向きを引数 In2 の向きに変換するような回転行列を戻り値として返してくる関数です。
　ただ、元の向きから９０度以上回転する場合は期待した回転行列が得られない可能性があります。

サンプル

　　Ｘ軸のプラスの方向をＹ軸のマイナスの方向に回転する行列を取得する。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet( 1.0f, 0.0f, 0.0f ), VGet( 0.0f, -1.0f, 0.0f ) ) ;

	// Ｘ軸に対してプラスの値を Vect1 に代入
	Vect1 = VGet( 80.0f, 0.0f, 0.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetAxis1( VECTOR XAxis, VECTOR YAxis, VECTOR ZAxis, VECTOR Pos ) ;

概略 指定の３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する

引数   VECTOR XAxis ： 任意のＸ軸の基本軸上での方向
VECTOR YAxis ： 任意のＹ軸の基本軸上での方向
VECTOR ZAxis ： 任意のＺ軸の基本軸上での方向
VECTOR Pos ： 任意の３軸の基本軸上での原点
戻り値 変換行列
解説  　任意の３軸上のＸＹＺ値を基本軸上のＸＹＺ値に変換する行列を作成します。


戻り値行列
m[0][0]=XAxis.x m[0][1]=XAxis.y m[0][2]=XAxis.z m[0][3]=0.0f
m[1][0]=YAxis.x m[1][1]=YAxis.y m[1][2]=YAxis.z m[1][3]=0.0f
m[2][0]=ZAxis.x m[2][1]=ZAxis.y m[2][2]=ZAxis.z m[2][3]=0.0f
m[3][0]=Pos.x   m[3][1]=Pos.y   m[3][2]=Pos.z   m[3][3]=1.0f

サンプル

　　基本軸上のＹのプラス値をＸ軸
　　基本軸上のＺのプラス値をＹ軸
　　基本軸上のＸのマイナス値をＺ軸とし、
　　且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする
　　３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet(  0.0f, 1.0f, 0.0f ),
				VGet(  0.0f, 0.0f, 1.0f ),
				VGet( -1.0f, 0.0f, 0.0f ),
				VGet( 100.0f, 0.0f, 200.0f ) ) ;

	// 上記軸上のＸ軸とＹ軸に対してプラスのベクトル Vect1 に代入
	Vect1 = VGet( 80.0f, 50.0f, 0.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "変換行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MGetAxis2( VECTOR XAxis, VECTOR YAxis, VECTOR ZAxis, VECTOR Pos ) ;

概略 基本軸上のベクトルを指定の３軸上のベクトルに変換する行列を取得する

引数   VECTOR XAxis ： 任意のＸ軸の基本軸上での方向
VECTOR YAxis ： 任意のＹ軸の基本軸上での方向
VECTOR ZAxis ： 任意のＺ軸の基本軸上での方向
VECTOR Pos ： 任意の３軸の基本軸上での原点
戻り値 変換行列
解説  　基本軸上のＸＹＺ値を任意の３軸上のＸＹＺ値に変換する行列を作成します。


戻り値行列
m[0][0]=XAxis.x m[0][1]=YAxis.x m[0][2]=ZAxis.x m[0][3]=0.0f
m[1][0]=XAxis.y m[1][1]=YAxis.y m[1][2]=ZAxis.y m[1][3]=0.0f
m[2][0]=XAxis.z m[2][1]=YAxis.z m[2][2]=ZAxis.z m[2][3]=0.0f
m[3][0]=-( Pos.x * XAxis.x + Pos.y * XAxis.y + Pos.z * XAxis.z )
m[3][1]=-( Pos.x * YAxis.x + Pos.y * YAxis.y + Pos.z * YAxis.z )
m[3][2]=-( Pos.x * ZAxis.x + Pos.y * ZAxis.y + Pos.z * ZAxis.z )
m[3][3]=1.0f

サンプル

　　基本軸上のベクトルを
　　基本軸上のＹのプラス値をＸ軸
　　基本軸上のＺのプラス値をＹ軸
　　基本軸上のＸのマイナス値をＺ軸とし、
　　且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする
　　３軸上のベクトルに変換する行列を取得する
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() VGet(  0.0f, 1.0f, 0.0f ),
				VGet(  0.0f, 0.0f, 1.0f ),
				VGet( -1.0f, 0.0f, 0.0f ),
				VGet( 100.0f, 0.0f, 200.0f ) ) ;

	// 任意の３軸上の原点に位置する基本軸上のベクトルを Vect に代入
	Vect1 = VGet( 100.0f, 0.0f, 200.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 0, "変換行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MAdd( MATRIX In1, MATRIX In2 ) ;

概略 二つの行列の足し算を行う

引数   MATRIX In1 ： 足し算を行う行列１
MATRIX In2 ： 足し算を行う行列２
戻り値 足し算を行った結果の行列
解説  　引数 In1 と In2 で渡した行列の足し算を行い、 結果の行列を戻り値として返す関数です。
　行列の足し算は行列の要素を単純に足すだけのものです。


戻り値行列
m[0][0] = In1.m[0][0] + In2.m[0][0]
m[0][1] = In1.m[0][1] + In2.m[0][1]
m[0][2] = In1.m[0][2] + In2.m[0][2]
m[0][3] = In1.m[0][3] + In2.m[0][3]

m[1][0] = In1.m[1][0] + In2.m[1][0]
m[1][1] = In1.m[1][1] + In2.m[1][1]
m[1][2] = In1.m[1][2] + In2.m[1][2]
m[1][3] = In1.m[1][3] + In2.m[1][3]

m[2][0] = In1.m[2][0] + In2.m[2][0]
m[2][1] = In1.m[2][1] + In2.m[2][1]
m[2][2] = In1.m[2][2] + In2.m[2][2]
m[2][3] = In1.m[2][3] + In2.m[2][3]

m[3][0] = In1.m[3][0] + In2.m[3][0]
m[3][1] = In1.m[3][1] + In2.m[3][1]
m[3][2] = In1.m[3][2] + In2.m[3][2]
m[3][3] = In1.m[3][3] + In2.m[3][3]

サンプル

　　ベクトルを０．８倍する行列と０．２倍する行列を足して、その行列を使用して
　ベクトルを変換します、０．８倍と０．２倍を足すと１．０倍なので、ベクトルは
　変換前と同じ値になります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix, Matrix1, Matrix2 ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MGetScale( VGet( 0.8f, 0.8f, 0.8f ) ) ;
	Matrix2 = MGetScale( VGet( 0.2f, 0.2f, 0.2f ) ) ;

	// 二つの行列を足したものを Matrix に代入
	Matrix = MAdd( Matrix1, Matrix2 ) ;

	// 適当な値を Vect1 に代入
	Vect1 = VGet( 100.0f, 0.0f, 200.0f ) ;

	// Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix1 の値を画面に表示
	DrawString( 0, 0, "０．８倍行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

	// Matrix2 の値を画面に表示
	DrawString( 0, 96, "０．２倍行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

	DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

	DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 192, "加算後の行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MMult( MATRIX In1, MATRIX In2 ) ;

概略 二つの行列の乗算を行う

引数   MATRIX In1 ： 乗算する左側の行列
MATRIX In2 ： 乗算する右側の行列
戻り値 乗算した結果の行列
解説  　引数 In1 と In2 を乗算した行列を結果の行列を戻り値として返す関数です。
　行列と行列の乗算は複数の行列の効果を合成することができます。 ( 合成された行列は In1 → In2 の順で効果が現れます( 例：拡大行列と平行移動行列と乗算した場合、 その行列を使用して変換( VTransform )したベクトルは拡大行列→平行移動行列の順で変換( VTransform )した場合と同じ結果になります ) )


戻り値行列
m[0][0] = In1.m[0][0] * In2.m[0][0] + In1.m[0][1] * In2.m[1][0] +
          In1.m[0][2] * In2.m[2][0] + In1.m[0][3] * In2.m[3][0] ;
m[0][1] = In1.m[0][0] * In2.m[0][1] + In1.m[0][1] * In2.m[1][1] +
          In1.m[0][2] * In2.m[2][1] + In1.m[0][3] * In2.m[3][1] ;
m[0][2] = In1.m[0][0] * In2.m[0][2] + In1.m[0][1] * In2.m[1][2] +
          In1.m[0][2] * In2.m[2][2] + In1.m[0][3] * In2.m[3][2] ;
m[0][3] = In1.m[0][0] * In2.m[0][3] + In1.m[0][1] * In2.m[1][3] +
          In1.m[0][2] * In2.m[2][3] + In1.m[0][3] * In2.m[3][3] ;

m[1][0] = In1.m[1][0] * In2.m[0][0] + In1.m[1][1] * In2.m[1][0] +
          In1.m[1][2] * In2.m[2][0] + In1.m[1][3] * In2.m[3][0] ;
m[1][1] = In1.m[1][0] * In2.m[0][1] + In1.m[1][1] * In2.m[1][1] +
          In1.m[1][2] * In2.m[2][1] + In1.m[1][3] * In2.m[3][1] ;
m[1][2] = In1.m[1][0] * In2.m[0][2] + In1.m[1][1] * In2.m[1][2] +
          In1.m[1][2] * In2.m[2][2] + In1.m[1][3] * In2.m[3][2] ;
m[1][3] = In1.m[1][0] * In2.m[0][3] + In1.m[1][1] * In2.m[1][3] +
          In1.m[1][2] * In2.m[2][3] + In1.m[1][3] * In2.m[3][3] ;

m[2][0] = In1.m[2][0] * In2.m[0][0] + In1.m[2][1] * In2.m[1][0] +
          In1.m[2][2] * In2.m[2][0] + In1.m[2][3] * In2.m[3][0] ;
m[2][1] = In1.m[2][0] * In2.m[0][1] + In1.m[2][1] * In2.m[1][1] +
          In1.m[2][2] * In2.m[2][1] + In1.m[2][3] * In2.m[3][1] ;
m[2][2] = In1.m[2][0] * In2.m[0][2] + In1.m[2][1] * In2.m[1][2] +
          In1.m[2][2] * In2.m[2][2] + In1.m[2][3] * In2.m[3][2] ;
m[2][3] = In1.m[2][0] * In2.m[0][3] + In1.m[2][1] * In2.m[1][3] +
          In1.m[2][2] * In2.m[2][3] + In1.m[2][3] * In2.m[3][3] ;

m[3][0] = In1.m[3][0] * In2.m[0][0] + In1.m[3][1] * In2.m[1][0] +
          In1.m[3][2] * In2.m[2][0] + In1.m[3][3] * In2.m[3][0] ;
m[3][1] = In1.m[3][0] * In2.m[0][1] + In1.m[3][1] * In2.m[1][1] +
          In1.m[3][2] * In2.m[2][1] + In1.m[3][3] * In2.m[3][1] ;
m[3][2] = In1.m[3][0] * In2.m[0][2] + In1.m[3][1] * In2.m[1][2] +
          In1.m[3][2] * In2.m[2][2] + In1.m[3][3] * In2.m[3][2] ;
m[3][3] = In1.m[3][0] * In2.m[0][3] + In1.m[3][1] * In2.m[1][3] +
          In1.m[3][2] * In2.m[2][3] + In1.m[3][3] * In2.m[3][3] ;

サンプル

　　ベクトルをＹ軸回転９０度する行列とＹ軸回転－９０度する２倍に拡大する行列を乗算して
　ベクトルに対してＹ軸回転行列→２倍拡大行列の順で VTransform を使用した場合と同じ効果がある行列を作成します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix, Matrix1, Matrix2 ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MGetRotY(  PHI_F / 2.0f ) ;
	Matrix2 = MGetRotY( -PHI_F / 2.0f ) ;

	// 二つの行列を０．５倍して加算したものを Matrix に代入
	Matrix = MAdd( MScale( Matrix1, 0.5f ), MScale( Matrix2, 0.5f ) ) ;

	// 適当な値を Vect1 に代入
	Vect1 = VGet( 200.0f, 0.0f, 0.0f ) ;

	// Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix1 の値を画面に表示
	DrawString( 0, 0, "Ｙ軸９０度回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

	// Matrix2 の値を画面に表示
	DrawString( 0, 96, "Ｙ軸－９０度回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

	DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

	DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 192, "乗算後の行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MScale( MATRIX InM, float Scale ) ;

概略 行列のスケーリングを行う

引数   MATRIX InM ： スケーリングする行列
float Scale ： スケーリング値
戻り値 スケーリングした結果の行列
解説  　引数 InM で渡された行列の各要素に Scale を乗算した行列を戻り値として返す関数です。


戻り値行列
m[0][0] = InM.m[0][0] * Scale ;
m[0][1] = InM.m[0][1] * Scale ;
m[0][2] = InM.m[0][2] * Scale ;
m[0][3] = InM.m[0][3] * Scale ;

m[1][0] = InM.m[1][0] * Scale ;
m[1][1] = InM.m[1][1] * Scale ;
m[1][2] = InM.m[1][2] * Scale ;
m[1][3] = InM.m[1][3] * Scale ;

m[2][0] = InM.m[2][0] * Scale ;
m[2][1] = InM.m[2][1] * Scale ;
m[2][2] = InM.m[2][2] * Scale ;
m[2][3] = InM.m[2][3] * Scale ;

m[3][0] = InM.m[3][0] * Scale ;
m[3][1] = InM.m[3][1] * Scale ;
m[3][2] = InM.m[3][2] * Scale ;
m[3][3] = InM.m[3][3] * Scale ;

サンプル

　　ベクトルをＹ軸回転９０度する行列とＸ軸回転９０度する行列をそれぞれ０．５倍して
　加算したものを作ります。
　　この行列はＹ軸回転９０度する行列を使用して VTransform したベクトルと
　Ｘ軸回転９０度する行列を使用して VTransform したベクトルをそれぞれ０．５倍して
　加算したものと同じ結果が出力される行列となります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix, Matrix1, Matrix2 ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MGetRotY( PHI_F / 2.0f ) ;
	Matrix2 = MGetRotX( PHI_F / 2.0f ) ;

	// 二つの行列を０．５倍して加算したものを Matrix に代入
	Matrix = MAdd( MScale( Matrix1, 0.5f ), MScale( Matrix2, 0.5f ) ) ;

	// 適当な値を Vect1 に代入
	Vect1 = VGet( 200.0f, 0.0f, 0.0f ) ;

	// Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix1 の値を画面に表示
	DrawString( 0, 0, "Ｙ軸９０度回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

	// Matrix2 の値を画面に表示
	DrawString( 0, 96, "Ｘ軸９０度回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

	DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

	DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

	DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 192, "乗算後の行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MTranspose( MATRIX InM ) ;

概略 転置行列を取得する

引数   MATRIX InM ： 転置する行列
戻り値 転置した結果の行列
解説  　引数 InM で渡された行列を転置したものを戻り値として返す関数です。
　転置行列とは行列要素の行と列を逆転したものです。
　転置する行列が回転行列の場合は逆回転する行列となります。


戻り値行列
m[0][0] = InM.m[0][0] ;
m[0][1] = InM.m[1][0] ;
m[0][2] = InM.m[2][0] ;
m[0][3] = InM.m[3][0] ;

m[1][0] = InM.m[0][1] ;
m[1][1] = InM.m[1][1] ;
m[1][2] = InM.m[2][1] ;
m[1][3] = InM.m[3][1] ;

m[2][0] = InM.m[0][2] ;
m[2][1] = InM.m[1][2] ;
m[2][2] = InM.m[2][2] ;
m[2][3] = InM.m[3][2] ;

m[3][0] = InM.m[0][3] ;
m[3][1] = InM.m[1][3] ;
m[3][2] = InM.m[2][3] ;
m[3][3] = InM.m[3][3] ;

サンプル

　　ベクトルをＹ軸回転９０度する行列を転置した行列を使用してベクトルを回転します。
　　回転行列を転置した行列は逆回転( Ｙ軸回転－９０度 )する行列となります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix, Matrix2 ;
	VECTOR Vect1, Vect2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MGetRotY( PHI_F / 2.0f ) ;

	// Matrix2 を転置した行列を Matrix に代入
	Matrix = MTranspose( Matrix2 ) ;

	// 適当な値を Vect1 に代入
	Vect1 = VGet( 200.0f, 0.0f, 0.0f ) ;

	// Vect1 を Matrix を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix ) ;

	// Matrix2 の値を画面に表示
	DrawString( 0, 0, "Ｙ軸９０度回転行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 192, "転置行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MInverse( MATRIX InM ) ;

概略 逆行列を取得する

引数   MATRIX InM ： 逆行列を求める行列
戻り値 InM の逆行列
解説  　引数 InM で渡された行列の逆行列を戻り値として返す関数です。
　行列は左から乗算する場合と右から乗算する場合で結果が変化するのですが、 逆行列は元の行列で左から乗算する場合と同じ結果が右から乗算した場合に出る行列です。

サンプル

　　平行移動する行列とその逆行列を用意して、適当な値を持ったベクトルが
　平行移動行列→その逆行列　の順で VTransform すれば元の値に戻るかを試します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	MATRIX Matrix, Matrix2 ;
	VECTOR Vect1, Vect2, Vect3 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MGetTranslate( VGet( 200.0f, 100.0f, 80.0f ) ) ;

	// Matrix2 の逆行列を Matrix に代入
	Matrix = MInverse( Matrix2 ) ;

	// 適当な値を Vect1 に代入
	Vect1 = VGet( 200.0f, 0.0f, 0.0f ) ;

	// Vect1 を Matrix2 を使用して変換した値を Vect2 に代入
	Vect2 = VTransform( Vect1, Matrix2 ) ;

	// Vect2 を Matrix2 の逆行列である Matrix で変換したものを Vect3 に代入
	Vect3 = VTransform( Vect2, Matrix ) ;

	// Matrix2 の値を画面に表示
	DrawString( 0, 0, "平行移動行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

	DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

	DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

	DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

	// Matrix の値を画面に表示
	DrawString( 0, 192, "逆行列", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
		Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

	DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
		Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

	DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
		Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

	DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
		Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

	// 変換元のベクトル値 Vect1 を画面に表示
	DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

	// 変換後のベクトル値 Vect2 を画面に表示
	DrawString( 0, 336, "平行移動後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

	// 変換後のベクトル値 Vect3 を画面に表示
	DrawString( 0, 384, "逆行列乗算後のベクトル", GetColor( 255,255,255 ) ) ;
	DrawFormatString( 0, 400, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect3.x, Vect3.y, Vect3.z ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


衝突検出系関数

宣言 float Segment_Segment_MinLength( VECTOR SegmentAPos1, VECTOR SegmentAPos2, VECTOR SegmentBPos1, VECTOR SegmentBPos2 ) ;

概略 二つの線分の最近点間の距離を得る

引数   VECTOR SegmentAPos1 ： 二線分の片方の始点
VECTOR SegmentAPos2 ： 二線分の片方の終点
VECTOR SegmentBPos1 ： 二線分のもう片方の始点
VECTOR SegmentBPos2 ： 二線分のもう片方の終点
戻り値 二線分の最近点間の距離
解説  　引数で渡された二つの線分が最も近づく点( 最近点 )同士の距離を得ます。

サンプル

　　線分を二つ定義して、片方の線分の終点を左右動かし、二線分の最近点間の距離が 64 以下になった際に
　線分の色を赤色にします。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	float xadd, length ;
	VECTOR LineA1, LineA2, LineB1, LineB2 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init()  640.0f )
			xadd = -xadd ;

		// 二線分の最近点どうしの距離を求める
		length = Segment_Segment_MinLength( LineA1, LineA2, LineB1, LineB2 ) ;

		// 片方の線分の描画
		DrawLine( LineB1.x, LineB1.y, LineB2.x, LineB2.y, GetColor( 255,255,255 ) ) ;

		// もう一つの線分を距離が 64 以下だったら色を変えて描画
		if( length 
			
-------------------------------------------------------------------------------

			


		



		

			
宣言 float Segment_Triangle_MinLength( VECTOR SegmentPos1, VECTOR SegmentPos2, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;


			
概略 線分と三角形の最近点間の距離を得る


			
引数
			 
			VECTOR SegmentPos1 ： 線分の始点

			VECTOR SegmentPos2 ： 線分の終点

			VECTOR TrianglePos1 ： 三角形を形成する頂点１

			VECTOR TrianglePos2 ： 三角形を形成する頂点２

			VECTOR TrianglePos3 ： 三角形を形成する頂点３
			

			
			
戻り値 線分と三角形の最近点間の距離
			

				 解説
				 　引数で渡された線分と三角形が最も近づく点( 最近点 )同士の距離を得ます。


				
			
		

		

		

			サンプル


			　　線分と三角形の座標を定義して、線分の終点を左右動かし、線分と三角形の最近点間の距離が 64 以下になった際に

			　三角形の色を赤色にします。
			
-------------------------------------------------------------------------------



#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	float xadd, length ;
	VECTOR Line1, Line2, Tri1, Tri2, Tri3 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init()  640.0f )
			xadd = -xadd ;

		// 線分と三角形の最近点間の距離を求める
		length = Segment_Triangle_MinLength( Line1, Line2, Tri1, Tri2, Tri3 ) ;

		// 線分の描画
		DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 255,255,255 ) ) ;

		// 三角形との距離が 64 以下だったら色を変えて描画
		if( length 
			
-------------------------------------------------------------------------------

			


		




		

			
宣言 float Segment_Point_MinLength( VECTOR SegmentPos1, VECTOR SegmentPos2, VECTOR PointPos ) ;


			
概略 線分と点の一番近い距離を得る


			
引数
			 
			VECTOR SegmentPos1 ： 線分の始点

			VECTOR SegmentPos2 ： 線分の終点

			VECTOR PointPos ： 点の座標
			

			
			
戻り値 線分と点が最も近づく座標間の距離
			

				 解説
				 　引数で渡された線分と点が最も近づく座標間の距離を得ます。


				
			
		

		

		

			サンプル


			　　線分と点の座標を定義して、点の座標を上下に動かし、線分と点の最近点間の距離が 64 以下になった際に

			　線分の色を赤色にします。
			
-------------------------------------------------------------------------------



#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	float yadd, length ;
	VECTOR Line1, Line2, Point ;

	// ＤＸライブラリの初期化
	if( DxLib_Init()  480.0f )
			yadd = -yadd ;

		// 線分と点が最も近づく座標間の距離を求める
		length = Segment_Point_MinLength( Line1, Line2, Point ) ;

		// 点の描画
		DrawPixel( Point.x, Point.y, GetColor( 255,255,255 ) ) ;

		// 点との距離が 64 以下だったら色を変えて描画
		if( length 
			
-------------------------------------------------------------------------------

			


		



		

			
宣言 HITRESULT_LINE HitCheck_Line_Triangle( VECTOR LinePos1, VECTOR LinePos2, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;


			
概略 三角形と線分の当たり判定


			
引数
			 
			VECTOR LinePos1 ： 線分の始点

			VECTOR LinePos2 ： 線分の終点

			VECTOR TrianglePos1 ： 三角形を形成する頂点１

			VECTOR TrianglePos2 ： 三角形を形成する頂点２

			VECTOR TrianglePos3 ： 三角形を形成する頂点３
			
			
戻り値 衝突情報構造体 HITRESULT_LINE
			

				 解説
				 　引数で渡された線分と三角形が接触しているかどうかを判定して、
					その結果を衝突情報構造体 HITRESULT_LINE で返してきます。



					HITRESULT_LINE 構造体は非常に単純な構造体でメンバ変数は以下の二つだけです。

					


					// 接触しているかどうか( 1:接触している  0:接触していない )
					int		HitFlag ;

					// 接触した座標( HitFlag が 1 の場合のみ有効 )
					VECTOR	Position ;
					

サンプル

　　線分と三角形の座標を定義して、線分の終点を上下に動かしながら線分と三角形の当たり判定を行い
　三角形と接触した場合は線分の始点と接触点とを結ぶ線を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	float yadd ;
	HITRESULT_LINE Result ;
	VECTOR Line1, Line2, Tri1, Tri2, Tri3 ;

	// ＤＸライブラリの初期化
	if( DxLib_Init()  480.0f )
			yadd = -yadd ;

		// 線分と点が最も近づく座標間の距離を求める
		Result = HitCheck_Line_Triangle( Line1, Line2, Tri1, Tri2, Tri3 ) ;

		// 三角形を真横から見たときにできる線を描画
		DrawLine( Tri1.x, Tri1.y, Tri2.x, Tri2.y, GetColor( 255,255,255 ) ) ;

		// 三角形と接触していたら始点と接触点を結ぶ線を
		// そうでない場合は始点と終点を結ぶ線を描画する
		if( Result.HitFlag == 1 )
		{
			DrawLine( Line1.x, Line1.y, Result.Position.x, Result.Position.y, GetColor( 255,0,0 ) ) ;
		}
		else
		{
			DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 0,255,0 ) ) ;
		}

		// 裏画面の内容を表画面に反映させる
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


モデルの読み込み・複製関係の関数

宣言 int MV1LoadModel( char *FileName ) ;

概略 モデルの読み込み

引数   FileName ：　ロードする３Ｄモデルファイルのパス文字列のアドレス
戻り値  －１　　　　：　エラー発生
－１以外　：　モデルのハンドル

解説  　３Ｄモデルファイルをメモリにロードします。
ＤＸライブラリで３Ｄモデルを扱うときに必ず使用する関数です。
　この関数が成功するとモデルハンドルというものが返ってきます。
これはメモリに読み込んだ３Ｄモデルファイルの識別番号で int 型の数値です。
　読み込んだモデルを扱う際にこの識別番号を使用することになりますので、 MV1LoadModel の戻り値は必ずなんらかの変数に格納しておく必要があります。

例　　DxChara.x をロードして、戻り値であるモデルハンドルを
　　int 型変数 MHandle に保存します



	int MHandle ;

	MHandle = MV1LoadModel( "DxChara.x" ) ;


読み込むことのできるモデルファイル形式は x, mqo, mv1, pmd( + vmd ) の３種類です。

　尚、形状情報とアニメーション(アニメーション)情報はファイルの内容通りに読み込めますが、 マテリアル情報は各ファイル形式それぞれで異なる表現をしているものを無理矢理ＤＸライブラリのマテリアル表現で扱おうとするため、 大抵の場合モデリングソフト上とは異なった見た目になってしまいます。
　なので、そのような場合はＤＸライブラリに合わせてモデルファイルのマテリアルを調整していただくか、 ＤＸライブラリの３Ｄツールでマテリアルを調整してからライブラリの専用形式である mv1 形式で保存して、そのファイルを使っていただくことになります。
　また、モデルファイルで使用されているテクスチャはモデルファイルの中には含まれませんので、 モデルファイルで指定されているフォルダにテクスチャファイルを格納しておく必要があります。


MMD( MikuMikuDance )のモデルファイル( pmd )とモーションファイル( vmd )について。

＜対応度について＞

　一応モーションの再生と取れに伴うＩＫ、物理演算に対応していますが、完全に本家 MikuMikuDance と同じというわけではありません。


＜読み込みについて＞

　MikuMikuDance ではトゥーン用のテクスチャ( toon01.bmp 等 )はモデルファイル( pmd )が存在するテクスチャとは別のフォルダにあっても問題なく読み込むことが出来ますが、 ＤＸライブラリではトゥーン用のテクスチャもモデルファイル( pmd )と同じフォルダに格納しておく必要があります。

　また、ＤＸライブラリでは MMD のモデルファイル形式( pmd )とモーションファイル形式( vmd )の読み込みに対応していますが、 モーションファイル( vmd )はモデルファイル( pmd )を読み込む際に一緒に読み込まれるようになっています。
　ただ、MV1LoadModel にはモーションファイルのファイル名を渡す引数はありませんので、 次のようなルールでモデルファイル( pmd )用のモーションファイルを検索します。

　１．モデルファイル名に３桁の番号がついたモーションファイルがあるか検索して、あったら読み込む
　　　( 検索する番号は 000 から )

　　　　　例えば、Miku.pmd というファイル名を FileName として渡した場合は、最初に Miku000.vmd という
　　　　　モーションファイルが存在するか調べます。

　２．検索する番号を000から順に１づつ増やしていき、存在しないファイル名になるまで読み込む

　　　　　例えば、Miku000.vmd、Miku001.vmd、Miku002.vmd と数字の繋がった３つのモーションファイルが
　　　　　あった場合は３つとも読み込まれます。
　　　　　仮に Miku000.vmd, Miku001.vmd, Miku005.vmd のように、番号が途切れていたら、Miku000.vmd と
　　　　　Miku001.vmd の二つだけ読み込まれ、Miku005.vmd は読み込まれません。

　尚、読み込み時にＩＫ計算を行いますので、xファイルやmv1ファイルに比べて読み込み時間が非常に長くなっています。


＜ループ再生するモーションについて＞

　モーションの中には歩きや走りといったループさせて再生を行う用途のモーションがあると思います。

　そのようなモーションの vmd ファイルは、＜読み込みについて＞の解説にあったファイル名の付け方にある３桁のモーションの番号の最後に半角の L をつけてください。

例：Miku000.vmd ～ Miku002.vmd の３つのファイルがあり、Miku000.vmd と Miku002.vmd が
　　ループ再生用途のモーションの場合

　Miku000.vmd　Miku001.vmd　Miku002.vmd

　　　　　　　　　↓

　Miku000L.vmd　Miku001.vmd　Miku002L.vmd


　L を付けることで関数 MV1SetLoadModelUsePhysicsMode の設定が「読み込み時に物理演算を行う」 DX_LOADMODEL_PHYSICS_LOADCALC となっている場合( デフォルトの設定は DX_LOADMODEL_PHYSICS_LOADCALC です )の物理演算がループ再生用途のモーション用にモーションの最初と最後のフレームが綺麗に繋がり自然なループ再生ができるように処理されます。
　逆にループ用途のモーションではないのに L を付けてしまうとモーションの最後の部分が変になってしまうので注意してください。
　また、L を付けても物理演算によって動く部分の動きが激しいときはやっぱりループ時に不自然な見え方になってしまいますので、 その際はリアルタイム物理演算の設定である DX_LOADMODEL_PHYSICS_REALTIME をお使いください。


＜モーションの再生について＞

　モーションの再生は他の形式と同じように MV1AttachAnim を使用します( AnimIndex は vmd についている番号を指定します )
　フレーム構造の違う他のモデルのモーションを使用する場合は MV1AttachAnim の NameCheck を TRUE にしてください。

サンプル

　　モデルファイル DxChara.x を読み込んで画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1DuplicateModel( int SrcMHandle ) ;

概略 指定のモデルと同じ基礎データを使用してモデルを作成する

引数   int SrcMHandle ：　作成するモデルの基礎データを持つモデルのハンドル
戻り値  －１　　　　：　エラー発生
－１以外　：　モデルのハンドル

解説  　SrcMHandle が持つ基礎モデルデータを使用してモデルを作成します。
　用途としては、たとえばアクションゲームの雑魚敵など、 同じ見た目で大量に登場するキャラクターが居る場合、 その数だけ MV1LoadModel をしてしまうと同じ３Ｄモデルデータが幾つもメモリ上に存在することになり効率的ではありません( それに読み込み時間も掛かります )、 なのでそんな場合にはキャラクターモデル一つに付き一回だけ MV1LoadModel で読み込んで、 後は MV1LoadModel ではなく MV1DuplicateModel を使用してモデルハンドルを作成するようにすれば使用メモリ容量と読み込み時間を大幅に削減することができます。

　因みに画像ハンドルのように一つのモデルを使用して一体描画する度に位置や再生するアニメーションなどを切り替え、 再度描画するといったことをすることでモデルハンドル一つで複数のキャラクターを表現することは可能ですが、 ２Ｄの画像一枚と違い３Ｄモデルには色々な状態情報が含まれていますので、キャラクターの数だけモデルハンドルを作成したほうが速度的には有利です。

　なお、作成されるモデルハンドルには、SrcMHandle が示すモデルの座標値や回転値、 アタッチしているアニメーションなど MV1LoadModel 以降に設定された情報は基本的に継承されません。 ( 特別に継承される情報を変更する関数には、その関数の解説でその旨を記載しています )



サンプル

　　モデルファイル DxChara.x を読み込んだあと、同じデータを使用するモデルハンドルを３つ作成し、 それぞれ座標をずらして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle[ 4 ] ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 同じデータを使用するモデルハンドルを３つ作成する
	ModelHandle[ 1 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;
	ModelHandle[ 2 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;
	ModelHandle[ 3 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle[ 0 ], VGet( -200.0f, -300.0f, 600.0f ) ) ;
	MV1SetPosition( ModelHandle[ 1 ], VGet(  150.0f, -300.0f, 600.0f ) ) ;
	MV1SetPosition( ModelHandle[ 2 ], VGet(  500.0f, -300.0f, 600.0f ) ) ;
	MV1SetPosition( ModelHandle[ 3 ], VGet(  850.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle[ 0 ] ) ;
	MV1DrawModel( ModelHandle[ 1 ] ) ;
	MV1DrawModel( ModelHandle[ 2 ] ) ;
	MV1DrawModel( ModelHandle[ 3 ] ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1DeleteModel( int MHandle ) ;

概略 モデルを削除する

引数   int MHandle ：　削除するモデルのハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle で渡されたモデルハンドルが示すモデルをメモリ上から削除します。
　用途はメモリの節約と、モデルハンドルの節約です。( モデルハンドルは最大で 65536 個までしか作れません )
　使用しなくなったモデルハンドルをこの関数で削除せずに次々と新たなモデルを読み込んだり MV1DuplicateModel で複製したりすると何れメモリが足りなくなるかモデルハンドルの限界数に達するかをしてしまいますので、 使用しなくなったモデルハンドルはこの関数で削除するようにしてください。

　因みに DxLib_End を呼ぶと作成されていたモデルは自動的に削除されますので、 DxLib_End の前に作成していたモデル全てに対して MV1DeleteModel をする必要はありません。

サンプル

　DxChara.x を MV1LoadModel で読み込んだ後、ひたすら MV1DuplicateModel でモデルを作成 → 描画 → MV1DeleteModel で削除を繰り返します。 ( サンプルでは MV1DeleteModel を使うために無意味に作成と削除を繰り返していますが、移動して描画する度に削除と作成をしなければいけないわけではありません )
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, DupModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() SetDrawScreen( DX_SCREEN_BACK ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// 何かボタンが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 読み込んだデータと同じデータを使用するモデルハンドルを作成する
		DupModelHandle = MV1DuplicateModel( ModelHandle ) ;

		// 画面に映るランダムな位置に３Ｄモデルを移動
		MV1SetPosition( DupModelHandle, VGet( ( float )GetRand( 639 ), ( float )-GetRand( 300 ), GetRand( 300 ) + 300.0f ) ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( DupModelHandle ) ;

		// ３Ｄモデルの削除
		MV1DeleteModel( DupModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetLoadModelUsePhysicsMode( int PhysicsMode ) ;

概略 読み込むモデルの物理演算モードを設定する

引数   int PhysicsMode ：　読み込むモデルに適用する物理演算モード
　　　　　DX_LOADMODEL_PHYSICS_LOADCALC　　ファイル読み込み時に物理演算を行う
　　　　　DX_LOADMODEL_PHYSICS_REALTIME　　　リアルタイム物理演算を行う
　　　　　DX_LOADMODEL_PHYSICS_DISABLE　　　　物理演算を使用しない
戻り値 　０：成功
　 －１：エラー発生

解説  　MV1LoadModel で読み込まれる３Ｄモデルに物理演算用の情報がある場合の処理を設定します。
　物理演算用の情報がないモデルを読み込む場合はこの関数の設定は関係ありません。


DX_LOADMODEL_PHYSICS_LOADCALC　　ファイル読み込み時に物理演算を行う（デフォルト）

　　ファイル読み込み時にアニメーションを再生しながらの物理演算をシミュレーション(計算)して、
　その結果をアニメーションに含めてしまいます。

　　物理演算用情報を持ったモデル特有の処理をしなくても物理演算の恩恵を受けることができ、
　処理負荷もアニメーションを再生しながら物理演算を行う DX_LOADMODEL_PHYSICS_REALTIME より
　低くなりますが、シミュレーションは「その場に立ち止まった状態でアニメーションを再生した」ことを
　前提として行われるため、見た目は DX_LOADMODEL_PHYSICS_REALTIME より不自然になります。


DX_LOADMODEL_PHYSICS_REALTIME　　リアルタイム物理演算を行う

　　DX_LOADMODEL_PHYSICS_LOADCALC と違いリアルタイムに物理演算を行います。
　　リアルタイムに３Ｄモデルの挙動に即した物理演算が行われるため、
　DX_LOADMODEL_PHYSICS_LOADCALC より自然な動きになります。

　　ただ、代わりに MV1SetScale によるスケーリングができないという点と、処理負荷が
　DX_LOADMODEL_PHYSICS_LOADCALC より高いというデメリットがあります。

　　リアルタイムの物理演算には通常の３Ｄモデルを扱う関数のほかに実際に物理演算を行う関数
　MV1PhysicsCalculation と物理演算の状態をリセットする関数 MV1PhysicsResetState を使用します。

　　尚、現時点では各モデル個別に物理演算を行うため、物理演算の情報を持つモデル同士の
　衝突などには対応していません。


DX_LOADMODEL_PHYSICS_DISABLE　　物理演算を使用しない

　　物理演算用の情報が含まれる３Ｄモデルを読み込んだ際も物理演算用の情報が
　ない３Ｄモデルとして扱います。

サンプル

　リアルタイム物理演算モードで Test.pmd と Test000.vmd を MV1LoadModel で読み込んで
リアルタイム物理演算を行いながらアニメーション０をループ再生します。
　尚、Test.pmd と Test000.vmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。
　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex ;
	float TotalTime, PlayTime ;

	// ウインドウモードで起動
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "Test.pmd" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラに映る範囲( カメラからの距離の範囲 )を設定
	SetCameraNearFar( 10.0f, 1000.0f ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

	// ３Ｄモデルの０番目のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, 0, -1, FALSE ) ;

	// アタッチしたアニメーションの総再生時間を取得する
	TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;

	// 物理演算の状態をリセット
	MV1PhysicsResetState( ModelHandle ) ;

	// 再生時間の初期化
	PlayTime = 0.0f ;

	// 何かキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 再生時間を進める
		PlayTime += 0.5f ;

		// 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
		if( PlayTime >= TotalTime )
		{
			PlayTime = 0.0f ;

			// 再生時間をセットする
			MV1SetAttachAnimTime( ModelHandle, AttachIndex, PlayTime ) ;

			// モーションがループしたときに位置が移動することがあるので物理演算の状態をリセット
			MV1PhysicsResetState( ModelHandle ) ;
		}
		else
		{
			// 再生時間をセットする
			MV1SetAttachAnimTime( ModelHandle, AttachIndex, PlayTime ) ;
		}

		// 物理演算を６０分の１秒経過したという設定で実行
		MV1PhysicsCalculation( ModelHandle, 1000.0f / 60.0f ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetLoadModelPhysicsWorldGravity( float Gravity ) ;

概略 読み込むモデルの物理演算に適用する重力パラメータを設定する

引数   float Gravity : Ｙ軸方向の重力の強さ( デフォルト値：-122.5f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MV1LoadModel で読み込まれる３Ｄモデルに物理演算用の情報があり、且つ物理演算を行う場合に適用する重力のＹ軸方向の強さを設定します。
　デフォルト値は -122.5f で、値をより低くすれば( マイナス方向に値を大きくすれば )重力は強くなり、高くすれば( プラス方向に値を大きくすれば )重力は小さくなります。
　例えば値をプラスにすると空に向かって重力が働くことになります。

　この関数は MV1LoadModel を呼び出す前に使用します。

サンプル

ありません






モデル描画関係

宣言 int MV1DrawModel( int MHandle ) ;

概略 モデルを描画する

引数   int MHandle ：　描画するモデルのハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルを画面に描画します。
　用途はモデルを画面に表示したい場合など・・・

　因みに、Ｚバッファを使用した現状の３Ｄレンダリングでは半透明の描画物は視点から最も離れているものから順に描画しないと正常な見た目になりませんので、 もし描画するモデルの中に半透明の部分が含まれている場合は視点からの距離を考慮した上で MV1DrawFrame や MV1DrawMesh で描画する必要があります。 ( ＤＸライブラリ自体にＺソートの機能はありません )

サンプル

　MV1LoadModel のサンプルを参考にして下さい。



宣言 int MV1DrawFrame( int MHandle, int FrameIndex ) ;

概略 モデルの指定のフレームを描画する

引数   int MHandle ：　描画するモデルのハンドル
int FrrameIndex ： 描画するフレームの番号
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデル中の FrameIndex 番目のフレームが持つメッシュ( ポリゴンの集合 )を画面に描画します。 ( ＤＸライブラリではモデル中の階層構造を「フレーム」と呼称します。また、フレームの構造は基本的にモデルファイルの通りになります )
　フレームにメッシュが含まれていない場合は何も描画されません。

　用途としては、モデルの一部分のみを描画したい場合や、モデル中に半透明の部分がありパーツ単位で前後関係を考慮して描画しなければならない場合などに使用します。

　尚、モデル中に何個フレームがあるかは MV1GetFrameNum 関数で、各フレームの名前等はそれぞれの座標などは『フレーム関係』の関数を使用することで取得することができます。

サンプル

　　モデルファイル DxChara.x を読み込んで、２番目のフレームのみ画面に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの２番目のフレームを描画
	MV1DrawFrame( ModelHandle, 2 ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1DrawMesh( int MHandle, int MeshIndex ) ;

概略 モデルの指定のメッシュを描画する

引数   int MHandle ：　描画するモデルのハンドル
int MeshIndex ： 描画するメッシュの番号
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデル中の MeshIndex 番目のメッシュを描画します。 ( ＤＸライブラリではポリゴンの集合のことを「メッシュ」と呼称します )
　モデルの一部分を描画したい場合は MV1DrawFrame 関数を使用しますが、この関数は「フレーム」より細かい単位の「メッシュ」で描画を行います。
　用途は MV1DrawFrame と同じで、フレームより細かい単位で描画したい場合や、フレーム中の一部分のみ半透明のものがあり、前後関係を考慮した上で個別に描画したい場合などに使用します。

　構造的には、メッシュは必ずどこかのフレームに所属していて、フレームが持つメッシュを全て描画するのが MV1DrawFrame 関数、その内の一つだけを描画するのが MV1DrawMesh 関数となります。

　フレームに含まれるメッシュの数ははフレームに含まれるポリゴンに使用されているマテリアル( 材質 )の数と比例します。つまり、マテリアル毎にメッシュが分かれているというわけです。
　なので、例えば「布」「金属」「革」といった３つのマテリアルを使用したフレームが存在した場合は、そのフレームが持つメッシュの数は３つになります。

　モデル中に何個メッシュがあるかは MV1GetMeshNum 関数で、各フレームに含まれるメッシュの数は MV1GetFrameMeshNum 関数で、 各フレームに含まれるメッシュの識別番号は MV1GetFrameMesh で取得することができます。
　また、各メッシュの情報を取得したり設定したりする関数は『メッシュ関係』に一覧があります。

サンプル

　　モデルファイル DxChara.x を読み込んで、０番目のメッシュを画面に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの０番目のメッシュを描画
	MV1DrawMesh( ModelHandle, 0 ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------





モデル基本制御関係

宣言 int MV1SetPosition( int MHandle, VECTOR Position ) ;

概略 モデルの座標をセットする

引数   int　　　　MHandle ： モデルのハンドル
VECTOR Position ： モデルにセットする座標
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの座標をセットします。

　グラフィックハンドルでは座標やスケールと言ったものは画像自体には保持せず DrawGraph や DrawExtendGraph などの描画関数を呼ぶ際に直接指定していましたが、 ３Ｄモデルは設定すべき情報が多く、項目の数に合わせて描画関数のバリエーションを増やしたらとんでもないことになってしまうので、 この MV1SetPosition などの関数で描画を行う前に予め座標や回転値を設定するようになっています。

　座標は VECTOR 型の構造体( float x, y, z をメンバ変数に持つ構造体 )が引数になっていて、 いちいち VECTOR 構造体を定義してメンバ変数に座標値を代入して、という手順を踏まなければならなくて面倒ですが、 x, y, z の値を引数で渡すと VECTOR 構造体を戻り値として返してくれる VGet 関数を使用すれば面倒ではなくなります。



	// 普通に引数を渡そうとすると面倒・・・
	VECTOR Position ;

	Position.x = 0.0f ;
	Position.y = 400.0f ;
	Position.z = -600.0f ;
	MV1SetPosition( MHandle, Position ) ;

	-----------------------------------------------

	// VGet 関数を使用すれば簡単
	MV1SetPosition( MHandle, VGet( 0.0f, 400.0f, -600.0f ) ) ;



サンプル

　MV1LoadModel のサンプルを参考にして下さい。



宣言 VECTOR MV1GetPosition( int MHandle ) ;

概略 モデルの座標を取得する

引数   int MHandle ： モデルのハンドル
戻り値 モデルの座標

解説  　MHandle のモデルハンドルが示すモデルの座標を取得します。
　MV1SetPosition でセットした座標を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetScale( int MHandle, VECTOR Scale ) ;

概略 モデルの拡大値をセットする

引数   int　　　　MHandle ： モデルのハンドル
VECTOR Scale 　： 拡大値
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの拡大値を設定します。
　Scale で渡す VECTOR 構造体の各メンバ変数( x, y, z )の値を 2.0f にするとモデルが２倍の大きさに、逆に 0.5f 等にすると半分の大きさになります。 尚、マイナスの値を渡すと見た目が破綻します。

サンプル

　　モデルファイル DxChara.x を読み込んで、x軸方向に２倍に拡大して描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルのスケールをx軸方向に２倍にする
	MV1SetScale( ModelHandle, VGet( 2.0f, 1.0f, 1.0f ) ) ;

	// ３Ｄモデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR MV1GetScale( int MHandle ) ;

概略 モデルの拡大値を取得する

引数   int MHandle ： モデルのハンドル
戻り値 モデルの拡大値

解説  　MHandle のモデルハンドルが示すモデルの拡大値を取得します。
　MV1SetScale でセットした拡大値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetRotationXYZ( int MHandle, VECTOR Rotate ) ;

概略 モデルの回転値をセットする

引数   int　　　　MHandle ： モデルのハンドル
VECTOR Rotate　　： 回転値( 単位はラジアン )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの回転値を設定します。
　Rotate で渡す VECTOR 構造体の各メンバ変数( x, y, z )の値はそれぞれ x軸回転値、y軸回転値、z軸回転値を代入しておきます。 ( 回転値の単位はラジアンですので、度数単位の値を代入する場合は　度 * PHI_F / 180.0f　の計算をしてください )

　キャラクターモデルの向いている方向を設定する場合は y軸回転を使用します。

　尚、回転の順番は x軸回転 → y軸回転 → z軸回転 です。

サンプル

　　モデルファイル DxChara.x を読み込んで、y軸を回転軸として９０度回転して描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３ＤモデルのY軸の回転値を９０度にセットする
	MV1SetRotationXYZ( ModelHandle, VGet( 0.0f, 90.0f * PHI_F / 180.0f, 0.0f ) ) ;

	// ３Ｄモデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 VECTOR MV1GetRotationXYZ( int MHandle ) ;

概略 モデルの回転値を取得する

引数   int MHandle ： モデルのハンドル
戻り値 モデルの回転値

解説  　MHandle のモデルハンドルが示すモデルの回転値を取得します。
　MV1SetRotationXYZ でセットした回転値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetRotationZYAxis( int MHandle, VECTOR ZAxis, VECTOR YAxis, float ZTwist ) ;

概略 モデルのＺ軸とＹ軸の方向をセットする

引数   int　　　　MHandle ： モデルのハンドル
VECTOR ZAxis ： Ｚ軸の方向
VECTOR YAxis ： Ｙ軸の方向
float　　　ZTwist ： ZAxis を回転軸とした回転値( 単位はラジアン )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの回転値をＺ軸の方向、Ｙ軸の方向と、ZAxis で指定した方向を軸とした回転値で設定します。 ( ZAxis, YAxis は正規化されている必要はありません )

　この関数は何かのモデルをある方向に向けたい場合などに使用します。( 砲台を敵の方向に向けるなど )

サンプル

　　モデルファイル DxChara.x を読み込んで、モデルのz軸の方向を画面左上の方に向けて描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 0.0f, 600.0f ) ) ;

	// ３ＤモデルのＺ軸を画面左上方向に向ける
	// ( DxChara.x はＺ軸のマイナス方向に向いているので右下方向に傾きます )
	MV1SetRotationZYAxis( ModelHandle, VGet( -0.5f, 0.5f, 0.0f ), VGet( 0.5f, 0.5f, 0.0f ), 0.0f ) ;

	// ３Ｄモデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetMatrix( int MHandle, MATRIX Matrix ) ;

概略 モデルの座標変換用行列をセットする

引数   int　　　　MHandle ： モデルのハンドル
MATRIX Matrix ： 座標変換用行列
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの座標変換用行列をセットします。

　この関数は MV1SetPosition 関数や MV1SetScale や MV1SetRotationXYZ関数などの代わりに行列を使用してローカル → ワールド座標変換を行いたい場合に使用します。

　この関数に単位行列以外の行列を渡すと、以後 MV1SetPosition や MV1SetScale 等の関数の設定は無視され、 MV1SetMatrix 関数で設定した行列のみを使用してローカル → ワールド座標変換が行われるようになります。 ( 解除する場合は MV1SetMatrix 関数に単位行列を渡します )

サンプル

　　モデルファイル DxChara.x を読み込んで、拡大率を２倍にしてから座標をカメラの写る位置に移動するということを行列を使用して設定した後に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ２倍に拡大した後画面に映る位置に３Ｄモデルを移動する行列のセット
	MV1SetMatrix( ModelHandle, MMult( MGetScale( VGet( 2.0f, 2.0f, 2.0f ) ), MGetTranslate( VGet( 320.0f, -600.0f, 600.0f ) ) ) ) ;

	// ３Ｄモデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MATRIX MV1GetMatrix( int MHandle ) ;

概略 モデルの座標変換用行列を取得する

引数   int MHandle ： モデルのハンドル
戻り値 モデルの座標変換用行列

解説  　MHandle のモデルハンドルが示すモデルの座標変換用行列を取得します。
　事前に MV1SetMatrix で行列を設定していた場合はその値が、 設定していなかった場合は MV1SetPosition や MV1SetScale 等の関数で設定した値の結果( 行列 )が返ってきます。

サンプル

　　モデルファイル DxChara.x を読み込んで複製した後、最初に読み込んだモデルハンドルの方に座標位置変更や拡大率の設定を行い、 その結果の行列を複製したモデルに設定して描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, SubModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ModelHandle と同じモデルを使用するモデルの作成
	SubModelHandle = MV1DuplicateModel( ModelHandle ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 0.0f, 600.0f ) ) ;

	// ３Ｄモデルの拡大率を０．５倍にする
	MV1SetScale( ModelHandle, VGet( 0.5f, 0.5f, 0.5f ) ) ;

	// ModelHandle に設定した座標変換パラメータの結果の行列を SubModelHandle の座標変換行列として設定する
	MV1SetMatrix( SubModelHandle, MV1GetMatrix( ModelHandle ) ) ;

	// SubModelHandle の方の３Ｄモデルを描画
	MV1DrawModel( SubModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetVisible( int MHandle, int VisibleFlag ) ;

概略 モデルを描画するかどうかを変更する

引数   int MHandle ： モデルのハンドル
int VisibleFlag ： 描画するかどうか( TRUE：表示する FALSE：表示しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルを描画するかどうかを設定します。
　この関数で描画しない設定にすると、以後 MV1DrawModel 等の描画関数を使用しても描画されなくなります。

サンプル

　　モデルファイル DxChara.x を GetNowCount が返す値が奇数秒の時だけ描画する。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// 何かキーが押されるかウインドウが閉じられるまでループする
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリアする
		ClearDrawScreen() ;

		// ３Ｄモデルをカウンタが奇数秒の時は描画して、偶数表のときは描画しないようにする
		if( GetNowCount() % 2000 MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetVisible( int MHandle ) ;

概略 モデルを描画するかどうかを取得する

引数   int MHandle ： モデルのハンドル
戻り値 　TRUE：モデルを描画する FALSE：モデルを描画しない
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルを描画するかどうかの設定値を取得します。
　MV1SetVisible でセットした設定値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetDifColorScale( int MHandle, COLOR_F Scale ) ;

概略 モデルのディフューズカラーのスケール値を設定する

引数   int　　　　　MHandle ： モデルのハンドル
COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルのマテリアルのディフューズカラー( 拡散光色 )のスケール値を設定します。

　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、 モデル描画時にマテリアル中のディフューズカラーの緑成分とα成分以外が 0.0f として描画されます。

　用途としては選択されているモデルの表現や、簡単な色違い表現などがあります。

　因みに引数の COLOR_F は float r, g, b, a を持つ構造体です。
これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、 引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 GetColorF を使用すると便利です。



// ディフューズカラーの赤成分を５０％にする
MV1SetDifColorScale( ModelHandle, GetColorF( 0.5f, 1.0f, 1.0f, 1.0f ) ) ;



サンプル

　　モデルファイル DxChara.x のディフューズカラーの緑成分と青成分を０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルのディフューズカラーの緑成分と青成分を０％にする
	MV1SetDifColorScale( ModelHandle, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetDifColorScale( int MHandle ) ;

概略 モデルのディフューズカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
戻り値 ディフューズカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのディフューズカラーに適用するスケール値を取得します。
　MV1SetDifColorScale でセットした設定値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetSpcColorScale( int MHandle, COLOR_F Scale ) ;

概略 モデルのスペキュラカラーのスケール値を設定する

引数   int　　　　　MHandle ： モデルのハンドル
COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルのマテリアルのスペキュラカラー( 反射光色 )のスケール値を設定します。

　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、 モデル描画時にマテリアル中のスペキュラカラーの緑成分とα成分以外が 0.0f として描画されます。

　用途としては光沢があるオブジェクトの光沢の色を変化させたり、光沢を無くしたりすることができます。

　因みに、モデルのマテリアルに設定されているスペキュラカラー値に対するスケールなので、 設定対象のモデルのマテリアルに元々スペキュラカラー成分が無い場合( スペキュラカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。
サンプル

　　モデルファイル DxChara.x のスペキュラカラーの緑成分と青成分を０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルのスペキュラカラーの緑成分と青成分を０％にする
	MV1SetSpcColorScale( ModelHandle, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetSpcColorScale( int MHandle ) ;

概略 モデルのスペキュラカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
戻り値 スペキュラカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのスペキュラカラーに適用するスケール値を取得します。
　MV1SetSpcColorScale でセットした設定値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetEmiColorScale( int MHandle, COLOR_F Scale ) ;

概略 モデルのエミッシブカラーのスケール値を設定する

引数   int　　　　　MHandle ： モデルのハンドル
COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルのマテリアルのエミッシブカラー( 自己発光色 )のスケール値を設定します。

　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、 モデル描画時にマテリアル中のエミッシブカラーの緑成分とα成分以外が 0.0f として描画されます。

　用途としては自己発光しているオブジェクトの自己発光を止めたり、自己発光の色を変化させたりすることができます。

　因みに、モデルのマテリアルに設定されているエミッシブカラー値に対するスケールなので、 設定対象のモデルのマテリアルに元々エミッシブカラー成分が無い場合( エミッシブカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。

サンプル

　　モデルファイル DxChara.x のエミッシブカラーの緑成分と青成分を０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルのエミッシブカラーの緑成分と青成分を０％にする
	MV1SetEmiColorScale( ModelHandle, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetEmiColorScale( int MHandle ) ;

概略 モデルのエミッシブカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
戻り値 エミッシブカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのエミッシブカラーに適用するスケール値を取得します。
　MV1SetEmiColorScale でセットした設定値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetAmbColorScale( int MHandle, COLOR_F Scale ) ;

概略 モデルのアンビエントカラーのスケール値を設定する

引数   int　　　　　MHandle ： モデルのハンドル
COLOR_F Scale　　： カラースケール値( 0.0f ～ 1.0f = 0% ～ 100% )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルのマテリアルのアンビエントカラー( 環境光色 )のスケール値を設定します。

　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、 モデル描画時にマテリアル中のアンビエントカラーの緑成分とα成分以外が 0.0f として描画されます。

　用途はあまり思いつきませんが、環境光の影響を受けたり受けなかったりを変化させることができます。

　因みに、モデルのマテリアルに設定されているアンビエントカラー値に対するスケールなので、 設定対象のモデルのマテリアルに元々アンビエントカラー成分が無い場合( アンビエントカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。

サンプル

　　モデルファイル DxChara.x のアンビエントカラーの緑成分と青成分を０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルのアンビエントカラーの緑成分と青成分を０％にする
	MV1SetAmbColorScale( ModelHandle, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetAmbColorScale( int MHandle ) ;

概略 モデルのアンビエントカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
戻り値 アンビエントカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのアンビエントカラーに適用するスケール値を取得します。
　MV1SetAmbColorScale でセットした設定値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1GetSemiTransState( int MHandle ) ;

概略 モデルに半透明要素があるかどうかを取得する

引数   int MHandle ： モデルのハンドル
戻り値 TRUE：半透明要素がある　FALSE：半透明要素は無い
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに半透明の要素があるかどうかを取得します。

　例えば、モデル中のどれかのマテリアルのテクスチャに半透明の部分があったり、 モデル中のどれかのフレームの不透明度が 1.0f ではなかったりすると TRUE が返ってきます。

　半透明要素を持つモデルをＺソートする場合に、各モデルに半透明要素があるかどうかを判定する際などに使用します。

サンプル

　　モデルファイル DxChara.x の不透明度を上下キーで操作できるようにした上で、 画面上に MV1GetSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float OpacityRate ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// 不透明度を初期化
	OpacityRate = 1.0f ;

	// ESCキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面のクリア
		ClearDrawScreen() ;

		// 上キーが押されたら不透明度を上げる
		if( CheckHitKey( KEY_INPUT_UP ) )
		{
			OpacityRate += 0.05f ;
			if( OpacityRate > 1.0f )
			{
				OpacityRate = 1.0f ;
			}
		}

		// 下キーが押されたら不透明度を下げる
		if( CheckHitKey( KEY_INPUT_DOWN ) )
		{
			OpacityRate -= 0.05f ;
			if( OpacityRate MV1SetOpacityRate( ModelHandle, OpacityRate ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 現在の不透明度と、MV1GetSemiTransState の戻り値を描画する
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),
			"ESC Key:Exit OpacityRate:%f SemiTransState:%d",
			OpacityRate, MV1GetSemiTransState( ModelHandle ) ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetOpacityRate( int MHandle, float Rate ) ;

概略 モデルの不透明度を設定する

引数   int MHandle ： モデルのハンドル
float Rate ： 不透明度( 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの不透明度を設定します。

　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、 1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。

　モデルを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。

サンプル

　　モデルファイル DxChara.x の不透明度を５０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 255,0,0 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの不透明度を50%にする
	MV1SetOpacityRate( ModelHandle, 0.5f ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetOpacityRate( int MHandle ) ;

概略 モデルの不透明度を取得する

引数   int MHandle ： モデルのハンドル
戻り値 モデルに設定されている不透明度

解説  　MHandle のモデルハンドルが示すモデルに設定されている不透明度を取得します。
　MV1SetOpacityRate でセットした値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetUseZBuffer( int MHandle, int Flag ) ;

概略 モデルを描画する際にＺバッファを使用するかどうかを設定する

引数   int MHandle ： モデルのハンドル
int Flag ： Ｚバッファを使用するかどうかのフラグ
　　　　　　( TRUE：使用する( 初期設定 ) FALSE：使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルを描画する際にＺバッファを使用するかどうかを設定します。

　SetUseZBuffer3D のモデル用の関数で、 効果は SetUseZBuffer3D と全く同じです。 ( Ｚバッファの詳しい説明は SetUseZBuffer3D 関数の解説に記述してあります )

サンプル

ありません



宣言 int MV1SetWriteZBuffer( int MHandle, int Flag ) ;

概略 モデルを描画する際にＺバッファを使用するかどうかを設定する

引数   int MHandle ： モデルのハンドル
int Flag ： Ｚバッファに書き込みを行うかどうかのフラグ
　　　　　　( TRUE：書き込む( 初期設定 ) FALSE：書き込まない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルを描画する際にＺバッファを使用するかどうかを設定します。

　SetWriteZBuffer3D のモデル用の関数で、 効果は SetWriteZBuffer3D と全く同じです。 ( Ｚバッファの詳しい説明は SetUseZBuffer3D 関数の解説に記述してあります )

サンプル

ありません



宣言 int MV1SetUseVertDifColor( int MHandle, int UseFlag ) ;

概略 モデル描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する

引数   int MHandle ： モデルのハンドル
int UseFlag ： 頂点データのディフューズカラーを使用するかどうか
　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルを描画する際のライティング計算に頂点データのディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定します。( 初期設定では使用しません )

　この関数で頂点ディフューズカラーを使用する設定にした場合はマテリアルのディフューズカラー設定は無視され、 代わりに頂点ディフューズカラーが使用されます。

　尚、ライティング計算を SetUseLighting 関数で無効にした場合はこの関数の設定に関係なくマテリアルのディフューズカラーは無視され、頂点ディフューズカラーが使用されます。

サンプル

　MV1SetMeshUseVertDifColor関数 のサンプルを参照してください。



宣言 int MV1SetUseVertSpcColor( int MHandle, int UseFlag ) ;

概略 モデル描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する

引数   int MHandle ： モデルのハンドル
int UseFlag ： 頂点データのスペキュラカラーを使用するかどうか
　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルを描画する際のライティング計算に頂点データのスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定します。( 初期設定では使用しません )

　この関数で頂点スペキュラカラーを使用する設定にした場合はマテリアルのスペキュラカラー設定は無視され、 代わりに頂点スペキュラカラーが使用されます。

　尚、ライティング計算を SetUseLighting 関数で無効にした場合はこの関数の設定に関係なくマテリアルのスペキュラカラーは無視され、頂点スペキュラカラーが使用されます。

サンプル

ありません



宣言 int MV1PhysicsCalculation( int MHandle, float MillisecondTime ) ;

概略 モデルの物理演算を指定時間分経過したと仮定して計算する

引数   int MHandle　　　　　 ： モデルのハンドル
float MillisecondTime ： 経過時間( 単位：ミリ秒 )
戻り値 　０：成功
　 －１：エラー発生

解説  　関数 MV1SetLoadModelUsePhysicsModeを使用して読み込む３Ｄモデルに対してリアルタイム物理演算を行うように指定した上で、 物理演算用の情報を持つ３Ｄモデルを関数 MV1LoadModel で読み込んだ場合に、この関数を使用して実際の物理演算を行います。

　引数の MillisecondTime で経過したと仮定する時間を指定します。
　単位はミリ秒( １秒は 1000.0fミリ秒 )です、通常のゲームは１秒間に６０回、 若しくは３０回画面が更新されるので、これに基づいて引数を指定する場合は

１秒間に６０回の場合は１回に 1000.0f ミリ秒の６０分の１分だけ処理するので

　　1000.0f / 60.0f = 16.66667f

１秒間に３０回の場合は１回に 1000.0f ミリ秒の３０分の１分だけ処理するので

　　1000.0f / 30.0f = 33.33333f

となります。

　この関数の結果はモデルの位置や姿勢を変更する関数( MV1SetPosition や MV1SetRotationXYZ、MV1SetMatrix、MV1AttachAnim、MV1SetAttachAnimTime )を使用すると無効になってしまいますので、物理演算の結果を描画する場合は必ず

　MV1SetPosition や MV1SetRotationXYZ、MV1SetAttachAnimTime などの関数で姿勢を決定した後

に、この関数を実行するようにしてください。

＜注意＞
リアルタイム物理演算を使用する場合は MV1SetScale によるスケーリングを行うと正常な演算結果が得られなくなりますので MV1SetScale を使用する場合はリアルタイム物理演算は行わないでください。

サンプル

　リアルタイム物理演算モードで Test.pmd を MV1LoadModel で読み込んで
リアルタイム物理演算を行いながらキーボードの上下左右でモデルの位置を移動します。
　尚、Test.pmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。
　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int PosX, PosZ, PosY ;

	// ウインドウモードで起動
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1SetLoadModelUsePhysicsMode( DX_LOADMODEL_PHYSICS_REALTIME ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "Test.pmd" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラに映る範囲( カメラからの距離の範囲 )を設定
	SetCameraNearFar( 10.0f, 1000.0f ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

	// 座標をリセット
	PosX = 0 ;
	PosY = 0 ;
	PosZ = 0 ;

	// ウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// キーボードの上下左右でモデルの座標を変更
		// ( シフトキーを押しながら上下キーでモデルを上下に移動 )
		if( CheckHitKey( KEY_INPUT_LSHIFT ) )
		{
			if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosY -- ;
			if( CheckHitKey( KEY_INPUT_UP    ) ) PosY ++ ;
		}
		else
		{
			if( CheckHitKey( KEY_INPUT_LEFT  ) ) PosX -- ;
			if( CheckHitKey( KEY_INPUT_RIGHT ) ) PosX ++ ;
			if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosZ -- ;
			if( CheckHitKey( KEY_INPUT_UP    ) ) PosZ ++ ;
		}

		// モデルの座標をセット
		MV1SetPosition( ModelHandle, VGet( PosX * 0.5f, PosY * 0.5f, PosZ * 0.5f ) ) ;

		// 物理演算を６０分の１秒経過したという想定で実行
		MV1PhysicsCalculation( ModelHandle, 1000.0f / 60.0f ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1PhysicsResetState( int MHandle ) ;

概略 モデルの物理演算の状態をリセットする

引数   int MHandle ： モデルのハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　関数 MV1SetLoadModelUsePhysicsModeを使用して読み込む３Ｄモデルに対してリアルタイム物理演算を行うように指定した上で、 物理演算用の情報を持つ３Ｄモデルを関数 MV1LoadModel で読み込んだ場合に、この関数を使用して物理演算の状態のリセットを行います。

　リセットする必要が発生するタイミングは主にワープ( 瞬間的に離れた場所に移動 )した場合です。

　現実では人間はワープしませんし( できませんし )、ゲーム中のキャラクターも特殊能力の設定でもない限りはワープしませんが、 ステージを移動した場合や、ゲームオーバーになってキャラクターがスタート地点に移動した場合など、 ゲームの手続きとしてのワープはごく普通に発生します。

　ゲームの手続きとして瞬間的に長距離移動しただけなのにも関わらす、この際に物理演算の状態をリセットしないと物理演算プログラムは 「その物体がものすごい速さで瞬間的に長距離移動した」として物理演算を行ってしまい、モデルの表示がおかしくなってしまいます。

　なので、キャラクターをワープさせた際などにはこの関数でモデルの物理演算の状態をリセットしてやってください。
サンプル

　リアルタイム物理演算モードで Test.pmd を MV1LoadModel で読み込んで
リアルタイム物理演算を行いながらキーボードの上下左右でモデルの位置を移動します。

　スペースキーが押されたらモデルを原点にワープさせ、MV1PhysicsResetState でモデルの物理演算の状態をリセットします。

　尚、Test.pmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。
　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int PosX, PosZ, PosY ;

	// ウインドウモードで起動
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1SetLoadModelUsePhysicsMode( DX_LOADMODEL_PHYSICS_REALTIME ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "Test.pmd" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// カメラに映る範囲( カメラからの距離の範囲 )を設定
	SetCameraNearFar( 10.0f, 1000.0f ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

	// 座標をリセット
	PosX = 0 ;
	PosY = 0 ;
	PosZ = 0 ;

	// ウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// キーボードの上下左右でモデルの座標を変更
		// ( シフトキーを押しながら上下キーでモデルを上下に移動 )
		if( CheckHitKey( KEY_INPUT_LSHIFT ) )
		{
			if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosY -- ;
			if( CheckHitKey( KEY_INPUT_UP    ) ) PosY ++ ;
		}
		else
		{
			if( CheckHitKey( KEY_INPUT_LEFT  ) ) PosX -- ;
			if( CheckHitKey( KEY_INPUT_RIGHT ) ) PosX ++ ;
			if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosZ -- ;
			if( CheckHitKey( KEY_INPUT_UP    ) ) PosZ ++ ;
		}

		// モデルの座標をセット
		MV1SetPosition( ModelHandle, VGet( PosX * 0.5f, PosY * 0.5f, PosZ * 0.5f ) ) ;

		// スペースキーが押されたら原点に戻る
		if( GetInputChar( TRUE ) == ' ' )
		{
			PosX = 0 ;
			PosY = 0 ;
			PosZ = 0 ;

			// モデルの座標を原点に移動
			MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, 0.0f ) ) ;

			// モデルの物理演算の状態をリセット
			MV1PhysicsResetState( ModelHandle ) ;
		}

		// 物理演算を６０分の１秒経過したという想定で実行
		MV1PhysicsCalculation( ModelHandle, 1000.0f / 60.0f ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


アニメーション関係

宣言 int MV1AttachAnim( int MHandle, int AnimIndex, int AnimSrcMHandle, int NameCheck ) ;

概略 アニメーションをアタッチする

引数   int MHandle　　　　　　： アニメーションをアタッチするモデルのハンドル
int AnimIndex　　　　　： アタッチするアニメーション番号
int AnimSrcMHandle　： アタッチするアニメーションを持っているモデルのハンドル
　　　　　　　　　　　　　　　( -1 を渡すと MHandle と同じモデルハンドルが使用されます )
int NameCheck　　　　： AnimSrcMHandle が -1 以外の場合にアタッチするアニメーションの
　　　　　　　　　　　　　　フレームの名前とアタッチされる側のモデルのフレームの名前が
　　　　　　　　　　　　　　一致していない場合アタッチしないかどうか
　　　　　　　　　　　　　　( TRUE：アタッチしない　FALSE：アタッチする )
　　　　　　　　　　　　　　この引数は AnimSrcMHandle が -1 の場合は無視されます
戻り値 －１以外：アニメーションアタッチ番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルにアニメーションをアタッチします。

　アニメーションとは主にモデル内のフレームに対する動きのデータで、 キャラクターモデルが歩いたり走ったりといった表現をする際に使用します。 ( アニメーションのデータ自体は予めアニメーションデータを作成できるソフトを使用して作成しておく必要があります )

　ＤＸライブラリではアニメーションを再生する際に、 最初に再生したいアニメーションを指定する作業「アニメーションのアタッチ」をする必要があります。

　アタッチ自体は簡単で、この関数でアタッチしたいアニメーションの番号を渡すだけです。

　そして、アニメーションのアタッチが無事完了すると戻り値としてアタッチ番号が返ってきます。
　これは「ハンドル」と呼べるほどのものではありませんが、 モデルハンドルなどと同様にアタッチしたアニメーションに関する操作はすべてこのアタッチ番号を使用して行いますので、 アタッチ番号もモデルハンドルなどと同じように何かの変数にとっておく必要があります。



// 例 ： モデルに含まれる 0番目のアニメーションをアタッチしてアニメーションの総時間を取得する
int AttachIndex ;
float AnimTime ;

AttachIndex = MV1AttachAnim( MHandle, 0, -1, FALSE ) ;
AnimTime = MV1GetAttachAnimTotalTime( MHandle, AttachIndex ) ;


　アニメーションはアタッチした時点でアタッチしたアニメーションのカウント０の状態がモデルに反映されます。
　そして、アニメーションの再生カウントを変更する際は MV1SetAttachAnimTime を使用します。
　ＤＸライブラリには自動的にカウンタを進める仕組みはありませんので、 「MV1PlayAnim」 や 「MV1StopAnim」 のような名称の関数は存在しません。
　なので、MV1SetAttachAnimTime にセットする再生時間を徐々に進めることでアニメーションを再生します。

　引数 AnimSrcMHandle は同じフレーム構造を持った MHandle とは別のモデルのモデルに含まれているアニメーションを MHandle のモデルで再生する際に使用します。 ( 同じアニメーションを使用する見た目の違うキャラクターモデルが複数ある場合などは、 アニメーションだけのファイルと見た目の違うフレーム構造が同じメッシュだけのファイルを別々に用意することで各キャラクターモデルのファイルにはアニメーションデータを含める必要がなくなるので、 アニメーションデータの容量分だけデータサイズを削減することができます )

　引数 NameCheck は AnimSrcMHandle を使用して別のモデルファイルに含まれるアニメーションをアタッチする場合に、 アニメーションデータ側のフレームの名前とモーションをアタッチするモデルデータ側のフレームの名前を比較して違った場合はアタッチしないという処理をするかどうかを指定する引数で、 TRUE を渡すと比較して、FALSE を渡すと比較しません。

　名前を比較しない場合はフレームの階層構造と各階層のフレームの数がモデル側とアニメーション側で完全に一致していないと正常にアニメーションを再生することができません。
　名前を比較する場合はフレームの階層構造と名前が一致していればモデル側にあってアニメーション側に無いフレームがあっても正常にアニメーションを再生することができます。 ( ただし、同じ階層に同名のフレームが複数ある場合は正常にアニメーションを再生することはできません )

　名前比較を行うかどうかはアタッチするモーションデータにあわせて判断してください。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のアニメーションをループ再生します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex ;
	float TotalTime, PlayTime ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの０番目のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, 0, -1, FALSE ) ;

	// アタッチしたアニメーションの総再生時間を取得する
	TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;

	// 再生時間の初期化
	PlayTime = 0.0f ;

	// 何かキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 再生時間を進める
		PlayTime += 100.0f ;

		// 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
		if( PlayTime >= TotalTime )
		{
			PlayTime = 0.0f ;
		}

		// 再生時間をセットする
		MV1SetAttachAnimTime( ModelHandle, AttachIndex, PlayTime ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1DetachAnim( int MHandle, int AttachIndex ) ;

概略 アニメーションをデタッチする

引数   int MHandle ： アニメーションをデタッチするモデルのハンドル
int AttachIndex ： デタッチするアニメーションのアタッチ番号
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションをデタッチ( 外すこと )します。

　アニメーションは同時に幾つでもアタッチすることができ、 MV1SetAttachAnimBlendRate 関数でアタッチしている各アニメーションの影響率も設定することができるので、 一応、すべてのアニメーションをアタッチして、MV1SetAttachAnimBlendRate 関数で表示したいアニメーションの影響率だけを上げるということもできるのですが、 それをすると使用メモリや処理負荷が多少上昇します。

　なので、ＤＸライブラリのモデル機能では使用するアニメーションのみをアタッチして、 再生が終わったらこの関数でアタッチしたアニメーションをデタッチする( 外す )ことを想定しています。

　因みに、 MV1DeleteModel 関数でモデルを削除する際にアタッチしたアニメーションは自動的にデタッチされますので、 削除する前にアタッチしたすべてのアニメーションをこの関数でデタッチしておかなければならないということはありません。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のアニメーションと１番のアニメーションを交互に再生します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex, PlayAnim ;
	float TotalTime, PlayTime ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの０番目のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, 0, -1, FALSE ) ;

	// アタッチしたアニメーションの総再生時間を取得する
	TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;

	// 再生時間の初期化
	PlayTime = 0.0f ;

	// 再生しているアニメーションを０番にする
	PlayAnim = 0 ;

	// アニメーション０の再生が終わるか、何かキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 再生時間を進める
		PlayTime += 100.0f ;

		// 再生時間がアニメーションの総再生時間に達したら次のアニメーションにする
		if( PlayTime >= TotalTime )
		{
			// 再生しているアニメーションを、今までが０番だったら１番に、１番だったら０番にする
			if( PlayAnim == 0 )
			{
				PlayAnim = 1 ;
			}
			else
			{
				PlayAnim = 0 ;
			}

			// 今までアタッチしていたアニメーションのデタッチ
			MV1DetachAnim( ModelHandle, AttachIndex ) ;

			// ３Ｄモデルの PlayAnim 番目のアニメーションをアタッチする
			AttachIndex = MV1AttachAnim( ModelHandle, PlayAnim, -1, FALSE ) ;

			// アタッチしたアニメーションの総再生時間を取得する
			TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;

			// 再生時間の初期化
			PlayTime = 0.0f ;
		}

		// 再生時間をセットする
		MV1SetAttachAnimTime( ModelHandle, AttachIndex, PlayTime ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetAttachAnimTime( int MHandle, int AttachIndex, float Time ) ;

概略 アタッチしているアニメーションの再生時間を設定する

引数   int MHandle ： モデルのハンドル
int AttachIndex ： 再生時間を設定するアニメーションのアタッチ番号
float Time ： 再生時間
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの再生時間を設定します。

　ＤＸライブラリのアニメーション機能には自動的にアニメーションを再生する機能はありませんので、 この関数を使用してアニメーションの再生時間を設定します。

　アニメーションのキーが存在しない時間が指定された場合は、 指定された時間の前後にあるキーからの補間値がモデルに反映されます。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のアニメーションの再生時間 10000.0f の状態を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの０番目のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, 0, -1, FALSE ) ;

	// アタッチしたアニメーションの再生時間を 10000.0f にする
	MV1SetAttachAnimTime( ModelHandle, AttachIndex, 10000.0f ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetAttachAnimTime( int MHandle, int AttachIndex ) ;

概略 アタッチしているアニメーションの再生時間を取得する

引数   int MHandle ： モデルのハンドル
int AttachIndex ： 再生時間を取得するアニメーションのアタッチ番号
戻り値 アニメーションに設定されている再生時間

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの再生時間を取得します。
MV1SetAttachAnimTime でセットした値を取得するだけの関数です。

サンプル

ありません



宣言 float MV1GetAttachAnimTotalTime( int MHandle, int AttachIndex ) ;

概略 アタッチしているアニメーションの総時間を取得する

引数   int MHandle ： モデルのハンドル
int AttachIndex ： 総時間取得するアニメーションのアタッチ番号
戻り値 アニメーションの総時間

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの総時間を取得します。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のアニメーションの総時間を画面左上に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex ;
	float TotalTime ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ３Ｄモデルの０番目のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, 0, -1, FALSE ) ;

	// アニメーション０番の総時間を画面に描画
	TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "%f", TotalTime ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetAttachAnimBlendRate( int MHandle, int AttachIndex, float Rate ) ;

概略 アタッチしているアニメーションのブレンド率を設定する

引数   int MHandle ： モデルのハンドル
int AttachIndex ： アニメーションのアタッチ番号
float Rate ： ブレンド率( 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションのブレンド率を設定します。

　例えば、アニメーション０とアニメーション１を合成して表示したいときにします。
　そんな状況があるのかといいますと、結構あります。

　例えば歩いている状態から走っているアニメーションに切り替えたい場合、 最良の見た目を求めるのでしたら歩いている状態から走っている状態に移行するアニメーションを作り、 それを歩くアニメーションと走るアニメーションの間に再生するべきですが、 実際のゲームでは大抵の場合歩いているアニメーションのどのタイミングで走るアニメーションに切り替わるのかを事前に知る方法はありませんので、 歩くアニメーションを途中で止めて走るアニメーションを流すことになります。

　ですが、歩くアニメーションを止めて走るアニメーションを再生するとはっきりと切り替わりが見えてしまいあまり見た目的に良くありません、 こんな時にこの関数を使用して歩くアニメーションのブレンド率を徐々に下げ、 走るアニメーションのブレンド率を徐々に上げることで歩くアニメーションから走るアニメーションへの以降の様子をぼかして違和感を軽減することが出来ます。

　他にも全く姿勢の違うアニメーションへの切り替えの違和感を軽減する際などに使用できます。

サンプル

　　モデルファイル DxChara.x に含まれる直立しているアニメーションから右手を前に出しているアニメーションへ徐々に移行します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AttachIndex1, AttachIndex2 ;
	float Rate ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() WaitTimer( 1000 ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルの立っているアニメーション( ４番目のアニメーション )をアタッチする
	AttachIndex1 = MV1AttachAnim( ModelHandle, 4, -1, FALSE ) ;

	// ３Ｄモデルの手を前に出しているアニメーション( ５番目のアニメーション )をアタッチする
	AttachIndex2 = MV1AttachAnim( ModelHandle, 5, -1, FALSE ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// ４番目のアニメーションから５番目のアニメーションに徐々に移行する
	for( Rate = 0.0f ; Rate ClearDrawScreen() ;

		// 立っているアニメーションのブレンド率をセット
		MV1SetAttachAnimBlendRate( ModelHandle, AttachIndex1, 1.0f - Rate ) ;

		// 手を前に出しているアニメーションのブレンド率をセット
		MV1SetAttachAnimBlendRate( ModelHandle, AttachIndex2, Rate ) ;

		// モデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映する
		ScreenFlip() ;
	}

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetAttachAnimBlendRate( int MHandle, int AttachIndex ) ;

概略 アタッチしているアニメーションのブレンド率を取得する

引数   int MHandle ： モデルのハンドル
int AttachIndex ： ブレンド率を取得するアニメーションのアタッチ番号
戻り値 アニメーションに設定されているブレンド率

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションのブレンド率を取得します。
MV1SetAttachAnimBlendRate でセットした値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1GetAttachAnim( int MHandle, int AttachIndex ) ;

概略 アタッチしているアニメーションのアニメーション番号を取得する

引数   int MHandle ： モデルのハンドル
int AttachIndex ： アニメーション番号を取得するアニメーションのアタッチ番号
戻り値 アタッチしているアニメーションの番号

解説  　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの番号を取得します。
MV1AttachAnim の第二引数( int AnimIndex )で渡した値がそのまま返ってきます。

具体的な用途は思いつきませんが、必要になることがあるような気がするので追加しました。

サンプル

ありません



宣言 int MV1GetAnimNum( int MHandle ) ;

概略 アニメーションの数を取得する

引数   int MHandle ： モデルのハンドル
戻り値 －１以外：モデルに含まれるアニメーションの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるアニメーションの総数を取得します。

サンプル

　　モデルファイル DxChara.x に含まれるアニメーションの一覧を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AnimNum, i ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// モデルに含まれるアニメーションの数を取得する
	AnimNum = MV1GetAnimNum( ModelHandle ) ;

	// アニメーションの一覧を描画する
	for( i = 0 ; i DrawFormatString( 0, i * 16, GetColor( 255,255,255 ),
			"No:%d Name:%s Time:%f",
			i,
			MV1GetAnimName( ModelHandle, i ),
			MV1GetAnimTotalTime( ModelHandle, i ) ) ;
	}

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 const char *MV1GetAnimName( int MHandle, int AnimIndex ) ;

概略 指定番号のアニメーション名を取得する

引数   int MHandle ： モデルのハンドル
int AnimIndex ： アニメーション名を取得したいアニメーションの番号
戻り値 NULL以外：指定番号のアニメーション名
　 NULL：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるアニメーションの名前を取得します。

　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。

サンプル

　MV1GetAnimNum関数 のサンプルを参照してください。



宣言 MV1GetAnimIndex( int MHandle, char *AnimName ) ;

概略 指定名のアニメーション番号を取得する

引数   int MHandle ： モデルのハンドル
char *AnimName ： 番号を取得したいアニメーションの名前
戻り値 －１以外：アニメーション番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれる指定名を持つアニメーションの番号を取得します。

　名前からアニメーション番号を検索したい場合に使用します。

サンプル

　　モデルファイル DxChara.x に含まれる Animation_2 という名前のアニメーションを再生します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, AnimIndex, AttachIndex ;
	float TotalTime, PlayTime ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// Animation_2 という名前のアニメーションの番号を取得する
	AnimIndex = MV1GetAnimIndex( ModelHandle, "Animation_2" ) ;

	// 取得したアニメーション番号のアニメーションをアタッチする
	AttachIndex = MV1AttachAnim( ModelHandle, AnimIndex, -1, FALSE ) ;

	// アタッチしたアニメーションの総再生時間を取得する
	TotalTime = MV1GetAttachAnimTotalTime( ModelHandle, AttachIndex ) ;

	// 再生時間の初期化
	PlayTime = 0.0f ;

	// 何かキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 再生時間を進める
		PlayTime += 100.0f ;

		// 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
		if( PlayTime >= TotalTime )
		{
			PlayTime = 0.0f ;
		}

		// 再生時間をセットする
		MV1SetAttachAnimTime( ModelHandle, AttachIndex, PlayTime ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetAnimTotalTime( int MHandle, int AnimIndex ) ;

概略 指定番号のアニメーションの総時間を得る

引数   int MHandle ： モデルのハンドル
int AnimIndex ： 総時間を取得したいアニメーションの番号
戻り値 －１．０ｆ以外：指定番号のアニメーションの総時間
　 －１．０ｆ：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるアニメーションの総時間を取得します。

サンプル

　MV1GetAnimNum関数 のサンプルを参照してください。



マテリアル関係

宣言 int MV1GetMaterialNum( int MHandle ) ;

概略 モデルで使用しているマテリアルの数を取得する

引数   int MHandle ： モデルのハンドル
戻り値 －１以外：モデルに含まれるマテリアルの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの総数を取得します。

サンプル

　　モデルファイル DxChara.x に含まれるアニメーションの情報を一つづつ描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, MaterialNum, i ;
	COLOR_F Color ;
	char *Name ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// モデルに含まれるマテリアルの数を取得する
	MaterialNum = MV1GetMaterialNum( ModelHandle ) ;

	// マテリアルの情報を一つづつ描画する
	for( i = 0 ; i ClearDrawScreen() ;

		// マテリアルの名前を描画
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),  "Name            %s", MV1GetMaterialName( ModelHandle, i ) ) ;

		// マテリアルのディフューズカラーを描画
		Color = MV1GetMaterialDifColor( ModelHandle, i ) ;
		DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Diffuse  Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

		// マテリアルのスペキュラカラーを描画
		Color = MV1GetMaterialSpcColor( ModelHandle, i ) ;
		DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Specular Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

		// マテリアルのエミッシブカラーを描画
		Color = MV1GetMaterialEmiColor( ModelHandle, i ) ;
		DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Emissive Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

		// マテリアルのアンビエントカラーを描画
		Color = MV1GetMaterialAmbColor( ModelHandle, i ) ;
		DrawFormatString( 0, 64, GetColor( 255,255,255 ), "Ambient  Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

		// マテリアルのスペキュラの強さ描画
		DrawFormatString( 0, 80, GetColor( 255,255,255 ), "Specular Power  %f", MV1GetMaterialSpcPower( ModelHandle, i ) ) ;

		// 描画ブレンドモードの描画
		switch( MV1GetMaterialDrawBlendMode( ModelHandle, i ) )
		{
		case DX_BLENDMODE_NOBLEND : Name = "DX_BLENDMODE_NOBLEND" ; break ;
		case DX_BLENDMODE_ALPHA   : Name = "DX_BLENDMODE_ALPHA"   ; break ;
		case DX_BLENDMODE_ADD     : Name = "DX_BLENDMODE_ADD"     ; break ;
		case DX_BLENDMODE_SUB     : Name = "DX_BLENDMODE_SUB"     ; break ;
		case DX_BLENDMODE_INVSRC  : Name = "DX_BLENDMODE_INVSRC"  ; break ;
		case DX_BLENDMODE_MULA    : Name = "DX_BLENDMODE_MULA"    ; break ;
		}
		DrawFormatString( 0, 96, GetColor( 255,255,255 ), "Draw Blend Mode   %s", Name ) ;

		// 描画ブレンドパラメータの描画
		DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Draw Blend Param  %d", MV1GetMaterialDrawBlendParam( ModelHandle, i ) ) ;

		// キー入力待ち
		WaitKey() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 const char *MV1GetMaterialName( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルの名前を取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： 名前を取得したいマテリアルの番号
戻り値 NULL 以外：マテリアルの名前
　 NULL：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの名前を取得します。

　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。

サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialDifColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;

概略 指定のマテリアルのディフューズカラーを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： ディフューズカラーを変更するマテリアルの番号
COLOR_F Color ： ディフューズカラー( 拡散光色 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのディフューズカラー( 拡散光色 )を変更します。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のマテリアルのディフューズカラーを真っ赤にしてモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルのディフューズカラーを真っ赤にします
	MV1SetMaterialDifColor( ModelHandle, 0, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMaterialDifColor( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのディフューズカラーを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 ディフューズカラー
解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのディフューズカラー( 拡散光色 )を取得します。

　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。 ( 値の範囲は 0.0f ～ 1.0f ( ０％～１００％ ) )

サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialSpcColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;

概略 指定のマテリアルのスペキュラカラーを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： スペキュラカラーを変更するマテリアルの番号
COLOR_F Color ： スペキュラカラー( 拡散光色 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラカラー( 反射光色 )を変更します。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のマテリアルのスペキュラカラーを緑色にしてモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルのスペキュラカラーを緑にします
	MV1SetMaterialSpcColor( ModelHandle, 0, GetColorF( 0.0f, 1.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMaterialSpcColor( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのスペキュラカラーを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 スペキュラカラー
解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラカラー( 反射光色 )を取得します。

　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。 ( 値の範囲は 0.0f ～ 1.0f ( ０％～１００％ ) )

サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialEmiColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;

概略 指定のマテリアルのエミッシブカラーを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： エミッシブカラーを変更するマテリアルの番号
COLOR_F Color ： エミッシブカラー( 自己発光色 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのエミッシブカラー( 自己発光色 )を変更します。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のマテリアルのエミッシブカラーを暗い黄色にしてモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルのエミッシブカラーを暗い黄色にします
	MV1SetMaterialEmiColor( ModelHandle, 0, GetColorF( 0.2f, 0.2f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMaterialEmiColor( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのエミッシブカラーを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 エミッシブカラー
解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのエミッシブカラー( 自己発光色 )を取得します。

　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。 ( 値の範囲は 0.0f ～ 1.0f ( ０％～１００％ ) )

サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialAmbColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;

概略 指定のマテリアルのアンビエントカラーを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： アンビエントカラーを変更するマテリアルの番号
COLOR_F Color ： アンビエントカラー( 環境光色 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのアンビエントカラー( 環境光色 )を変更します。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のマテリアルのアンビエントカラーを紫色にしてモデルを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルのアンビエントカラーを紫色にします
	MV1SetMaterialAmbColor( ModelHandle, 0, GetColorF( 1.0f, 0.0f, 1.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMaterialAmbColor( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのアンビエントカラーを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 アンビエントカラー
解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのアンビエントカラー( 環境光色 )を取得します。

　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。 ( 値の範囲は 0.0f ～ 1.0f ( ０％～１００％ ) )

サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialSpcPower( int MHandle, int MaterialIndex, float Power ) ;

概略 指定のマテリアルのスペキュラの強さを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： スペキュラの強さを変更するマテリアルの番号
float Power ： スペキュラの強さ
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラの強さを変更します。

　具体的には反射する光の範囲が鋭くなります。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のマテリアルのスペキュラの強さを変更します。
　　( 変化がわかりにくいので、スペキュラカラーも明るくしています )
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルのスペキュラカラーを明るくします
	MV1SetMaterialSpcColor( ModelHandle, 0, GetColorF( 0.457f, 0.687f, 0.948f, 0.f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルのスペキュラの強さを 0.1f にします
	MV1SetMaterialSpcPower( ModelHandle, 0, 19.0f ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetMaterialSpcPower( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのスペキュラの強さを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 スペキュラの強さ
解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラの強さを取得します。

サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1GetMaterialDifMapTexture( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルでディフューズマップとして使用されているテクスチャ番号を取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 ０以上：テクスチャの番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのディフューズマップとして使用されているテクスチャの番号を取得します。
　取得した番号は関数 MV1GetTextureGraphHandle などの引数として使用します。 ( テクスチャの番号はモデルに含まれるテクスチャに振られる番号で、グラフィックハンドルではありませんのでご注意ください )

　モデルのテクスチャを変更したり利用したりしたいときに使用します。

サンプル

　　モデルファイル DxChara.x に含まれる４番目のマテリアルにディフューズテクスチャとして使用されている
　テクスチャの番号を取得して、そのテクスチャのグラフィックハンドルを取得して画面に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int TexIndex ;
	int GrHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// マテリアル番号４で使用されているテクスチャの番号を取得する
	TexIndex = MV1GetMaterialDifMapTexture( ModelHandle, 4 ) ;

	// モデルで使用されているテクスチャのグラフィックハンドルを取得する
	GrHandle = MV1GetTextureGraphHandle( ModelHandle, TexIndex ) ;

	// 取得したグラフィックハンドルを画面に描画する
	DrawGraph( 0, 0, GrHandle, TRUE ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMaterialSpcMapTexture( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルでスペキュラマップとして使用されているテクスチャ番号を取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 ０以上：テクスチャの番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラマップとして使用されているテクスチャの番号を取得します。
　取得した番号は関数 MV1GetTextureGraphHandle などの引数として使用します。 ( テクスチャの番号はモデルに含まれるテクスチャに振られる番号で、グラフィックハンドルではありませんのでご注意ください )

　モデルのテクスチャを変更したり利用したりしたいときに使用します。

サンプル

　　マテリアルで使用されているテクスチャを画面に描画するサンプルが MV1GetMaterialDifMapTexture 関数 にあります。



宣言 int MV1GetMaterialNormalMapTexture( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルで法線マップとして使用されているテクスチャ番号を取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 ０以上：テクスチャの番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの法線マップとして使用されているテクスチャの番号を取得します。
　取得した番号は関数 MV1GetTextureGraphHandle などの引数として使用します。 ( テクスチャの番号はモデルに含まれるテクスチャに振られる番号で、グラフィックハンドルではありませんのでご注意ください )

　モデルのテクスチャを変更したり利用したりしたいときに使用します。

サンプル

　　マテリアルで使用されているテクスチャを画面に描画するサンプルが MV1GetMaterialDifMapTexture 関数 にあります。



宣言 int MV1SetMaterialDrawBlendMode( int MHandle, int MaterialIndex, int BlendMode ) ;

概略 指定のマテリアルの描画ブレンドモードを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
int BlendMode ： 描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのブレンドモードを変更します。
　現在モデル描画で正常に動作するブレンドモードは DX_BLENDMODE_ALPHA, DX_BLENDMODE_ADD の２種類のみです。 ( ハードウエアが対応している場合は DX_BLENDMODE_SUB も正常に機能します )
　ブレンドモードの説明に関しては SetDrawBlendMode 関数の解説を参照してください。

　ブレンドモードのパラメータの変更は MV1SetMaterialDrawBlendParam 関数を使用します。

サンプル

　　モデルファイル DxChara.x に含まれる１番目のマテリアルの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 0,0,255 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる１番目のマテリアルの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
	MV1SetMaterialDrawBlendMode( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMaterialDrawBlendMode( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルの描画ブレンドモードを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの描画ブレンドモードを取得します。


サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialDrawBlendParam( int MHandle, int MaterialIndex, int BlendParam ) ;

概略 指定のマテリアルの描画ブレンドパラメータを変更する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
int BlendParame ： 描画ブレンドパラメータ( 0 ～ 255 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのブレンドパラメータを変更します。
( ブレンドパラメータの説明に関しては SetDrawBlendMode 関数の解説を参照してください )

　尚、ブレンドモードの変更は MV1SetMaterialDrawBlendMode 関数を使用してください。

サンプル

　　モデルファイル DxChara.x に含まれる１番目のマテリアルの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更して、 ブレンドパラメータを128にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 0,0,255 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のマテリアルの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
	MV1SetMaterialDrawBlendMode( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

	// マテリアルのブレンドパラメータを 128 に変更する
	MV1SetMaterialDrawBlendParam( ModelHandle, 1, 128 ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMaterialDrawBlendParam( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルの描画ブレンドパラメータを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 描画ブレンドパラメータ( 0 ～ 255 )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの描画ブレンドパラメータを取得します。


サンプル

　MV1GetMaterialNum関数 のサンプルを参照してください。



宣言 int MV1SetMaterialOutLineWidth( int MHandle, int MaterialIndex, float Width ) ;

概略 指定のマテリアルのトゥーンレンダリングで使用する輪郭線の太さを設定する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
float Width ： 輪郭線の太さ
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの立体的な( カメラとモデルとの距離に影響される )輪郭線の太さを変更します。
　輪郭線は pmd ファイルを読み込んだ場合に表示されます。


＜＜輪郭線の太さ決定の仕組み＞＞

　輪郭線は立体的な太さ( MV1SetMaterialOutLineWidth で指定する太さ )と、平面的な太さ( MV1SetMaterialOutLineDotWidth で指定する太さ )の二種類があります。
　立体的な太さはカメラとモデルとの距離で実際に画面に描画される輪郭線の太さが変化します。( 離れれば離れるほど細く、近づけば近づくほど太く )
　平面的な太さはカメラとモデルとの距離に関係なく常に一定の太さで描画されます。

　ＤＸライブラリでは、立体的・平面的の両方の計算で太さを求め、より太い結果の太さを用いて輪郭線を描画します。
　これは「近づけば近づくほど輪郭線は太くなって欲しいけど、どれだけ離れても最低限の太さで輪郭線を描画したい」 という処理を実現するためにこうなりました。

　尚、より太い計算結果を採用する関係で、輪郭線を描画したくない場合は MV1SetMaterialOutLineWidth と MV1SetMaterialOutLineDotWidth の両方で太さを 0.0f に設定する必要があります。

　また、MV1SetScale でモデルのスケールを変更するとこのパラメータにもスケーリングが掛かってしまいますので注意してください。
サンプル

　　ありません



宣言 float MV1GetMaterialOutLineWidth( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのトゥーンレンダリングで使用する輪郭線の太さを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 輪郭線の太さ
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの立体的な輪郭線の太さを取得します。

　　　輪郭線の太さの詳細は MV1SetMaterialOutLineWidth の解説を参照してください。
サンプル

　　ありません



宣言 int MV1SetMaterialOutLineDotWidth( int MHandle, int MaterialIndex, float Width ) ;

概略 指定のマテリアルのトゥーンレンダリングで使用する輪郭線のドット単位の太さを設定する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
float Width ： 輪郭線の太さ
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの平面的な( カメラとモデルとの距離に影響されない )輪郭線の太さを変更します。
　輪郭線は pmd ファイルを読み込んだ場合に表示されます。

　　　輪郭線の太さの詳細は MV1SetMaterialOutLineWidth の解説を参照してください。
サンプル

　　ありません



宣言 float MV1GetMaterialOutLineDotWidth( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのトゥーンレンダリングで使用する輪郭線のドット単位の太さを取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 輪郭線の太さ
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの平面的な輪郭線の太さを取得します。

　　　輪郭線の太さの詳細は MV1SetMaterialOutLineWidth の解説を参照してください。
サンプル

　　ありません



宣言 int MV1SetMaterialOutLineColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;

概略 指定のマテリアルのトゥーンレンダリングで使用する輪郭線の色を設定する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
COLOR_F Color ： 輪郭線の色
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの輪郭線の色を変更します。デフォルトの輪郭線の色は真っ黒 GetColorF( 0.0f, 0.0f, 0.0f, 1.0f ) です。
　色の値の取得は GetColorF を使うと便利です。
　尚、輪郭線は pmd ファイルを読み込んだ場合に表示されます。

サンプル

　　ありません



宣言 COLOR_F MV1GetMaterialOutLineColor( int MHandle, int MaterialIndex ) ;

概略 指定のマテリアルのトゥーンレンダリングで使用する輪郭線の色を取得する

引数   int MHandle ： モデルのハンドル
int MaterialIndex ： マテリアルの番号
戻り値 輪郭線の色
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの輪郭線の色を取得します。

　基本的に MV1SetMaterialOutLineColor で設定した値を返すだけの関数です。
サンプル

　　ありません





テクスチャ関係

宣言 int MV1GetTextureNum( int MHandle ) ;

概略 モデルで使用されているテクスチャの数を取得する

引数   int MHandle ： モデルのハンドル
戻り値 －１以外：モデルで使用されているテクスチャの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用されているテクスチャの総数を取得します。

サンプル

　　モデルファイル SimpleModel.mqo で使用されているテクスチャの情報を一つづつ描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int i, TextureNum ;
	int Width, Height, GrHandle ;
	const char *String ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// モデルに含まれるテクスチャの総数を取得する
	TextureNum = MV1GetTextureNum( ModelHandle ) ;

	// テクスチャの数だけ繰り返し
	for( i = 0 ; i ClearDrawScreen() ;

		// テクスチャのグラフィックハンドルを取得する
		GrHandle = MV1GetTextureGraphHandle( ModelHandle, i ) ;

		// テクスチャの名前を描画する
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),  "Name                  %s", MV1GetTextureName( ModelHandle, i ) ) ;

		// テクスチャの大きさを描画する
		GetGraphSize( GrHandle, &Width, &Height ) ;
		DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Size                  %dx%d", Width, Height ) ;

		// テクスチャのＵ値のアドレスモードを描画する
		switch( MV1GetTextureAddressModeU( ModelHandle, i ) )
		{
		case DX_TEXADDRESS_WRAP   : String = "DX_TEXADDRESS_WRAP" ;   break ;
		case DX_TEXADDRESS_MIRROR : String = "DX_TEXADDRESS_MIRROR" ; break ;
		case DX_TEXADDRESS_CLAMP  : String = "DX_TEXADDRESS_CLAMP" ;  break ;
		}
		DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Address Mode U        %s", String ) ;

		// テクスチャのＶ値のアドレスモードを描画する
		switch( MV1GetTextureAddressModeV( ModelHandle, i ) )
		{
		case DX_TEXADDRESS_WRAP   : String = "DX_TEXADDRESS_WRAP" ;   break ;
		case DX_TEXADDRESS_MIRROR : String = "DX_TEXADDRESS_MIRROR" ; break ;
		case DX_TEXADDRESS_CLAMP  : String = "DX_TEXADDRESS_CLAMP" ;  break ;
		}
		DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Address Mode V        %s", String ) ;

		// テクスチャのフィルタリングモードを描画する
		switch( MV1GetTextureSampleFilterMode( ModelHandle, i ) )
		{
		case DX_DRAWMODE_NEAREST :     String = "DX_DRAWMODE_NEAREST" ;     break ;
		case DX_DRAWMODE_BILINEAR :    String = "DX_DRAWMODE_BILINEAR" ;    break ;
		case DX_DRAWMODE_ANISOTROPIC : String = "DX_DRAWMODE_ANISOTROPIC" ; break ;
		}
		DrawFormatString( 0, 64, GetColor( 255,255,255 ), "Sample Filter Mode    %s", String ) ;

		// テクスチャを描画する
		DrawGraph( 0, 80, GrHandle, TRUE ) ;

		// キー入力待ち
		WaitKey() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 const char *MV1GetTextureName( int MHandle, int TexIndex ) ;

概略 テクスチャの名前を取得する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
戻り値 NULL以外：テクスチャの名前( ファイルパスではありません )
　 NULL：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用されているテクスチャの名前を取得します。
　xファイル や mqoファイルではテクスチャの名前という情報が無いので、 ファイル名がテクスチャの名前として使用されます。


サンプル

　MV1GetTextureNum関数 のサンプルを参照してください。



宣言 int MV1SetTextureGraphHandle( int MHandle, int TexIndex, int GrHandle, int SemiTransFlag ) ;

概略 テクスチャとして使用するグラフィックハンドルを変更する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
int GrHandle ： テクスチャとして使用するグラフィックハンドル
int SemiTransFlag ： グラフィックハンドルに半透明要素があるかどうか( TRUE：ある FALSE：ない )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用するテクスチャのグラフィックハンドルを変更します。
　変更後はモデル中の変更されたテクスチャを使用しているマテリアルの部分が GrHandle で指定した画像になります。
　色違いキャラクターを表現したりする場合に便利です。

　尚、３Ｄモデルは半透明要素があるかどうかの情報をよく使いますので、 セットするグラフィックハンドルに半透明の部分があるかどうかを SemiTransFlag で指定します、ある場合は TRUE を、無い場合は FALSE を渡してください。

　注意点として、GrHandle に渡すグラフィックハンドルの画像の幅や高さは 2 の n乗( 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 ... ) である必要があり、また、LoadDivGraph で分割読込した画像や、DerivationGraph で派生させた画像は使用することができません。 ( エラーにはなりませんが期待する描画結果は得られません )

　画像のサイズについては、グラフィックスデバイスの性能によって扱える画像の最大サイズが変化しますので。
　2009年時点で多くの環境で安心して使える画像の最大サイズは恐らく 2048 くらいまで、 ３Ｄ機能を持ち始めたばかりのノートパソコン等では 1024 くらいまでの対応となります。

　因みに、GrHandle に -1 を渡すと元のテクスチャのグラフィックハンドルを使用するようになります。

サンプル

　　モデルファイル DxChara.x で使用されている目のテクスチャを緑色の目の画像に変更します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int GrHandle ;
	int TexIndex ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() LoadGraph( "DxCharaEye2.tga" ) ;

	// ３Ｄモデルの読み込み
	ModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// モデルを画面に映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 400.0f ) ) ;

	// 目の部分のマテリアルで使用されているテクスチャの番号を取得
	TexIndex = MV1GetMaterialDifMapTexture( ModelHandle, 4 ) ;

	// テクスチャで使用するグラフィックハンドルを変更する
	MV1SetTextureGraphHandle( ModelHandle, TexIndex, GrHandle, FALSE ) ;

	// モデルを描画する
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetTextureGraphHandle( int MHandle, int TexIndex ) ;

概略 テクスチャのグラフィックハンドルを取得する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
戻り値 －１以外：テクスチャのグラフィックハンドル
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用されているテクスチャで使用されるグラフィックハンドルを取得します。
　取得したグラフィックハンドルは普通のグラフィックハンドルと同じように DrawGraph で描画したり、 GetGraphSize でサイズを取得したりすることができます。


サンプル

　MV1GetTextureNum関数 のサンプルを参照してください。



宣言 int MV1SetTextureAddressMode( int MHandle, int TexIndex, int AddrUMode, int AddrVMode ) ;

概略 テクスチャのアドレスモードを変更する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
int AddrUMode ： Ｕ値のアドレスモード
int AddrVMode ： Ｖ値のアドレスモード
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用するテクスチャを描画する際に使用されるアドレスモードを変更します。

　アドレスモードとは画像サイズ以上のテクスチャ座標が指定された場合にどう表示するかというもので、以下の３種類があります。


DX_TEXADDRESS_WRAP

　画像サイズ以上のテクスチャ座標の部分は素直に繰り返します。


DX_TEXADDRESS_MIRROR

　画像サイズ以上のテクスチャ座標の部分は鏡に映されたように反転する表示と、もとの反転していない表示とを繰り返します。
　例えば４倍のテクスチャ座標が指定された場合　通常の見た目・反転した見た目・通常の見た目・反転した見た目　という風になります。


DX_TEXADDRESS_CLAMP

　他のモードと違って画像が繰り返されず、画像サイズ以上のテクスチャ座標の部分は画像の端のピクセルが引き伸ばされたような見た目になります。


　アドレスモードはＵ方向とＶ方向で別々に指定することができます。
　初期状態ではＵ，Ｖ共に DX_TEXADDRESS_WRAP です。

サンプル

　　モデルファイル AddressTest.mqo で使用されているテクスチャのアドレスモードを、横方向は DX_TEXADDRESS_MIRROR に
　縦方向は DX_TEXADDRESS_CLAMP にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "AddressTest.mqo" ) ;

	// モデルを画面に映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 400.0f ) ) ;

	// テクスチャ０番のアドレスモードを横方向は DX_TEXADDRESS_MIRROR に、
	// 縦方向は DX_TEXADDRESS_CLAMP に変更する
	MV1SetTextureAddressMode( ModelHandle, 0, DX_TEXADDRESS_MIRROR, DX_TEXADDRESS_CLAMP ) ;

	// モデルを描画する
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetTextureAddressModeU( int MHandle, int TexIndex ) ;

概略 テクスチャのＵ値のアドレスモードを取得する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
戻り値 －１以外：テクスチャのＵ値のアドレスモード
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用されているテクスチャを描画する際に使用されるＵ値のアドレスモードを取得します。
　戻り値であるアドレスモードについては関数 MV1SetTextureAddressMode の解説を参照してください。


サンプル

　MV1GetTextureNum関数 のサンプルを参照してください。



宣言 int MV1GetTextureAddressModeV( int MHandle, int TexIndex ) ;

概略 テクスチャのＶ値のアドレスモードを取得する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
戻り値 －１以外：テクスチャのＶ値のアドレスモード
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用されているテクスチャを描画する際に使用されるＶ値のアドレスモードを取得します。
　戻り値であるアドレスモードについては関数 MV1SetTextureAddressMode の解説を参照してください。


サンプル

　MV1GetTextureNum関数 のサンプルを参照してください。



宣言 int MV1SetTextureSampleFilterMode( int MHandle, int TexIndex, int FilterMode ) ;

概略 テクスチャのフィルタリングモードを変更する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
int FilterMode ： フィルタリングモード
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用するテクスチャを描画する際に使用されるフィルタリングモードを変更します。

　フィルタリングモードはポリゴンに貼り付けられ、変形して画面に表示されることになるテクスチャをどのように描画するかと言うもので、以下の３種類があります。


DX_DRAWMODE_NEAREST

　最近点フィルタリング方式です。
　画面にピクセルを描画する際に、テクスチャ中の計算上一番適している１ピクセルのみを使って描画します。
　画面にテクスチャの解像度以上の大きさに描画されるとドットが四角く表示されます。

DX_DRAWMODE_BILINEAR

　線形フィルタリング方式です。
　画面にピクセルを描画する際に、テクスチャ中の計算上適している上位４ピクセルの色を合成して描画します。
　画面にテクスチャの解像度以上の大きさに描画されると、 ドット同士の色の合成が行われるので DX_DRAWMODE_NEAREST と違いボヤっとした見た目になります。

DX_DRAWMODE_ANISOTROPIC

　異方性フィルタリング方式です。
　画面に描画するピクセルの色を複雑な計算をして決定します。
　画面に拡大されて描画される際は DX_DRAWMODE_BILINEAR とあまり違いはありませんが、 画面に元の画像よりも小さく、つまり縮小されて描画される場合は DX_DRAWMODE_BILINEAR より良好な描画結果が得られます。( デフォルトではこのタイプです )


　因みに描画負荷は DX_DRAWMODE_ANISOTROPIC が一番重く、 次に DX_DRAWMODE_BILINEAR、一番軽いのは DX_DRAWMODE_NEAREST です。

サンプル

　　モデルファイル FilterTest.mqo で使用されているテクスチャのフィルタリングモードを DX_DRAWMODE_NEAREST にして描画します。
　　ドットとドットの間がくっきり分かれた見た目になります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "FilterTest.mqo" ) ;

	// モデルを画面に映る位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 400.0f ) ) ;

	// テクスチャ０番のフィルタリングモードを DX_DRAWMODE_NEAREST に変更
	MV1SetTextureSampleFilterMode( ModelHandle, 0, DX_DRAWMODE_NEAREST ) ;

	// モデルを描画する
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetTextureSampleFilterMode( int MHandle, int TexIndex ) ;

概略 テクスチャのフィルタリングモードを取得する

引数   int MHandle ： モデルのハンドル
int TexIndex ： テクスチャの番号
戻り値 －１以外：テクスチャのフィルタリングモード
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルで使用されているテクスチャを描画する際に使用されるフィルタリングモードを取得します。
　戻り値であるアドレスモードについては関数 MV1SetTextureSampleFilterMode の解説を参照してください。


サンプル

　MV1GetTextureNum関数 のサンプルを参照してください。



フレーム関係

宣言 int MV1GetFrameNum( int MHandle ) ;

概略 フレームの数を取得する

引数   int MHandle ： モデルのハンドル
戻り値 －１以外：モデルに含まれるフレームの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの数を取得します。

サンプル

　　モデルファイル DxChara.x に含まれるフレームの情報を一つづつ表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, FrameNum, i, Parent ;
	VECTOR Position ;
	MATRIX Matrix ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// フレームの数を取得する
	FrameNum = MV1GetFrameNum( ModelHandle ) ;

	// フレームの数だけループ
	for( i = 0 ; i ClearDrawScreen() ;

		// フレーム名の描画
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),      "Name         %s", MV1GetFrameName( ModelHandle, i ) ) ;

		// 親フレーム名の描画
		Parent = MV1GetFrameParent( ModelHandle, i ) ;
		if( Parent == -2 )
		{
			DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Parent Name  None" ) ;
		}
		else
		{
			DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Parent Name  %s", MV1GetFrameName( ModelHandle, Parent ) ) ;
		}

		// 子フレームの数を描画
		DrawFormatString( 0, 32, GetColor( 255,255,255 ),     "Child Num    %d", MV1GetFrameChildNum( ModelHandle, i ) ) ;

		// フレームのワールド座標の描画
		Position = MV1GetFramePosition( ModelHandle, i ) ;
		DrawFormatString( 0, 48, GetColor( 255,255,255 ),     "Position     x:%f y:%f z:%f", Position.x, Position.y, Position.z ) ;

		// 変換行列を描画する
		Matrix = MV1GetFrameLocalMatrix( ModelHandle, i ) ;
		DrawFormatString( 0, 64,  GetColor( 255,255,255 ),    "   Matrix    %f %f %f %f", Matrix.m[ 0 ][ 0 ], Matrix.m[ 0 ][ 1 ], Matrix.m[ 0 ][ 2 ], Matrix.m[ 0 ][ 3 ] ) ;
		DrawFormatString( 0, 80,  GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 1 ][ 0 ], Matrix.m[ 1 ][ 1 ], Matrix.m[ 1 ][ 2 ], Matrix.m[ 1 ][ 3 ] ) ;
		DrawFormatString( 0, 96,  GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 2 ][ 0 ], Matrix.m[ 2 ][ 1 ], Matrix.m[ 2 ][ 2 ], Matrix.m[ 2 ][ 3 ] ) ;
		DrawFormatString( 0, 112, GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 3 ][ 0 ], Matrix.m[ 3 ][ 1 ], Matrix.m[ 3 ][ 2 ], Matrix.m[ 3 ][ 3 ] ) ;

		// フレームのローカル座標からワールド座標に変換する行列を描画する
		Matrix = MV1GetFrameLocalWorldMatrix( ModelHandle, i ) ;
		DrawFormatString( 0, 128,  GetColor( 255,255,255 ),   "LW Matrix    %f %f %f %f", Matrix.m[ 0 ][ 0 ], Matrix.m[ 0 ][ 1 ], Matrix.m[ 0 ][ 2 ], Matrix.m[ 0 ][ 3 ] ) ;
		DrawFormatString( 0, 144,  GetColor( 255,255,255 ),   "             %f %f %f %f", Matrix.m[ 1 ][ 0 ], Matrix.m[ 1 ][ 1 ], Matrix.m[ 1 ][ 2 ], Matrix.m[ 1 ][ 3 ] ) ;
		DrawFormatString( 0, 160,  GetColor( 255,255,255 ),   "             %f %f %f %f", Matrix.m[ 2 ][ 0 ], Matrix.m[ 2 ][ 1 ], Matrix.m[ 2 ][ 2 ], Matrix.m[ 2 ][ 3 ] ) ;
		DrawFormatString( 0, 176, GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 3 ][ 0 ], Matrix.m[ 3 ][ 1 ], Matrix.m[ 3 ][ 2 ], Matrix.m[ 3 ][ 3 ] ) ;

		// フレームの表示状態を描画
		DrawFormatString( 0, 192, GetColor( 255,255,255 ),    "Visible      %d", MV1GetFrameVisible( ModelHandle, i ) ) ;

		// フレームに半透明要素があるかどうかを描画
		DrawFormatString( 0, 208, GetColor( 255,255,255 ),    "Semi Trans   %d", MV1GetFrameSemiTransState( ModelHandle, i ) ) ;

		// フレームに含まれるメッシュの数を描画
		DrawFormatString( 0, 224, GetColor( 255,255,255 ),    "Mesh Num     %d", MV1GetFrameMeshNum( ModelHandle, i ) ) ;

		// フレームに含まれる三角形ポリゴンの数を描画
		DrawFormatString( 0, 240, GetColor( 255,255,255 ),    "Triangle Num %d", MV1GetFrameTriangleNum( ModelHandle, i ) ) ;

		// キーの入力待ち
		WaitKey() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SearchFrame( int MHandle, char *FrameName ) ;

概略 指定名のフレームをモデル中から検索する

引数   int MHandle ： モデルのハンドル
char *FrameName ： フレーム名
戻り値 ０以上：指定名のフレームの番号
　  －２：指定名のフレームが見つからなかった
　  －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームから、指定の名前のものを検索します。

　同名のフレームが含まれる場合は番号の若いフレームが返ってきます。

サンプル

　　モデルファイル DxChara.x に含まれる名前が Mesh_1 のフレームの番号を表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// フレーム名 Mesh_1 のフレームの番号を画面に描画する
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "%d", MV1SearchFrame( ModelHandle, "Mesh_1" ) ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SearchFrameChild( int MHandle, int FrameIndex, char *ChildName ) ;

概略 指定名のフレームを指定のフレームの子フレームの中から検索する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： 検索対象のフレームの番号
char *ChildName ： フレーム名
戻り値 ０以上：指定名のフレームの番号
　  －２：指定名のフレームが見つからなかった
　  －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデル内の指定のフレームが持つ子フレームの中から、指定の名前のフレームを検索します。

　指定のフレームが持つ子フレームだけではなく、子フレームが持つ子フレームも検索の対象になります。
　同名のフレームが含まれる場合は番号の若いフレームが返ってきます。

サンプル

　　モデルファイル DxChara.x に含まれる２番目のフレームの子フレームの中から Koshi という名前のフレームの番号を検索します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// モデルの２番目のフレームが持つ子フレームの中から AnkleR という名前のフレームの番号を検索して画面に描画する
	DrawFormatString( 0, 0, GetColor( 255,255,255 ), "%d", MV1SearchFrameChild( ModelHandle, 2, "AnkleR" ) ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 char *MV1GetFrameName( int MHandle, int FrameIndex ) ;

概略 フレームの名前を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 NULL以外：フレームの名前
　 NULL：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの名前を取得します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 int MV1GetFrameParent( int MHandle, int FrameIndex ) ;

概略 フレームの親フレームを取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 ０以上：親フレームの番号
　 －２：親フレームが無い
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの親フレームのフレーム番号を取得します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 int MV1GetFrameChildNum( int MHandle, int FrameIndex ) ;

概略 フレームの子フレームの数を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 ０以上：子フレームの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームが持つ子フレームの数を取得します。

　FrameIndex を -1 にすると親が居ないフレームの数が返ってきます。

サンプル

　　モデルファイル DxChara.x に含まれる０番目のフレームの子フレームの名前を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, i, ChildNum, FrameIndex ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// フレーム０番の子フレームの数を取得
	ChildNum = MV1GetFrameChildNum( ModelHandle, 0 ) ;

	// 子フレームの数だけループ
	for( i = 0 ; i MV1GetFrameChild( ModelHandle, 0, i ) ;

		// 子フレームの名前を表示
		DrawFormatString( 0, i * 16, GetColor( 255,255,255 ), "%s", MV1GetFrameName( ModelHandle, FrameIndex ) ) ;
	}

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetFrameChild( int MHandle, int FrameIndex, int ChildIndex ) ;

概略 フレームの子フレームを取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
int ChildIndex ： 子フレーム番号
戻り値 ０以上：子フレームのフレーム番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームが持つ子フレームのフレーム番号を取得します。

　FrameIndex を -1 にすると、親の居ないフレームが取得できます。

　尚、ChildIndex に MV1GetFrameChildNum 関数で取得できる子フレームの数以上の値を渡すとエラーとなります。

サンプル

　MV1GetFrameChildNum関数 のサンプルを参照してください。



宣言 VECTOR MV1GetFramePosition( int MHandle, int FrameIndex ) ;

概略 フレームの座標を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームのワールド座標
解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームのワールド座標を取得します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 MATRIX MV1GetFrameLocalMatrix( int MHandle, int FrameIndex ) ;

概略 フレームの座標変換行列を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームの変換行列
解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの変換行列を取得します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 MATRIX MV1GetFrameLocalWorldMatrix( int MHandle, int FrameIndex ) ;

概略 フレームのローカル座標からワールド座標に変換する行列を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームのローカル→ワールド行列

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームのローカル座標からワールド座標に変換する行列を取得します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 int MV1SetFrameUserLocalMatrix( int MHandle, int FrameIndex, MATRIX Matrix ) ;

概略 フレームの座標変換行列を設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
MATRIX Matrix ： フレームに設定する変換行列
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの変換行列として引数で渡す Matrix の値を使用するようにします。

　この関数を使用して行列を設定すると、 以降 MV1ResetFrameUserLocalMatrix で設定が解除されるまでこの関数で設定した行列が使用されます。 ( 行列を設定したフレームに対するキーが打たれているアニメーションを再生しても、 この関数で設定した行列が優先されます )

サンプル

　　モデルファイル SimpleModel.mqo に含まれる２番目のフレームの変換行列を下方向に 300.0f 移動する
　行列にしてから描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// モデルを見える位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 800.0f ) ) ;

	// ２番目のフレームに下に動くのローカル行列をセットする
	MV1SetFrameUserLocalMatrix( ModelHandle, 2, MGetTranslate( VGet( 0.0f, -300.0f, 0.0f ) ) ) ; 

	// モデルを描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1ResetFrameUserLocalMatrix( int MHandle, int FrameIndex ) ;

概略 フレームの座標変換行列をデフォルトに戻す

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 　０：成功
　 －１：エラー発生

解説  　関数 MV1SetFrameUserLocalMatrix で設定した行列の効果を解除します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる２番目のフレームの変換行列を下方向に 300.0f 移動する
　行列をセットしたり解除したりを１秒単位で行いつつ描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, Time, UseMatrix ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// モデルを見える位置に移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 800.0f ) ) ;

	// 行列を使用するかどうかのフラグを１にする
	UseMatrix = 1 ;

	// 現在のタイムカウントを記録しておく
	Time = GetNowCount() ;

	// 何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// １秒経つ毎に独自の行列を使用するかどうかを変更する
		if( GetNowCount() - Time > 1000 )
		{
			// フラグによって処理を分岐
			if( UseMatrix == 1 )
			{
				// ２番目のフレームに下に動くのローカル行列をセットする
				MV1SetFrameUserLocalMatrix( ModelHandle, 2, MGetTranslate( VGet( 0.0f, -300.0f, 0.0f ) ) ) ;

				// フラグを０にする
				UseMatrix = 0 ;
			}
			else
			{
				// ２番目のフレームに設定した行列を無効化する
				MV1ResetFrameUserLocalMatrix( ModelHandle, 2 ) ;

				// フラグを１にする
				UseMatrix = 1 ;
			}

			// 現在のタイムカウントを記録しておく
			Time = GetNowCount() ;
		}

		// モデルを描画
		MV1DrawModel( ModelHandle ) ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetFrameVisible( int MHandle, int FrameIndex, int VisibleFlag ) ;

概略 フレームの表示・非表示状態を変更する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
int VisibleFlag ： 表示状態( TRUE：表示　FALSE：非表示 )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの表示状態を変更します。

　VisibleFlag に FALSE を渡すと、指定のフレームが持つメッシュ、及び指定のフレームの子フレームが持つメッシュと子フレームの子フレームが持つメッシュも描画されなくなります。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームの表示状態を「非表示」にして描画します。
　「円柱」フレームの子フレームである「子円柱」も一緒に表示されなくなります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// １番のフレームの表示状態を「非表示」にする
	MV1SetFrameVisible( ModelHandle, 1, FALSE ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetFrameVisible( int MHandle, int FrameIndex ) ;

概略 フレームの表示・非表示状態を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 ０以上：フレームの表示状態( TRUE：表示 FALSE：非表示 )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるフレームの表示状態を取得します。

　親フレームの表示状態が仮に「非表示」になっていても、この関数はあくまで指定のフレームに設定されている表示状態を返します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 int MV1SetFrameDifColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;

概略 フレームのディフューズカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる３番目のフレームのディフューズカラーを赤にします。
　「立方体」フレームの子フレームである「子立方体」も一緒に赤色になります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// ３番のフレームのディフューズカラーを赤にする
	MV1SetFrameDifColorScale( ModelHandle, 3, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetFrameDifColorScale( int MHandle, int FrameIndex ) ;

概略 フレームのディフューズカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームのディフューズカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を取得します。

　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して MV1SetFrameDifColorScale 関数で設定された値をそのまま返します。

サンプル

ありません



宣言 int MV1SetFrameSpcColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;

概略 フレームのスペキュラカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームのスペキュラカラーを黄色にします。
　「円柱」フレームの子フレームである「子円柱」も一緒に黄色になります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// １番のフレームのスペキュラカラーを黄色にする
	MV1SetFrameSpcColorScale( ModelHandle, 1, GetColorF( 1.0f, 1.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetFrameSpcColorScale( int MHandle, int FrameIndex ) ;

概略 フレームのスペキュラカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームのスペキュラカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を取得します。

　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して MV1SetFrameSpcColorScale 関数で設定された値をそのまま返します。

サンプル

ありません



宣言 int MV1SetFrameEmiColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;

概略 フレームのエミッシブカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームのエミッシブカラーを水色にします。
　「円柱」フレームの子フレームである「子円柱」も一緒に水色になります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// １番のフレームのエミッシブカラーのスケール値を水色にする
	MV1SetFrameEmiColorScale( ModelHandle, 1, GetColorF( 0.0f, 1.0f, 1.0f, 0.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetFrameEmiColorScale( int MHandle, int FrameIndex ) ;

概略 フレームのエミッシブカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームのエミッシブカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を取得します。

　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して MV1SetFrameEmiColorScale 関数で設定された値をそのまま返します。

サンプル

ありません



宣言 int MV1SetFrameAmbColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;

概略 フレームのアンビエントカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームのアンビエントカラーを紫色にします。
　「円柱」フレームの子フレームである「子円柱」も一緒に水色になります。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// １番のフレームのアンビエントカラーのスケール値を紫色にする
	MV1SetFrameAmbColorScale( ModelHandle, 1, GetColorF( 1.0f, 0.0f, 1.0f, 0.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetFrameAmbColorScale( int MHandle, int FrameIndex ) ;

概略 フレームのアンビエントカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームのアンビエントカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を取得します。

　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して MV1SetFrameAmbColorScale 関数で設定された値をそのまま返します。

サンプル

ありません



宣言 int MV1GetFrameSemiTransState( int MHandle, int FrameIndex ) ;

概略 フレームに半透明要素があるかどうかを取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 TRUE：半透明要素がある　FALSE：半透明要素は無い
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに半透明の要素があるかどうかを取得します。

　例えば、フレーム内のメッシュが使用しているマテリアルのテクスチャに半透明の部分があったり、 指定のフレームや子フレームの何れかの不透明が 1.0f ではなかったりすると TRUE が返ってきます。

　半透明要素を持つフレーム同士をＺソートする場合に、各フレームに半透明要素があるかどうかを判定する際などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo の３番目のフレームの不透明度を上下キーで操作できるようにした上で、 画面上に MV1GetFrameSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float OpacityRate ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 100.0f, 600.0f ) ) ;

	// 不透明度を初期化
	OpacityRate = 1.0f ;

	// ESCキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面のクリア
		ClearDrawScreen() ;

		// 上キーが押されたら不透明度を上げる
		if( CheckHitKey( KEY_INPUT_UP ) )
		{
			OpacityRate += 0.05f ;
			if( OpacityRate > 1.0f )
			{
				OpacityRate = 1.0f ;
			}
		}

		// 下キーが押されたら不透明度を下げる
		if( CheckHitKey( KEY_INPUT_DOWN ) )
		{
			OpacityRate -= 0.05f ;
			if( OpacityRate MV1SetFrameOpacityRate( ModelHandle, 3, OpacityRate ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 現在の３番目のフレームの不透明度と、MV1GetFrameOpacityState の戻り値を描画する
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),
			"ESC Key:Exit OpacityRate:%f SemiTransState:%d",
			OpacityRate, MV1GetFrameSemiTransState( ModelHandle, 3 ) ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetFrameOpacityRate( int MHandle, int FrameIndex, float Rate ) ;

概略 フレームの不透明度を設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
float Rate ： 不透明度( 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームの不透明度を設定します。

　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、 1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。
　指定のフレームの子フレームにも影響を与えます。

　モデルの一部のフレームを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。

サンプル

　　モデルファイル SimpleModel.mqo の１番目のフレームの不透明度を５０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 255,0,0 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 100.0f, 600.0f ) ) ;

	// ３Ｄモデルの１番目のフレームの不透明度を50%にする
	MV1SetFrameOpacityRate( ModelHandle, 1, 0.5f ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetFrameOpacityRate( int MHandle, int FrameIndex ) ;

概略 フレームの不透明度を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 フレームに設定されている不透明度

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに設定されている不透明度を取得します。
　MV1SetFrameOpacityRate でセットした値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetFrameTextureAddressTransform( int MHandle, int FrameIndex, float TransU, float TransV, float ScaleU, float ScaleV, float RotCenterU, float RotCenterV, float Rotate ) ;

概略 フレームのテクスチャ座標変換パラメータを設定する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
float TransU ： テクスチャ座標のＵ値に加算する値( 初期値 0.0f )
float TransV ： テクスチャ座標のＶ値に加算する値( 初期値 0.0f )
float ScaleU ： テクスチャ座標のＵ値に掛ける値( 初期値 1.0f )
float ScaleV ： テクスチャ座標のＶ値に掛ける値( 初期値 1.0f )
float RotCenterU ： テクスチャ座標の回転中心となるＵ値( 初期値 0.0f )
float RotCenterV ： テクスチャ座標の回転中心となるＶ値( 初期値 0.0f )
float Rotate ： テクスチャ座標の回転値（ 単位はラジアン ）( 初期値 0.0f )
戻り値 　０：成功
　 －１：エラー発生

解説   　メッシュのテクスチャ座標に対して行う変換処理のパラメータを設定します。

　用途としては、例えばキャラクターの顔のテクスチャに複数の表情を予め描いておいて、 表情を変えたいタイミングでその表情が描かれているテクスチャ座標に TransU と TransV の引数を使用してメッシュに含まれる頂点のテクスチャ座標をスライドさせて描画される表情を変更する、などがあります。

尚、各引数の意味は上記の注釈の通りですが、パラメータによる演算が行われる順序は

１．RotCenterU, RotCenterV, Rotate による座標値の回転
２．TransU, TransV を座標値に加算
３．ScaleU, ScaleV による座標値の拡大

となります。
この関数による設定をリセットしたい場合は MV1ResetFrameTextureAddressTransform を使用してください。

サンプル

　　モデルファイル TexAddrTransfTest.mqo を約１秒毎にテクスチャ座標をずらしてアニメーションさせます。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int WaitCounter, ViewPattern ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "TexAddrTransfTest.mqo" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

	// 描画するパターンと、描画パターンを変更する間隔をカウントする変数の初期化
	ViewPattern = 0 ;
	WaitCounter = 0 ;

	// ＥＳＣキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 描画するパターンを変更する処理
		WaitCounter ++ ;
		if( WaitCounter == 60 )
		{
			WaitCounter = 0 ;

			// ６０フレーム経過したら描画パターンを変更
			ViewPattern ++ ;
			if( ViewPattern == 4 )
			{
				ViewPattern = 0 ;
			}
		}

		// 描画するパターンに応じてテクスチャ座標のＵ値をずらす値を変更
		MV1SetFrameTextureAddressTransform( ModelHandle, 0, 0.25f * ViewPattern, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f ) ;

		// モデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1ResetFrameTextureAddressTransform( int MHandle, int FrameIndex ) ;

概略 フレームのテクスチャ座標変換パラメータをリセットする

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 　０：成功
　 －１：エラー発生

解説   　関数 MV1SetFrameTextureAddressTransform で設定したテクスチャ座標変換パラメータを初期値にリセットします。 効果的には MV1SetFrameTextureAddressTransform 関数の引数を注釈に「初期値」として記載されている値を渡して呼んだ場合と同じです。

サンプル

ありません



宣言 int MV1GetFrameTriangleNum( int MHandle, int FrameIndex ) ;

概略 フレームに含まれるポリゴンの数を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 ０以上：三角形ポリゴンの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれる三角形ポリゴンの数を取得します。

サンプル

　MV1GetFrameNum関数 のサンプルを参照してください。



宣言 int MV1GetFrameMeshNum( int MHandle, int FrameIndex ) ;

概略 フレームが持つメッシュの数を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
戻り値 ０以上：フレームに含まれるメッシュの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュの数を取得します。

　この関数の戻り値には、子フレームが持つメッシュの数は含まれません。

サンプル

　　モデルファイル DxChara.x の１番目のフレームに含まれるメッシュの情報を表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, MeshNum, i, MeshIndex ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// １番目のフレームに含まれるメッシュの数を取得する
	MeshNum = MV1GetFrameMeshNum( ModelHandle, 1 ) ;

	// メッシュの数だけループ
	for( i = 0 ; i MV1GetFrameMesh( ModelHandle, 1, i ) ;

		// メッシュが使用しているマテリアルとメッシュに含まれる三角形ポリゴンの数を描画
		DrawFormatString( 0, i * 16, GetColor( 255,255,255 ), "Mesh No  %d   Material  %d    Triangle Polygon Num  %d",
			i, MV1GetMeshMaterial( ModelHandle, MeshIndex ), MV1GetMeshTriangleNum( ModelHandle, MeshIndex ) ) ;
	}

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetFrameMesh( int MHandle, int FrameIndex, int Index ) ;

概略 フレームの表示・非表示状態を取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： フレームの番号
int Index ： フレーム内メッシュの番号
戻り値 ０以上：メッシュの番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュの番号を取得します。

　Index に MV1GetFrameMeshNum 関数の戻り値以上の値を渡すとエラーになります。

サンプル

　MV1GetFrameMeshNum関数 のサンプルを参照してください。



メッシュ関係

宣言 int MV1GetMeshNum( int MHandle ) ;

概略 モデルに含まれるメッシュの数を取得する

引数   int MHandle ： モデルのハンドル
戻り値 ０以上：モデルに含まれるメッシュの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるメッシュの数を取得します。

サンプル

　　モデルファイル DxChara.x に含まれるメッシュの情報を表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle, MeshNum, i ;
	VECTOR Position ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// モデルに含まれるメッシュの数を取得する
	MeshNum = MV1GetMeshNum( ModelHandle ) ;

	// メッシュの数だけループ
	for( i = 0 ; i ClearDrawScreen() ;

		// メッシュが使用しているマテリアルの描画
		DrawFormatString( 0,  0, GetColor( 255,255,255 ),  "Material              %d", MV1GetMeshMaterial( ModelHandle, i ) ) ;

		// メッシュに含まれる三角形ポリゴンの数を描画
		DrawFormatString( 0, 16, GetColor( 255,255,255 ),  "Triangle Polygon Num  %d", MV1GetMeshTriangleNum( ModelHandle, i ) ) ;

		// メッシュの表示・非表示状態を描画
		DrawFormatString( 0, 32, GetColor( 255,255,255 ),  "Visible               %d", MV1GetMeshVisible( ModelHandle, i ) ) ;

		// メッシュに半透明要素があるかどうかを描画
		DrawFormatString( 0, 48, GetColor( 255,255,255 ),  "Semi Trans State      %d", MV1GetMeshSemiTransState( ModelHandle, i ) ) ;

		// メッシュがバックカリングを行うかどうかを描画
		DrawFormatString( 0, 64, GetColor( 255,255,255 ),  "Back Culling          %d", MV1GetMeshBackCulling( ModelHandle, i ) ) ;

		// メッシュの頂点ディフューズカラーを使用するかどうかを描画
		DrawFormatString( 0, 80, GetColor( 255,255,255 ),  "Use Vertex Dif Color  %d", MV1GetMeshUseVertDifColor( ModelHandle, i ) ) ;

		// メッシュの頂点スペキュラカラーを使用するかどうかを描画
		DrawFormatString( 0, 96, GetColor( 255,255,255 ),  "Use Vertex Spc Color  %d", MV1GetMeshUseVertSpcColor( ModelHandle, i ) ) ;

		// メッシュに含まれる頂点のローカル座標の最大座標値を描画
		Position = MV1GetMeshMaxPosition( ModelHandle, i ) ;
		DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Max Position          x %f  y %f  z %f", Position.x, Position.y, Position.z ) ;

		// メッシュに含まれる頂点のローカル座標の最小座標値を描画
		Position = MV1GetMeshMinPosition( ModelHandle, i ) ;
		DrawFormatString( 0, 128, GetColor( 255,255,255 ), "Min Position          x %f  y %f  z %f", Position.x, Position.y, Position.z ) ;

		// キーの入力待ち
		WaitKey() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMeshMaterial( int MHandle, int MeshIndex ) ;

概略 メッシュが使用しているマテリアルの番号を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 ０以上：マテリアルの番号
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュで使用されているマテリアルの番号を取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 int MV1GetMeshTriangleNum( int MHandle, int MeshIndex ) ;

概略 メッシュに含まれる三角形ポリゴンの数を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 ０以上：三角形ポリゴンの数
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる三角形ポリゴンの数を取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 int MV1SetMeshVisible( int MHandle, int MeshIndex, int VisibleFlag ) ;

概略 メッシュの表示・非表示状態を変更する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
int VisibleFlag ： 変更後の表示状態( TRUE：表示 FALSE：非表示 )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュの表示状態を変更します。

　VisibleFlag を FALSE にした場合、MV1DrawModel 等の描画関数を呼んでも描画されなくなります。

サンプル

　　モデルファイル DxChara.x に含まれる１番目のメッシュを非表示にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// １番のメッシュの表示状態を「非表示」にする
	MV1SetMeshVisible( ModelHandle, 1, FALSE ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMeshVisible( int MHandle, int MeshIndex ) ;

概略 メッシュの表示・非表示状態を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 ０以上：メッシュの表示状態( TRUE：表示 FALSE：非表示 )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュの表示状態を取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 int MV1SetMeshDifColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;

概略 フレームのディフューズカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる０番のメッシュのディフューズカラーを赤にします。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// ０番のメッシュのディフューズカラーを赤にする
	MV1SetMeshDifColorScale( ModelHandle, 0, GetColorF( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMeshDifColorScale( int MHandle, int MeshIndex ) ;

概略 メッシュのディフューズカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュ番号
戻り値 メッシュのディフューズカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を取得します。

　MV1SetMeshDifColorScale 関数で設定された値をそのまま返すだけの関数です。

サンプル

ありません



宣言 int MV1SetMeshSpcColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;

概略 フレームのスペキュラカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル DxChara.x に含まれる１番のメッシュのスペキュラカラーを緑にします。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// １番のメッシュのスペキュラカラーを緑にする
	MV1SetMeshSpcColorScale( ModelHandle, 1, GetColorF( 0.0f, 1.0f, 0.0f, 0.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMeshSpcColorScale( int MHandle, int MeshIndex ) ;

概略 メッシュのスペキュラカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュ番号
戻り値 メッシュのスペキュラカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を取得します。

　MV1SetMeshSpcColorScale 関数で設定された値をそのまま返すだけの関数です。

サンプル

ありません



宣言 int MV1SetMeshEmiColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;

概略 フレームのエミッシブカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる１番のメッシュのエミッシブカラーを青にします。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// １番のメッシュのエミッシブカラーを青にする
	MV1SetMeshEmiColorScale( ModelHandle, 1, GetColorF( 0.0f, 0.0f, 1.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMeshEmiColorScale( int MHandle, int MeshIndex ) ;

概略 メッシュのエミッシブカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュ番号
戻り値 メッシュのエミッシブカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を取得します。

　MV1SetMeshEmiColorScale 関数で設定された値をそのまま返すだけの関数です。

サンプル

ありません



宣言 int MV1SetMeshAmbColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;

概略 フレームのアンビエントカラーのスケール値を設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
COLOR_F Scale ： スケール値( 各色 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を設定します。

　モデル中の一部分だけ色を変えたい場合などに使用します。

サンプル

　　モデルファイル SimpleModel.mqo に含まれる３番のメッシュのアンビエントカラーを黄色にします。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// ３番のメッシュのアンビエントカラーを黄色にする
	MV1SetMeshAmbColorScale( ModelHandle, 3, GetColorF( 0.0f, 0.0f, 1.0f, 1.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 COLOR_F MV1GetMeshAmbColorScale( int MHandle, int MeshIndex ) ;

概略 メッシュのアンビエントカラーのスケール値を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュ番号
戻り値 メッシュのアンビエントカラーのスケール値

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を取得します。

　MV1SetMeshAmbColorScale 関数で設定された値をそのまま返すだけの関数です。

サンプル

ありません



宣言 int MV1SetMeshOpacityRate( int MHandle, int MeshIndex, float Rate ) ;

概略 メッシュの不透明度を設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
float Rate ： 不透明度( 0.0f ～ 1.0f )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュの不透明度を設定します。

　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、 1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。
　モデルの一部のメッシュを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。

サンプル

　　モデルファイル SimpleModel.mqo の０番目のメッシュの不透明度を５０％にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 255,0,0 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 100.0f, 600.0f ) ) ;

	// ３Ｄモデルの０番目のメッシュの不透明度を50%にする
	MV1SetMeshOpacityRate( ModelHandle, 0, 0.5f ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 float MV1GetMeshOpacityRate( int MHandle, int MeshIndex ) ;

概略 メッシュの不透明度を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 メッシュに設定されている不透明度

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに設定されている不透明度を取得します。
　MV1SetMeshOpacityRate でセットした値を取得するだけの関数です。

サンプル

ありません



宣言 int MV1SetMeshDrawBlendMode( int MHandle, int MeshIndex, int BlendMode ) ;

概略 メッシュの描画ブレンドモードを設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
int BlendMode ： 描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるメッシュの描画ブレンドモードを変更します。
　マテリアルにも描画ブレンドモードの設定がありますので、この関数はマテリアルの設定を無視して描画ブレンドモードを変更したい場合に使用します。 ( BlendMode を -1 にすると、マテリアルのブレンドモードが使用されるようになります )

　尚、現在モデル描画で正常に動作するブレンドモードは DX_BLENDMODE_ALPHA, DX_BLENDMODE_ADD の２種類のみです。 ( ハードウエアが対応している場合は DX_BLENDMODE_SUB も正常に機能します )
　ブレンドモードの説明に関しては SetDrawBlendMode 関数の解説を参照してください。

　ブレンドモードのパラメータの変更は関数 MV1SetMeshDrawBlendParam を使用します。

サンプル

　　モデルファイル DxChara.x に含まれる１番目のメッシュの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 0,0,255 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる１番目のメッシュの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
	MV1SetMeshDrawBlendMode( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMeshDrawBlendMode( int MHandle, int MeshIndex ) ;

概略 指定のマテリアルの描画ブレンドモードを取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるメッシュのの描画ブレンドモードを取得します。

　MV1SetMeshDrawBlendMode 関数で設定した値を返すだけの関数です。


サンプル

ありません



宣言 int MV1SetMeshDrawBlendParam( int MHandle, int MeshIndex, int BlendParam ) ;

概略 メッシュの描画ブレンドパラメータを設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
int BlendParame ： 描画ブレンドパラメータ( 0 ～ 255 )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるメッシュのブレンドパラメータを変更します。
( ブレンドパラメータの説明に関しては SetDrawBlendMode 関数の解説を参照してください )

　尚、ブレンドモードの変更は MV1SetMeshDrawBlendMode 関数を使用してください。

サンプル

　　モデルファイル DxChara.x に含まれる１番目のメッシュの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更して、 ブレンドパラメータを128にして描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 0,0,255 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる１番目のメッシュの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
	MV1SetMeshDrawBlendMode( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

	// モデルに含まれる１番目のメッシュのブレンドパラメータを 128 に変更する
	MV1SetMeshDrawBlendParam( ModelHandle, 1, 128 ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMeshDrawBlendParam( int MHandle, int MeshIndex ) ;

概略 メッシュの描画ブレンドパラメータを取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 描画ブレンドパラメータ( 0 ～ 255 )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるメッシュの描画ブレンドパラメータを取得します。

　この関数は MV1SetMeshDrawBlendParam 関数で設定した値を返すだけの関数です。


サンプル

ありません



宣言 int MV1SetMeshBackCulling( int MHandle, int MeshIndex, int CullingFlag ) ;

概略 メッシュのバックカリングを行うかどうかを設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
int CullingFlag ： バックカリングを行うかどうか( TRUE：行う FALSE：行わない )
戻り値 ０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルに含まれるメッシュを描画する際にバックカリング( 反対向きのポリゴンを描画しない )を行うかどうか変更します。

　ポリゴンは多くの場合裏から見られることはありませんので、基本的にはバックカリングを行うという設定にしておくことで描画負荷を下げることが出来、それで何も問題はありませんが、 例えばペラペラの紙やスカート等、態々裏面のポリゴンを用意するのはポリゴン数的に勿体無いという場合はこの関数でバックかリングを無効にします。

　ただし裏面のポリゴンを描画する際も表面のポリゴンを描画する際もライティング計算に使用される法線は同じものとなりますので、 ライティングの影響が強いメッシュに対してバックカリングを無効にすると見た目が変になります。( その場合は仕方が無いので裏面用に別のポリゴンを用意するしかありません )

サンプル

　　モデルファイル BackCulling.mqo に含まれる０番目のメッシュのバックカリングを有効な状態と無効にした状態での２パターンで描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "BackCulling.mqo" ) ;

	// バックカリングされているのがわかり易いように画面全体を青で塗りつぶす
	DrawBox( 0, 0, 640, 480, GetColor( 0,0,255 ), TRUE ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 490.0f, 50.0f, 600.0f ) ) ;

	// 最初は何もせずに３Ｄモデルを描画
	MV1DrawModel( ModelHandle ) ;

	// 最初の位置から少し移動
	MV1SetPosition( ModelHandle, VGet( 50.0f, 50.0f, 600.0f ) ) ;

	// ３Ｄモデルに含まれる０番目のバックカリングを無効にする
	MV1SetMeshBackCulling( ModelHandle, 0, FALSE ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMeshBackCulling( int MHandle, int MeshIndex ) ;

概略 メッシュのバックカリングを行うかどうかを取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 ０以上：バックカリングを行うかどうか( TRUE：行う FALSE：行わない )
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュでバックカリングを行うかどうかを取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 VECTOR MV1GetMeshMaxPosition( int MHandle, int MeshIndex ) ;

概略 メッシュに含まれる頂点のローカル座標での最大値を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 メッシュに含まれる頂点のローカル座標での最大値

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のローカル座標での最大値を取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 VECTOR MV1GetMeshMinPosition( int MHandle, int MeshIndex ) ;

概略 メッシュに含まれる頂点のローカル座標での最小値を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 メッシュに含まれる頂点のローカル座標での最小値

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のローカル座標での最小値を取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 int MV1GetMeshSemiTransState( int MHandle, int MeshIndex ) ;

概略 メッシュに半透明要素があるかどうかを取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 TRUE：半透明要素がある　FALSE：半透明要素は無い
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに半透明の要素があるかどうかを取得します。

　例えば、メッシュが使用しているマテリアルのテクスチャに半透明の部分があったり、 メッシュの不透明度が 1.0f ではなかったりすると TRUE が返ってきます。

　半透明要素を持つメッシュをＺソートする場合に、各メッシュに半透明要素があるかどうかを判定する際などに使用します。

サンプル

　　モデルファイル DxChara.x の０番目のメッシュの不透明度を上下キーで操作できるようにした上で、 画面上に MV1GetMeshSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float OpacityRate ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "DxChara.x" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, -300.0f, 600.0f ) ) ;

	// 不透明度を初期化
	OpacityRate = 1.0f ;

	// ESCキーが押されるかウインドウが閉じられるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面のクリア
		ClearDrawScreen() ;

		// 上キーが押されたら不透明度を上げる
		if( CheckHitKey( KEY_INPUT_UP ) )
		{
			OpacityRate += 0.05f ;
			if( OpacityRate > 1.0f )
			{
				OpacityRate = 1.0f ;
			}
		}

		// 下キーが押されたら不透明度を下げる
		if( CheckHitKey( KEY_INPUT_DOWN ) )
		{
			OpacityRate -= 0.05f ;
			if( OpacityRate MV1SetMeshOpacityRate( ModelHandle, 1, OpacityRate ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 現在の不透明度と、MV1GetMeshSemiTransState の戻り値を描画する
		DrawFormatString( 0, 0, GetColor( 255,255,255 ),
			"ESC Key:Exit OpacityRate:%f SemiTransState:%d",
			OpacityRate, MV1GetMeshSemiTransState( ModelHandle, 1 ) ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1SetMeshUseVertDifColor( int MHandle, int MeshIndex, int UseFlag ) ;

概略 メッシュの頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
int UseFlag ： 頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうか( TRUE：使用する FALSE：使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを設定します。
( デフォルトでは頂点ディフューズカラーは使用しません )

　この関数で頂点ディフューズカラーを使用する設定にした場合はマテリアルのディフューズカラー設定は無視され、代わりに頂点ディフューズカラーが使用されます。

　モデリングソフトでライティングの結果を頂点カラーに反映した場合等に使用します。
　尚、ライティング計算を SetUseLighting 関数で無効にした場合はこの関数の設定に関係なくマテリアルのディフューズカラーは無視され、頂点ディフューズカラーが使用されます。

サンプル

　　モデルファイル SimpleModelVertexColor.mqo を最初は普通に描画し、キーが押された後３番目のメッシュの頂点ディフューズカラーを
　有効にして( マテリアルのディフューズカラーを無効にして )再度モデルを描画します。
　　３番目のメッシュの頂点ディフューズカラーは真っ黒なので、キーが押された後はエミッシブカラー( 自己発光色 )と
　アンビエントカラー( 環境光色 )のみの平坦な見た目に変化します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModelVertexColor.mqo" ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// 画面をクリア
	ClearDrawScreen() ;

	// ３番目のメッシュの頂点ディフューズカラーを使用する設定に変更する
	MV1SetMeshUseVertDifColor( ModelHandle, 3, TRUE ) ;

	// ３Ｄモデルの描画
	MV1DrawModel( ModelHandle ) ;

	// キーの入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1GetMeshUseVertDifColor( int MHandle, int MeshIndex ) ;

概略 メッシュの頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかの設定を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうか( TRUE：使用する FALSE：使用しない )

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



宣言 int MV1SetMeshUseVertSpcColor( int MHandle, int MeshIndex, int UseFlag ) ;

概略 メッシュの頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを設定する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
int UseFlag ： 頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうか( TRUE：使用する FALSE：使用しない )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを設定します。

　この関数で頂点スペキュラカラーを使用する設定にした場合はマテリアルのスペキュラカラー設定は無視され、代わりに頂点スペキュラカラーが使用されます。

　ただ、現時点ではライブラリのモデルデータ読みこみプログラムに頂点のスペキュラカラーを設定する処理が組み込まれていないので、 この関数で頂点スペキュラカラーを有効にしてもマテリアルのスペキュラカラーが無効化されるだけとなります。

サンプル

ありません



宣言 int MV1GetMeshUseVertSpcColor( int MHandle, int MeshIndex ) ;

概略 メッシュの頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかの設定を取得する

引数   int MHandle ： モデルのハンドル
int MeshIndex ： メッシュの番号
戻り値 頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうか( TRUE：使用する FALSE：使用しない )

解説  　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のスペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを取得します。

サンプル

　MV1GetMeshNum関数 のサンプルを参照してください。



コリジョン( 衝突判定 )関係

宣言 int MV1SetupCollInfo( int MHandle, int FrameIndex, int XDivNum, int YDivNum, int ZDivNum ) ;

概略 コリジョン情報を構築する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： コリジョンの情報を構築するフレームの番号
int XDivNum ： コリジョン情報のＸ軸方向の空間分割数
int YDivNum ： コリジョン情報のＹ軸方向の空間分割数
int ZDivNum ： コリジョン情報のＺ軸方向の空間分割数
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとの当たり判定を行うための情報のセットアップを行います。

　３Ｄを扱うゲームでは多くの場合３Ｄモデルとの当たり判定を行っています。 この MV1SetupCollInfo を含むコリジョン関係関数は、その当たり判定処理の手助けをするものです。

　その使い方ですが、コリジョン関係の機能を使用するにはまずこの関数でコリジョン情報として使用したいポリゴンを持つフレームのポリゴンをコリジョン情報として使うための準備をしてやる必要があります。 そのフレームは FrameIndex で指定しますが、ここで FrameIndex を -1 にすることでモデル全体のポリゴンをコリジョン情報として準備することができます。
　因みにコリジョン処理は非常に負荷の高い処理ですので、 例えばステージモデルとの当たり判定を行う場合等は描画用のステージモデルをそのまま当たり判定用のモデルとして使うのではなく、 当たり判定用の粗いポリゴンメッシュを収めるフレームを用意して、 そのフレームに対して MV1SetupCollInfo をした方が良いです。 ( そしてそのフレームは MV1SetFrameVisible 関数で描画されないようにしておきます )

　セットアップ時に指定する XDivNum, YDivNum, ZDivNum ですが、 コリジョン処理の仕組みとして、 あるコリジョン処理をする際にコリジョン用のフレーム内に存在するすべてのポリゴンと接触判定をすると大変な処理負荷になってしまいますので、 コリジョン用のポリゴンはまずポリゴンが存在する空間を格子状に区切ってどの枠にどのポリゴンが存在するかを整理して、 コリジョン処理を行いたい領域の周辺に存在するポリゴンとだけ接触判定をするようにして、 処理負荷があまり大きくならないようにします。
　分割数の最適値ですが、 一つの格子が、コリジョン処理を行うオブジェクトの大きさとコリジョン用ポリゴンの平均的な大きさを比較して、 大きい方と同じくらいになる分割数が良いです。 検索対象となるポリゴンが多くなるのは問題ですが、検索対象となる格子の数が多すぎるのもまた問題ですので・・・ ( 例えば人型キャラクターが登場するステージの分割数でしたら、 人型キャラクターのモデルとコリジョン用ポリゴンの平均的な大きさを比較して、 人型キャラクターモデルの方が大きい場合は格子一つのサイズが人型キャラクターと同じ位の大きさになる分割数、 コリジョン用ポリゴンの平均的な大きさのほうが大きい場合は格子一つのサイズがコリジョン用ポリゴンの平均的な大きさと同じくらいの大きさになる分割数が最適となります )

　ちなみにコリジョン情報の構築は負荷の高い処理ですので、 コリジョン情報の更新は MV1RefreshCollInfo 関数を使用して明示的に行う必要があります。
　動かないモデルをコリジョンとして使用する場合は一度この関数でコリジョン情報をセットアップした後は何もする必要はありませんが、 動くモデルをコリジョンとして使用する場合は MV1RefreshCollInfo を呼ばないとコリジョン情報の形状が最後に更新したときの状態のままとなってしまいますので注意してください。

サンプル

　　モデルファイル SimpleModel.mqo の０番目のフレーム( 中心の球体 )と線分の当たり判定をし、
　当たったところまで線分を描画します。
　　あと、当たっているのかどうかを判断するために上下キーで線分を移動できるようにしています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	float y ;
	VECTOR StartPos, EndPos ;
	MV1_COLL_RESULT_POLY HitPoly ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 画面に映る位置に３Ｄモデルを移動
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// モデルの０番目のフレームのコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, 0, 8, 8, 8 ) ;

	// 当たり判定用のラインを出すＹ座標を初期化
	y = 300.0f ;

	// ウインドウが閉じられるかＥＳＣキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 上下キーで線分の y 座標を操作できる
		if( CheckHitKey( KEY_INPUT_UP ) == 1 )
		{
			y += 16.0f ;
		}
		if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
		{
			y -= 16.0f ;
		}

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// ０番のフレームと線分との当たり判定
		StartPos = VGet( 0.0f, y, 600.0f ) ;
		EndPos   = VGet( 1000.0f, y, 600.0f ) ;
		HitPoly = MV1CollCheck_Line( ModelHandle, 0, StartPos, EndPos ) ;

		// 当たった場合はその位置を描画する線分の終点とする
		if( HitPoly.HitFlag == 1 )
		{
			EndPos = HitPoly.HitPosition ;
		}

		// 線分の描画
		DrawLine3D( StartPos, EndPos, GetColor( 255,255,0 ) ) ;

		// 当たったかどうかを表示する
		DrawFormatString( 0, 0, GetColor( 255,255,255 ), "HIT:%d", HitPoly.HitFlag ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1TerminateCollInfo( int MHandle, int FrameIndex ) ;

概略 コリジョン情報の後始末をする

引数   int MHandle ： モデルのハンドル
int FrameIndex ： コリジョンの情報の後始末を行うフレームの番号
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとの当たり判定を行うための情報の後始末を行います。

　この関数を使用して明示的に情報を破棄しなくても、 MV1DeleteModel や DxLib_End が呼ばれた際にモデル情報と共にコリジョン情報の後始末は行われますので、 この関数を使用する機会はあまり無いかもしれません。

　尚、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。

サンプル

　　ありません



宣言 int MV1RefreshCollInfo( int MHandle, int FrameIndex ) ;

概略 コリジョン情報を更新する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： コリジョンの情報を更新するフレームの番号
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとの当たり判定を行うための情報の更新を行います。

　動作させないモデルをコリジョンポリゴンとして使用している場合はこの関数を呼ぶ必要はありませんが、 MV1SetPosition で座標を移動したり、アニメーションを流したりするモデルをコリジョンポリゴンとして使用している場合はこの関数を使用して明示的にコリジョン情報を更新する必要があります。 ( 更新しない場合は最後に更新した状態のままとなります )

　尚、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。

サンプル

　　モデルファイル SimpleModel.mqo の０番目のフレーム( 中心の球体 )と線分の当たり判定をし、
　当たったところまで線分を描画します。
　　そして、モデルを上下に動かしながら MV1RefreshCollInfo でコリジョン情報を更新しています。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int Add, y ;
	VECTOR StartPos, EndPos ;
	MV1_COLL_RESULT_POLY HitPoly ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// モデルの０番目のフレームのコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, 0, 8, 8, 8 ) ;

	// モデルの進行方向をセット
	Add = 8 ;

	// モデルの移動位置をセット
	y = 0 ;

	// ウインドウが閉じられるかＥＳＣキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの移動位置を上下に移動させる
		y += Add ;
		if( y  300 )
			Add = -Add ;

		// ３Ｄモデルの位置を変更する
		MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f + y, 600.0f ) ) ;

		// ０番目のフレームのコリジョン情報を更新する
		MV1RefreshCollInfo( ModelHandle, 0 ) ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// ０番のフレームと線分との当たり判定
		StartPos = VGet(    0.0f, 300.0f, 600.0f ) ;
		EndPos   = VGet( 1000.0f, 300.0f, 600.0f ) ;
		HitPoly = MV1CollCheck_Line( ModelHandle, 0, StartPos, EndPos ) ;

		// 当たった場合はその位置を描画する線分の終点とする
		if( HitPoly.HitFlag == 1 )
		{
			EndPos = HitPoly.HitPosition ;
		}

		// 線分の描画
		DrawLine3D( StartPos, EndPos, GetColor( 255,255,0 ) ) ;

		// 当たったかどうかを表示する
		DrawFormatString( 0, 0, GetColor( 255,255,255 ), "HIT:%d", HitPoly.HitFlag ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MV1_COLL_RESULT_POLY MV1CollCheck_Line( int MHandle, int FrameIndex, VECTOR PosStart, VECTOR PosEnd ) ;

概略 線分とモデルの当たり判定

引数   int MHandle ： モデルのハンドル
int FrameIndex ： コリジョンの情報を更新するフレームの番号
VECTOR PosStart ： 当たり判定で使用する線分の始点
VECTOR PosEnd ： 当たり判定で使用する線分の終点
戻り値 当たり判定結果構造体

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンと線分との当たり判定を行います。
( この関数でモデルのポリゴンと線分との当たり判定を行う場合は対象となるフレーム( 若しくはモデル全体 )に対して事前に MV1SetupCollInfo を呼んで準備を行っておく必要があります、 また、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )

　戻り値である MV1_COLL_RESULT_POLY は当たり判定の結果が代入されている構造体で、以下のような内容になっています。



// コリジョン結果代入用ポリゴン
struct MV1_COLL_RESULT_POLY
{
	// どれかのポリゴンに当たったかどうか
	// ( 1：当たった  0：当たらなかった )
	int	HitFlag ;

	// 線分とポリゴンが交差した座標
	VECTOR	HitPosition ;

	// 当たったポリゴンが含まれるフレームの番号
	int	FrameIndex ;

	// 当たったポリゴンが使用しているマテリアルの番号
	int	MaterialIndex ;

	// 当たったポリゴンを形成する三点の座標
	VECTOR	Position[ 3 ] ;

	// 当たったポリゴンの法線
	VECTOR	Normal ;
} ;

　注釈の通りですが、 どれかのポリゴンに当たったかどうかはメンバ変数 HitFlag が 1 かどうかで判断することができ、 線分とポリゴンが交差した座標は HitPosition に代入されます。
　当たったポリゴンが含まれるメッシュを所有しているフレームの番号はメンバ変数 FrameIndex に、 当たったポリゴンが使用しているマテリアルの番号はメンバ変数 MaterialIndex に、 当たったポリゴンを形成する三頂点の座標はメンバ配列 Position に、 当たったポリゴンの法線はメンバ変数 Normal にそれぞれ代入されます。
サンプル

　　モデルファイル SimpleModel.mqo と上下に動く線分との当たり判定をして、当たったところまでの線分の描画と、
　当たり判定の結果を画面に描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int Add, y ;
	VECTOR StartPos, EndPos ;
	MV1_COLL_RESULT_POLY HitPoly ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ３Ｄモデルを見える位置に移動する
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// モデル全体のコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, -1, 8, 8, 8 ) ;

	// モデルの進行方向をセット
	Add = 8 ;

	// モデルの移動位置をセット
	y = 0 ;

	// ウインドウが閉じられるか何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの移動位置を上下に移動させる
		y += Add ;
		if( y  600 )
			Add = -Add ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// モデルと線分との当たり判定
		StartPos = VGet( -300.0f, y, 600.0f ) ;
		EndPos   = VGet( 1000.0f, y, 600.0f ) ;
		HitPoly = MV1CollCheck_Line( ModelHandle, -1, StartPos, EndPos ) ;

		// 当たった場合はその位置を描画する線分の終点とする
		if( HitPoly.HitFlag == 1 )
		{
			EndPos = HitPoly.HitPosition ;
		}

		// 線分の描画
		DrawLine3D( StartPos, EndPos, GetColor( 255,255,0 ) ) ;

		// 当たったかどうかで処理を分岐
		if( HitPoly.HitFlag == 1 )
		{
			// 当たった場合は衝突の情報を描画する

			// 交差した座標を描画
			DrawFormatString( 0, 0, GetColor( 255,255,255 ),  "Hit Pos   %f  %f  %f",
				HitPoly.HitPosition.x, HitPoly.HitPosition.y, HitPoly.HitPosition.z ) ;

			// 当たったポリゴンが含まれるフレームの番号を描画
			DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Frame     %d", HitPoly.FrameIndex ) ;

			// 当たったポリゴンが使用しているマテリアルの番号を描画
			DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Material  %d", HitPoly.MaterialIndex ) ;

			// 当たったポリゴンを形成する三頂点の座標を描画
			DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Position  %f  %f  %f",
				HitPoly.Position[ 0 ].x, HitPoly.Position[ 0 ].y, HitPoly.Position[ 0 ].z ) ;
			DrawFormatString( 0, 64, GetColor( 255,255,255 ), "          %f  %f  %f",
				HitPoly.Position[ 1 ].x, HitPoly.Position[ 1 ].y, HitPoly.Position[ 1 ].z ) ;
			DrawFormatString( 0, 80, GetColor( 255,255,255 ), "          %f  %f  %f",
				HitPoly.Position[ 2 ].x, HitPoly.Position[ 2 ].y, HitPoly.Position[ 2 ].z ) ;

			// 当たったポリゴンの法線を描画
			DrawFormatString( 0, 96, GetColor( 255,255,255 ), "Normal    %f  %f  %f",
				HitPoly.Normal.x, HitPoly.Normal.y, HitPoly.Normal.z ) ;
		}
		else
		{
			// 当たらなかった場合は衝突しなかった旨だけ描画する
			DrawString( 0, 0, "NO HIT", GetColor( 255,255,255 ) ) ;
		}

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MV1_COLL_RESULT_POLY_DIM MV1CollCheck_Sphere( int MHandle, int FrameIndex, VECTOR CenterPos, float r ) ;

概略 球とモデルの当たり判定

引数   int MHandle ： モデルのハンドル
int FrameIndex ： コリジョンの情報を更新するフレームの番号
VECTOR CenterPos ： 当たり判定で使用する球の中心座標
float r ： 当たり判定で使用する球の半径
戻り値 当たり判定結果ポリゴン配列構造体

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンと球との当たり判定を行います。
( この関数でモデルのポリゴンと線分との当たり判定を行う場合は対象となるフレーム( 若しくはモデル全体 )に対して事前に MV1SetupCollInfo を呼んで準備を行っておく必要があります、 また、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )

　戻り値である MV1_COLL_RESULT_POLY_DIM は当たり判定の結果が代入されている構造体で、以下のような内容になっています。



// コリジョン結果代入用ポリゴン配列
struct MV1_COLL_RESULT_POLY_DIM
{
	// 当たったポリゴンの数
	int			HitNum ;

	// 当たったポリゴンの配列へのポインタ
	// ( 配列の要素数は HitNum です )
	MV1_COLL_RESULT_POLY	*Dim ;
} ;

　また、MV1_COLL_RESULT_POLY_DIM 構造体で使用されている MV1_COLL_RESULT_POLY 構造体は以下のような内容になっています。



// コリジョン結果代入用ポリゴン
struct MV1_COLL_RESULT_POLY
{
	// どれかのポリゴンに当たったかどうか
	// ( 球との当たり判定の場合は必ず 1 )
	int	HitFlag ;

	// 球とポリゴンの最近点の座標
	VECTOR	HitPosition ;

	// 当たったポリゴンが含まれるフレームの番号
	int	FrameIndex ;

	// 当たったポリゴンが使用しているマテリアルの番号
	int	MaterialIndex ;

	// 当たったポリゴンを形成する三点の座標
	VECTOR	Position[ 3 ] ;

	// 当たったポリゴンの法線
	VECTOR	Normal ;
} ;

　構造体の説明ですが、まず球とフレーム( 若しくはモデル全体 )との当たり判定を行うと戻り値として MV1_COLL_RESULT_POLY_DIM 構造体が返ってきます。
　この構造体の中身にはメンバ変数 HitNum と Dim があり、当たったポリゴンの数が HitNum に代入されています。
　この HitNum が 0 だったら球は対象のフレーム( 若しくはモデル全体 )に含まれるポリゴンに一枚も当たらなかったということです。
　そして当たった場合は、当たったポリゴンの数が HitNum に代入され、 どんなポリゴンと当たったかに関する情報がポインタ Dim が示すアドレスに当たったポリゴンの数だけ要素がある配列として格納されます。

　当たったかどうかだけを判断する場合は HitNum が 0 かどうかを判定するだけで、 当たったポリゴンに関する情報を扱いたい場合は Dim の先にある配列にアクセスするという使い方になります。

( Dim へのアクセスの仕方についてはサンプルプログラムを見ていただくとわかりやすいと思います ) 　また、この関数は当たるポリゴンの数が不定である関係上、動的にメモリを確保していますので、 戻り値の情報が必要なくなった場合は MV1CollResultPolyDimTerminate 関数に戻り値の構造体を渡して後始末を行う必要があります。

サンプル

　　モデルファイル SimpleModel.mqo と上下に動く球の当たり判定をして、球と当たったポリゴンとの最近点を表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int Add, y, i ;
	VECTOR SpherePos ;
	MV1_COLL_RESULT_POLY_DIM HitPolyDim ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ３Ｄモデルを見える位置に移動する
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// モデル全体のコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, -1, 8, 8, 8 ) ;

	// モデルの進行方向をセット
	Add = 8 ;

	// モデルの移動位置をセット
	y = 0 ;

	// ウインドウが閉じられるか何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの移動位置を上下に移動させる
		y += Add ;
		if( y  600 )
			Add = -Add ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 当たり判定を行う球の位置をセット
		SpherePos = VGet( 250.0f, y, 600.0f ) ;

		// モデルと球との当たり判定
		HitPolyDim = MV1CollCheck_Sphere( ModelHandle, -1, SpherePos, 100.0f ) ;

		// 球の描画
		DrawSphere3D( SpherePos, 100.0f, 8, GetColor( 255,255,0 ), GetColor( 255,255,255 ), FALSE ) ;

		// 当たったかどうかで処理を分岐
		if( HitPolyDim.HitNum >= 1 )
		{
			// 当たった場合は衝突の情報を描画する

			// 当たったポリゴンの数を描画
			DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Hit Poly Num   %d", HitPolyDim.HitNum ) ;

			// 当たったポリゴンの数だけ繰り返し
			for( i = 0 ; i MV1CollResultPolyDimTerminate( HitPolyDim ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MV1_COLL_RESULT_POLY_DIM MV1CollCheck_Capsule( int MHandle, int FrameIndex, VECTOR Pos1, VECTOR Pos2, float r ) ;

概略 カプセル形状とモデルの当たり判定

引数   int MHandle ： モデルのハンドル
int FrameIndex ： コリジョンの情報を更新するフレームの番号
VECTOR Pos1 ： カプセルを形成する二点中の一点の座標
VECTOR Pos2 ： カプセルを形成する二点中の一点の座標
float r ： カプセルの半径
戻り値 当たり判定結果ポリゴン配列構造体

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとカプセル形状( 二つの球を円筒で繋いだ形状 )との当たり判定を行います。
( この関数でモデルのポリゴンと線分との当たり判定を行う場合は対象となるフレーム( 若しくはモデル全体 )に対して事前に MV1SetupCollInfo を呼んで準備を行っておく必要があります、 また、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )

　戻り値である MV1_COLL_RESULT_POLY_DIM は当たり判定の結果が代入されている構造体で、以下のような内容になっています。



// コリジョン結果代入用ポリゴン配列
struct MV1_COLL_RESULT_POLY_DIM
{
	// 当たったポリゴンの数
	int			HitNum ;

	// 当たったポリゴンの配列へのポインタ
	// ( 配列の要素数は HitNum です )
	MV1_COLL_RESULT_POLY	*Dim ;
} ;

　また、MV1_COLL_RESULT_POLY_DIM 構造体で使用されている MV1_COLL_RESULT_POLY 構造体は以下のような内容になっています。



// コリジョン結果代入用ポリゴン
struct MV1_COLL_RESULT_POLY
{
	// どれかのポリゴンに当たったかどうか
	// ( カプセルとの当たり判定の場合は必ず 1 )
	int	HitFlag ;

	// 無効です
	VECTOR	HitPosition ;

	// 当たったポリゴンが含まれるフレームの番号
	int	FrameIndex ;

	// 当たったポリゴンが使用しているマテリアルの番号
	int	MaterialIndex ;

	// 当たったポリゴンを形成する三点の座標
	VECTOR	Position[ 3 ] ;

	// 当たったポリゴンの法線
	VECTOR	Normal ;
} ;

　構造体の説明ですが、まずカプセルとフレーム( 若しくはモデル全体 )との当たり判定を行うと戻り値として MV1_COLL_RESULT_POLY_DIM 構造体が返ってきます。
　この構造体の中身にはメンバ変数 HitNum と Dim があり、当たったポリゴンの数が HitNum に代入されています。
　この HitNum が 0 だったら球は対象のフレーム( 若しくはモデル全体 )に含まれるポリゴンに一枚も当たらなかったということです。
　そして当たった場合は、当たったポリゴンの数が HitNum に代入され、 どんなポリゴンと当たったかに関する情報がポインタ Dim が示すアドレスに当たったポリゴンの数だけ要素がある配列として格納されます。

　当たったかどうかだけを判断する場合は HitNum が 0 かどうかを判定するだけで、 当たったポリゴンに関する情報を扱いたい場合は Dim の先にある配列にアクセスするという使い方になります。

( Dim へのアクセスの仕方についてはサンプルプログラムを見ていただくとわかりやすいと思います ) 　また、この関数は当たるポリゴンの数が不定である関係上、動的にメモリを確保していますので、 戻り値の情報が必要なくなった場合は MV1CollResultPolyDimTerminate 関数に戻り値の構造体を渡して後始末を行う必要があります。

サンプル

　　モデルファイル SimpleModel.mqo と上下に動くカプセルの当たり判定をして、カプセルと当たったポリゴンとの最近点を表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

// カプセルの高さ
#define CAPSULE_H		64.0f

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int Add, y, i ;
	VECTOR CapsulePos1, CapsulePos2 ;
	MV1_COLL_RESULT_POLY_DIM HitPolyDim ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ３Ｄモデルを見える位置に移動する
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// モデル全体のコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, -1, 8, 8, 8 ) ;

	// モデルの進行方向をセット
	Add = 8 ;

	// モデルの移動位置をセット
	y = 0 ;

	// ウインドウが閉じられるか何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの移動位置を上下に移動させる
		y += Add ;
		if( y  600 )
			Add = -Add ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 当たり判定を行う球の位置をセット
		CapsulePos1 = VGet( 250.0f, y, 600.0f ) ;
		CapsulePos2 = VGet( 250.0f, y + CAPSULE_H, 600.0f ) ;

		// モデルとカプセルとの当たり判定
		HitPolyDim = MV1CollCheck_Capsule( ModelHandle, -1, CapsulePos1, CapsulePos2,  100.0f ) ;

		// カプセルの描画
		DrawCapsule3D( CapsulePos1, CapsulePos2, 100.0f, 8, GetColor( 255,255,0 ), GetColor( 255,255,255 ), FALSE ) ;

		// 当たったかどうかで処理を分岐
		if( HitPolyDim.HitNum >= 1 )
		{
			// 当たった場合は衝突の情報を描画する

			// 当たったポリゴンの数を描画
			DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Hit Poly Num   %d", HitPolyDim.HitNum ) ;

			// 当たったポリゴンの数だけ繰り返し
			for( i = 0 ; i DrawTriangle3D(
					HitPolyDim.Dim[ i ].Position[ 0 ], 
					HitPolyDim.Dim[ i ].Position[ 1 ], 
					HitPolyDim.Dim[ i ].Position[ 2 ], GetColor( 0,255,255 ), TRUE ) ;
			}
		}

		// 当たり判定情報の後始末
		MV1CollResultPolyDimTerminate( HitPolyDim ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MV1_COLL_RESULT_POLY MV1CollCheck_GetResultPoly( MV1_COLL_RESULT_POLY_DIM ResultPolyDim, int PolyNo ) ;

概略 当たり判定結果ポリゴン配列から指定番のポリゴン情報を取得する

引数   MV1_COLL_RESULT_POLY_DIM ResultPolyDim ： 当たり判定結果ポリゴン配列構造体
int PolyNo ： 取得したいポリゴンの番号
戻り値 当たり判定結果ポリゴン

解説  　MHandle のモデルハンドルが示すモデルと球の当たり判定を MV1CollCheck_Sphere で行った結果の MV1_COLL_RESULT_POLY_DIM 構造体から指定番号の当たったポリゴンの情報を取得するための関数です。
　MV1_COLL_RESULT_POLY_DIM 関数の中にある Dim が示す配列から情報を返すだけの関数ですが、 ポインタが苦手な方はこちらの関数を使用してください。

サンプル

　　モデルファイル SimpleModel.mqo と上下に動く球の当たり判定をして、球と当たったポリゴンとの最近点を表示します。
　　( MV1CollCheck_Sphere 関数のサンプルを MV1CollCheck_GetResultPoly を使用するように変更したものです )
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int Add, y, i ;
	VECTOR SpherePos ;
	MV1_COLL_RESULT_POLY_DIM HitPolyDim ;
	MV1_COLL_RESULT_POLY HitPoly ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ３Ｄモデルを見える位置に移動する
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// モデル全体のコリジョン情報を構築
	MV1SetupCollInfo( ModelHandle, -1, 8, 8, 8 ) ;

	// モデルの進行方向をセット
	Add = 8 ;

	// モデルの移動位置をセット
	y = 0 ;

	// ウインドウが閉じられるか何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの移動位置を上下に移動させる
		y += Add ;
		if( y  600 )
			Add = -Add ;

		// ３Ｄモデルの描画
		MV1DrawModel( ModelHandle ) ;

		// 当たり判定を行う球の位置をセット
		SpherePos = VGet( 250.0f, y, 600.0f ) ;

		// モデルと球との当たり判定
		HitPolyDim = MV1CollCheck_Sphere( ModelHandle, -1, SpherePos, 100.0f ) ;

		// 球の描画
		DrawSphere3D( SpherePos, 100.0f, 8, GetColor( 255,255,0 ), GetColor( 255,255,255 ), FALSE ) ;

		// 当たったかどうかで処理を分岐
		if( HitPolyDim.HitNum >= 1 )
		{
			// 当たった場合は衝突の情報を描画する

			// 当たったポリゴンの数を描画
			DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Hit Poly Num   %d", HitPolyDim.HitNum ) ;

			// 当たったポリゴンの数だけ繰り返し
			for( i = 0 ; i MV1CollResultPolyDimTerminate( HitPolyDim ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1CollResultPolyDimTerminate( MV1_COLL_RESULT_POLY_DIM ResultPolyDim ) ;

概略 当たり判定結果ポリゴン配列の後始末をする

引数   MV1_COLL_RESULT_POLY_DIM ResultPolyDim ： 当たり判定結果ポリゴン配列構造体
戻り値 　０：成功
　 －１：エラー発生

解説  　MV1CollCheck_Sphere 関数の戻り値である ResultPolyDim 構造体の後始末を行います。

　MV1CollCheck_Sphere 関数が返す構造体 MV1_COLL_RESULT_POLY_DIM は当たるポリゴンの数が不定な関係上、 当たり判定結果を代入するメモリ領域を動的に確保しているので、 当たり判定結果を使った処理が終了した際はこの関数で構造体の後始末を行う必要があります。

サンプル

　MV1CollCheck_Sphere関数 のサンプルを参照してください。



参照用メッシュ関係

宣言 int MV1SetupReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;

概略 参照用メッシュのセットアップ

引数   int MHandle ： モデルのハンドル
int FrameIndex ： 参照用メッシュを構築するフレームの番号
int IsTransform ： 参照用メッシュは頂点座標変換を施したものにするかどうか
　　　　　　( TRUE：変換を施したもの FALSE：変換を施さないローカル座標のもの )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンの座標や法線、ＵＶ値などの情報にアクセスするための準備を行います。

　３Ｄを扱うゲームを作成していると、 しばしば３Ｄモデルを描画する以外の用途で３Ｄモデルのポリゴンの頂点座標や法線座標を扱いたくなるときがあります、 最も一般的な例はモデルとの当たり判定ですが、 それ以外の用途でも・・・あんまり一般的な例は思いつきませんがあったりします。
　参照用メッシュはそんなときに有効なモデルの頂点座標やポリゴン情報にアクセスするための機能です。

　その使い方ですが、参照用メッシュの機能を使用するにはまずこの関数で参照したいポリゴンを参照するための準備を行う必要があります。 参照対象としたいフレームを引数 FrameIndex で指定して( FrameIndex を -1 にすることでモデル全体のポリゴンを参照するための準備をすることができます )、 加えて参照用メッシュの頂点座標を、 頂点座標変換を施した頂点にするかどうかを引数 IsTransform で指定します。 ( TRUE にすると MV1SetPosition や MV1AttachAnim 等で設定された頂点座標変換が行われたものが、 FALSE にすると MV1SetPosition や MV1AttachAnim 等の設定を無視して何も頂点座標変換が行われていないものがそれぞれ取得できます )
　因みに参照用メッシュの構築処理はそれなりに負荷の高い処理ですので、 できる限り参照したいポリゴンを持つフレームのみを指定した方が良いです。

　セットアップが完了した後は参照用メッシュの情報が入った構造体 MV1_REF_POLYGONLIST を戻り値として返してくる関数 MV1GetReferenceMesh を使用して、実際にポリゴンの情報を取得します。


// 参照用ポリゴンデータ構造体
struct MV1_REF_POLYGONLIST
{
	// ポリゴンの数
	int	PolygonNum ;

	// 頂点の数
	int	VertexNum ;

	// 頂点座標の最小値
	VECTOR	MinPosition ;

	// 頂点座標の最大値
	VECTOR	MaxPosition ;

	// ポリゴン構造体の配列へのポインタ
	MV1_REF_POLYGON	*Polygons ;

	// 頂点構造体の配列へのポインタ
	MV1_REF_VERTEX	*Vertexs ;
} ;

int PolygonNum
　参照用メッシュに含まれるポリゴンの数です。
　参照の対象をフレームにした場合はフレームに含まれるメッシュが持つポリゴンの総数が、 参照の対象をモデルにした場合はモデルに含まれる全メッシュが持つポリゴンの総数が代入されます。

int VertexNum
　参照用メッシュに含まれる頂点の数です。
　参照の対象をフレームにした場合はフレームに含まれるメッシュが持つ頂点の総数が、 参照の対象をモデルにした場合はモデルに含まれる全メッシュが持つ頂点の総数が代入されます。

VECTOR MinPosition
　参照用メッシュに含まれる頂点座標の最小値です。
　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最小値となります。

VECTOR MaxPosition
　参照用メッシュに含まれる頂点座標の最大値です。
　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最大値となります。

MV1_REF_POLYGON *Polygons
　参照用メッシュに含まれるポリゴン情報の配列へのポインタです。
　配列の要素数は PolygonNum 個で、 中身はポリゴンが含まれているフレームの番号、 ポリゴンに使用されているマテリアルの番号、 ポリゴンの形成に使用されている頂点の番号３つなどです。

MV1_REF_VERTEX *Vertexs
　参照用メッシュに含まれる頂点情報の配列へのポインタです。
　配列の要素数は VertexNum 個で、 中身は頂点の位置・法線・テクスチャ座標・頂点カラーなどです。
　ポリゴンの情報と頂点の情報が分かれているのは多くの場合一つの頂点は複数のポリゴンで使用されているので、 ポリゴンの情報の中に頂点の情報を含めてしまうと同じ頂点情報が幾つものポリゴン情報の中に含まれてデータサイズが無駄に大きくなってしまうからです。

　次に頂点の情報が格納される構造体 MV1_REF_VERTEX は次のような内容になっています。


struct MV1_REF_VERTEX
{
	// 位置
	VECTOR	Position ;

	// 法線
	VECTOR	Normal ;

	// テクスチャ座標
	UV	TexCoord[ 2 ] ;

	// ディフューズカラー
	COLOR_U8	DiffuseColor ;

	// スペキュラカラー
	COLOR_U8	SpecularColor ;
} ;

VECTOR Position
　頂点の座標です。
　頂点座標変換をする指定をした場合は MV1SetPosition や MV1AttachAnim などの設定が反映された座標が、 座標変換をしないようにした場合は読み込み時のメッシュのローカル座標そのままが代入されます。
　座標変換をする指定をした場合は MV1RefreshReferenceMesh 関数を呼ぶことで座標値が更新されます。

VECTOR Normal
　頂点の法線です。
　頂点座標変換をする指定をした場合は MV1SetRotation や MV1AttachAnim などの設定が反映された法線ベクトルが、 座標変換をしないようにした場合は読み込み時のメッシュのローカル法線がそのまま代入されます。
　座標変換をする指定をした場合は MV1RefreshReferenceMesh 関数を呼ぶことで法線値が更新されます。

UV TexCoord[ 2 ]
　頂点のテクスチャ座標です。
　UV は構造体で、中身は float u, v となっています。
　一応マルチテクスチャを考慮して２つのテクスチャ座標を代入できるようになっていますが、 現在のバージョンでは TexCoord[ 0 ] しか使いません。

COLOR_U8 DiffuseColor
　頂点のディフューズカラーです。
　メッシュに頂点カラーが無かった場合はポリゴンが使用しているマテリアルのディフューズカラーが代入されています。

COLOR_U8 SpecularColor
　頂点のスペキュラカラーです。
　現在のバージョンでは必ず r, g, b, a すべての要素が 0.0f となります。

　次にポリゴンの情報が格納される構造体 MV1_REF_POLYGON は以下のような内容になっています。


struct MV1_REF_POLYGON
{
	// ポリゴンが含まれるメッシュを持っているフレームの番号
	unsigned short	FrameIndex ;

	// 使用しているマテリアルの番号
	unsigned short	MaterialIndex ;

	// VIndex が指すインデックスの参照先( 1：フレーム  0：モデル全体 )
	int		VIndexTarget ;

	// 三角形ポリゴンを形成する三頂点の番号
	int		VIndex[ 3 ] ;

	// 三角形ポリゴンを形成する三頂点の座標の最小値
	VECTOR	MinPosition ;

	// 三角形ポリゴンを形成する三頂点の座標の最大値
	VECTOR	MaxPosition ;
} ;

unsigned short FrameIndex
　ポリゴンが含まれるメッシュを持っているフレームの番号です。
　すべてのポリゴンはどれかのメッシュに含まれていて、 すべてのメッシュはどれかのフレームに含まれているので、 この変数の値が不定になることはありません。

unsigned short MaterialIndex
　ポリゴンが使用しているマテリアルの番号です。

int VIndexTarget
　VIndex 配列が示すインデックスの参照先を表す番号が代入されています。
　ライブラリ内部で使用されている変数なので、通常ではこの値を利用することはありません。

int VIndex[ 3 ] 　三角形ポリゴンを形成する三頂点の番号です。
　例えば０番目のポリゴンで使用されている三頂点の座標を取得したい場合は以下のように記述します。


VECTOR Position[ 3 ] ;

Position[ 0 ] = PolygonList.Vertexs[ PolygonList.Polygons[ 0 ].VIndex[ 0 ] ].Position ;
Position[ 1 ] = PolygonList.Vertexs[ PolygonList.Polygons[ 0 ].VIndex[ 1 ] ].Position ;
Position[ 2 ] = PolygonList.Vertexs[ PolygonList.Polygons[ 0 ].VIndex[ 2 ] ].Position ;

VECTOR MinPosition
　ポリゴンを形成する三頂点の座標の最小値です。
　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最小値となります。

VECTOR MaxPosition
　ポリゴンを形成する三頂点の座標の最大値です。
　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最大値となります。

　尚、参照用メッシュの情報を構築する処理はそれなりに負荷の高い処理ですので、 頂点座標変換を行う設定にした場合でも MV1SetPosition や MV1SetAttachAnimTime などで状態を変更しただけでは参照用メッシュの頂点座標と頂点法線は更新されません。
　状態を変更した後に MV1RefreshReferenceMesh 関数で明示的に参照用メッシュをする必要がありますのでご注意ください。

サンプル

　　モデルファイル SimpleModel.mqo 全体の参照用メッシュを構築したあと、ポリゴン一枚一枚の座標を利用して
　モデルのワイヤーフレームを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int i ;
	MV1_REF_POLYGONLIST RefPoly ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// ３Ｄモデルを見える位置に移動する
	MV1SetPosition( ModelHandle, VGet( 320.0f, 300.0f, 600.0f ) ) ;

	// モデル全体の参照用メッシュを構築
	MV1SetupReferenceMesh( ModelHandle, -1, TRUE ) ;

	// 参照用メッシュ情報の取得
	RefPoly = MV1GetReferenceMesh( ModelHandle, -1, TRUE ) ;

	// ポリゴンの数だけ繰り返し
	for( i = 0 ; i DrawLine3D(
			RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
			RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
			GetColor( 255,255,0 ) ) ;

		DrawLine3D(
			RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
			RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
			GetColor( 255,255,0 ) ) ;

		DrawLine3D(
			RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
			RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
			GetColor( 255,255,0 ) ) ;
	}

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int MV1TerminateReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;

概略 参照用メッシュの後始末をする

引数   int MHandle ： モデルのハンドル
int FrameIndex ： 参照用メッシュの後始末を行うフレームの番号
int IsTransform ： 後始末の対象の参照用メッシュ
　　( TRUE：頂点座標変換を施した参照用メッシュ　FALSE：頂点座標変換を施さない参照用メッシュ )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )用に構築した参照用メッシュの後始末を行います。

　この関数を使用して明示的に参照用メッシュを破棄しなくても、 MV1DeleteModel や DxLib_End が呼ばれた際にモデル情報と参照用メッシュの後始末は行われますので、 この関数を使用する機会はあまり無いかもしれません。

　尚、MV1SetupReferenceMesh で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。

サンプル

　　ありません



宣言 int MV1RefreshReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;

概略 参照用メッシュを更新する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： 参照用メッシュを更新するフレームの番号
int IsTransform ： 更新する参照用メッシュは頂点座標変換を施したものかどうか
　　　　　　( TRUE：変換を施したもの FALSE：変換を施していないもの )
戻り値 　０：成功
　 －１：エラー発生

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )の参照用メッシュを更新します。

　モデルを動かさない場合は参照用メッシュを更新する必要はありませんが、 動くモデルをコリジョンポリゴンとして使用している場合はこの関数を使用して明示的にコリジョン情報を更新する必要があります。 ( 更新しない場合は最後に更新した状態のままとなります )

　尚、MV1SetupReferenceMesh で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。

サンプル

　　モデルファイル SimpleModel.mqo の０番目のフレームの参照用メッシュを構築したあと、上下にモデルを移動しながら
　ポリゴン一枚一枚の座標を利用して０番目のフレームのワイヤーフレームを描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int ModelHandle ;
	int Add, y, i ;
	MV1_REF_POLYGONLIST RefPoly ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() MV1LoadModel( "SimpleModel.mqo" ) ;

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// ０番目のフレームの参照用メッシュを構築
	MV1SetupReferenceMesh( ModelHandle, 0, TRUE ) ;

	// モデルの進行方向をセット
	Add = 8 ;

	// モデルの移動位置をセット
	y = 0 ;

	// ウインドウが閉じられるか何かキーが押されるまでループ
	while( ProcessMessage() == 0 && CheckHitKeyAll() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// ３Ｄモデルの移動位置を上下に移動させる
		y += Add ;
		if( y  600 )
			Add = -Add ;

		// ３Ｄモデルを移動する
		MV1SetPosition( ModelHandle, VGet( 320.0f, y, 600.0f ) ) ;

		// ０番目のフレームの参照用メッシュを更新する
		MV1RefreshReferenceMesh( ModelHandle, 0, TRUE ) ;

		// ０番目のフレームの参照用メッシュの取得
		RefPoly = MV1GetReferenceMesh( ModelHandle, 0, TRUE ) ;

		// ポリゴンの数だけ繰り返し
		for( i = 0 ; i DrawLine3D(
				RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
				RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
				GetColor( 255,255,0 ) ) ;

			DrawLine3D(
				RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
				RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
				GetColor( 255,255,0 ) ) ;

			DrawLine3D(
				RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
				RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
				GetColor( 255,255,0 ) ) ;
		}

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 MV1_REF_POLYGONLIST MV1GetReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;

概略 参照用メッシュを取得する

引数   int MHandle ： モデルのハンドル
int FrameIndex ： 参照用メッシュを取得するフレームの番号
int IsTransform ： 取得する参照用メッシュは頂点座標変換を施したものかどうか
　　　　　　( TRUE：変換を施したもの FALSE：変換を施していないもの )
戻り値 参照用メッシュを参照するための構造体

解説  　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )の参照用メッシュを取得します。
( この関数で参照用メッシュの構造体を取得する場合は、対象となるフレーム( 若しくはモデル全体 )に対して事前に MV1SetupReferenceMesh を呼んで準備を行っておく必要があります、 また、MV1SetupReferenceMesh で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )

　この関数の戻り値である MV1_REF_POLYGONLIST の詳細は MV1SetupReferenceMesh 関数の解説を参照してください。

サンプル

　MV1SetupReferenceMesh関数 のサンプル、又は MV1RefreshReferenceMesh関数 のサンプルを参照してください。



-------------------------------------------------------------------------------
戻る
