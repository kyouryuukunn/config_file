TITLE : ＤＸライブラリ置き場　リファレンスページ

入力関係の関数

　　ジョイパッド入力関連関数

宣言 int GetJoypadNum( void ) ;

概略 ジョイパッドが接続されている数を取得する

引数 なし
戻り値 接続されているジョイパッドの数

解説  　ジョイパッドがパソコンに接続されている数を取得します。

サンプル

　ありません



宣言 int GetJoypadInputState( int InputType ) ;

概略 ジョイパッドの入力状態を得る

引数  InputType : 入力状態を取得するパッドの識別子
　　　　　　　　DX_INPUT_KEY_PAD1　　: キー入力とパッド１
　　　　　　　　DX_INPUT_PAD1　　　　: パッド１
　　　　　　　　DX_INPUT_PAD2　　　　: パッド２
　　　　　　　　DX_INPUT_PAD3　　　　: パッド３
　　　　　　　　DX_INPUT_PAD4　　　　: パッド４
　　　　　　　　DX_INPUT_KEY　　　　 : キー入力

戻り値 パッドの入力状態

解説  　指定した識別子のパッドの入力状態が返ります。
　入力状態取得タイプにキー入力とありますがこれはパッドとキー入力を別々に取得するのは面倒かなと思いつけた機能です、 DX_INPUT_KEY_PAD1 を指定するとキー入力と（キー入力のパッド入力の対応は以下の通り）パッド１の入力状態を得ることが出来ます。
　DX_INPUT_KEY は下記の対応表のキー入力部のみの入力状態を得ます。
　入力状態は int型 データとして返り、 次に示すパッドの入力マスクを戻り値とAND演算をして結果が０でなければそのボタンが押されている事を示します。

PAD_INPUT_DOWN　 // ↓チェックマスク(下キー or テンキーの２キー)
PAD_INPUT_LEFT　 // ←チェックマスク(左キー or テンキーの４キー)
PAD_INPUT_RIGHT　 // →チェックマスク(右キー or テンキーの６キー)
PAD_INPUT_UP　 // ↑チェックマスク(上キー or テンキーの８キー)
PAD_INPUT_1　 // 1ボタンチェックマスク(Ｚキー)
PAD_INPUT_2　 // 2ボタンチェックマスク(Ｘキー)
PAD_INPUT_3　 // 3ボタンチェックマスク(Ｃキー)
PAD_INPUT_4　 // 4ボタンチェックマスク(Ａキー)
PAD_INPUT_5　 // 5ボタンチェックマスク(Ｓキー)
PAD_INPUT_6　 // 6ボタンチェックマスク(Ｄキー)
PAD_INPUT_7　 // 7ボタンチェックマスク(Ｑキー)
PAD_INPUT_8　 // 8ボタンチェックマスク(Ｗキー)
PAD_INPUT_9　 // 9ボタンチェックマスク(ＥＳＣキー)
PAD_INPUT_10　 // 10ボタンチェックマスク(スペースキー)
PAD_INPUT_28　 // こんな感じで28番目のボタンまで対応しています(初期状態では11番以降はキーボードキーとの対応はありません)



例 パッド１の上ボタンが押されているか調べる



	if( ( GetJoypadInputState( DX_INPUT_PAD1 ) & PAD_INPUT_UP ) == 0 )
	{
		// 押されていない
	}
	else
	{
		// 押されている
	}


≪余談≫

　この関数には秘密があります。
　実はこの関数は返される値の各ビットが各ボタンに対応していて最大で ２８個のボタンの状態を調べることが出来ます。
各ビットの構成は以下のようになっています。
　ビットが１になっていれば押されていることを示し、０の場合はおされて いないことを示しています。


(MSB)上位ビット　　　　　　　　　　(LSB)下位ビット
BBBBBBBBBBBBBBBBBBBBBBBBBBBBURLD

D・L・R・U：それぞれ方向キー下・左・右・上　　B:ボタン


　つまり下ボタンの状態を知りたい場合は



	int DownState ;
	int InputState ;

	InputState = GetJoypadInputState( DX_INPUT_PAD1 ) ;
	DownState = InputState & 1 ;


　とし、DownState が０でなければ下キーが押されていることを示します。
　１６個目のボタンの状態を知りたい場合は



	int ButtomState ;
	int InputState ;

	InputState = GetJoypadInputState( DX_INPUT_PAD1 ) ;
	ButtomState = InputState & 0x80000 ;


　とし、ButtomState が０でなければ１６個目のボタンが押されていること になります。
　もし DX_INPUT_KEY_PAD1 又は DX_INPUT_KEY としても当然キーボードの 入力が反映されるのは１４ビット目までで、１４ビット以上のビットは ジョイスティックのボタン入力のみの入力状態となります。

サンプル

　パッド１の9ボタン（ＥＳＣキー）が押されるまで待つ
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	int Cr , PadInput ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// 白色の値を取得
	Cr = GetColor( 255 , 255 , 255 ) ;

	// 文字列の描画
	DrawString( 150 , 240 - 32 , "パッドのSTARTボタンを押してください" , Cr );

	// パッド１の9ボタンの入力待ち
	PadInput = GetJoypadInputState( DX_INPUT_KEY_PAD1 ) ;
	while( ( PadInput & PAD_INPUT_9 ) == 0 )
	{
		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			 break ;	// エラーが発生したらループを抜ける
		}

		// パッド１の入力を取得
		PadInput = GetJoypadInputState( DX_INPUT_KEY_PAD1 ) ;
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int GetJoypadAnalogInput( int *XBuf , int *YBuf , int InputType) ;

概略 ジョイパッドのアナログ的なレバー入力情報を得る

引数  int *XBuf : パッドレバーの左右の入力状態を格納する int 型変数のアドレス
int *YBuf : パッドレバーの上下の入力状態を格納する int 型変数のアドレス
InputType : 入力状態を取得するパッドの識別子
　　　　　　　　DX_INPUT_PAD1　　　　: パッド１
　　　　　　　　DX_INPUT_PAD2　　　　: パッド２
　　　　　　　　DX_INPUT_PAD3　　　　: パッド３
　　　　　　　　DX_INPUT_PAD4　　　　: パッド４

戻り値 　０：成功
　 －１：エラー発生

解説  　アナログジョイパッドは『どれだけ左にレバーを倒しているか』 などの『倒している』『倒していない』の２種類では表現できない 細かい入力が可能となっています。
　この関数はその細かい入力状態を得るためにあります。XBufに 指定されたアドレスにはレバーの左右の入力状態を -1000 から 1000 までの数値で表現されたものが格納されます。値はマイナスの 場合はレバーは左側に倒されていることをを示し、プラスの場合は 右側に倒していることを示します。つまり -1000 だった場合は 一番左にレバーは倒されていることを示し、1000 だった場合は その逆、と言うことになります。
　YBufに指定されたアドレスにはレバーの上下(前後)の入力状態を 格納します、格納される値は同じく -1000 から 1000 までの間で マイナスの場合はレバーは上に倒されていることを、プラスの場合は 下に倒されていることを示します。よって -1000 の場合は…と言う わけです。

　なお、アナログ的な入力ではないジョイパッドの場合はおそらく 0 か -1000 又は 1000 の値が常に格納されると思われます。
サンプル

　ジョイパッドのアナログ的入力状態を画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			 LPSTR lpCmdLine, int nCmdShow )
{
	int Cr ;
	int InputX , InputY ;
	char String[ 64 ] ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// 描画先画面を裏画面にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 白色の値を取得
	Cr = GetColor( 255 , 255 , 255 ) ;

	// ＥＳＣキーが押されるまでループ
	while( ( GetJoypadInputState( DX_INPUT_KEY_PAD1 ) & PAD_INPUT_9 ) == 0 )
	{
		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			 break ;	// エラーが発生したらループを抜ける
		}

		// パッド１の入力を取得
		GetJoypadAnalogInput( &InputX , &InputY , DX_INPUT_KEY_PAD1 ) ;

		// 画面に入力状態を表示する
		{
			ClearDrawScreen() ;

			wsprintf( String , "X = %d" , InputX ) ;
			DrawString( 0 , 0 , String , Cr ) ;

			wsprintf( String , "Y = %d" , InputY ) ;
			DrawString( 0 , 16 , String , Cr ) ;
		}

		// 裏画面の内容を表画面に反映させる
		ScreenFlip() ;
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int SetJoypadInputToKeyInput( int InputType, int PadInput, int KeyInput1, int KeyInput2, int KeyInput3, int KeyInput4 ) ;

概略 　ジョイパッドの入力に対応したキーボードの入力を設定する

引数  InputType : キーとの対応設定を変更するパッドの識別子
　　　　　　　　DX_INPUT_PAD1　　　　: パッド１
　　　　　　　　DX_INPUT_PAD2　　　　: パッド２
　　　　　　　　DX_INPUT_PAD3　　　　: パッド３
　　　　　　　　DX_INPUT_PAD4　　　　: パッド４
PadInput : 設定を変更するパッドのボタン( PAD_INPUT_1 等 )
KeyInput1 : 対応させるキーその１( KEY_INPUT_Z 等 )
KeyInput2 : 対応させるキーその２( 無用な場合は -1 を渡してください )
KeyInput3 : 対応させるキーその３( 無用な場合は -1 を渡してください )
KeyInput4 : 対応させるキーその４( 無用な場合は -1 を渡してください )
戻り値 　０：成功
　 －１：エラー発生

解説  　GetJoypadInputState は例えば

GetJoypadInputState( DX_INPUT_KEY_PAD1 ) ;

　を実行した場合、キーの入力もパッドの入力として取得することができますが、 　DX_INPUT_KEY_PAD1 を渡した際のキーとパッドの入力の対応は、パッドの１ボタン＝Ｚキー、２ボタン＝Ｘキー・・・となっています。

　１０年以上前のＰＣゲームからＺキーが決定や攻撃ボタンとして使われてはいますが、ときにこの設定を変更したくなることがあると思います。 また、パッド２や３に対応するキーを設定したくなることもあると思います。
　そんなときに使用するのがこの関数です。

　この関数ではパッドの入力に対応したキーボード側の入力を設定することができます。
　例えばキーボードのＧキーを押したときにパッド１のＡボタンが押されたことにしたいときは

SetJoypadInputStateToKeyInput( DX_INPUT_PAD1, PAD_INPUT_1, KEY_INPUT_G, -1, -1, -1 ) ;

　を実行します。これを実行した後は、

GetJoypadInputState( DX_INPUT_KEY_PAD1 ) ;

　としたときに、Ｇキーが押されていれば、PAD_INPUT_1 が返ってくるようになります。

　ではパッド２以降は設定した後 GetJoypadInputState に何を渡せば良いんだ？という話ですが、 こちらは

GetJoypadInputState( DX_INPUT_PAD2 | DX_INPUT_KEY ) ;

という風に、渡す引数に DX_INPUT_KEY を論理和させて下さい。 ( パッド１も GetJoypadInputState( DX_INPUT_PAD1 | DX_INPUT_KEY ) ; でもＯＫです )

　なお、対応するキーの設定を４つもできるようにしているのは、 方向ボタンのように十字キーとテンキーどちらでも入力を対応させたいようなケースを考えてのことですので、 殆どの場合は KeyInput2 以降の３つの引数は -1 になると思います。


サンプル

　パッド１の十字ボタンに対応したキーをＩキー(上)、Ｋキー(下)、Ｊキー(左)、Ｌキー(右)にします
その後Ｉ，Ｋ，Ｊ，Ｌキーでボックスを操作できるようになります
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int x, y, input ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() 

			
-------------------------------------------------------------------------------

			


		

		

		

			
宣言 int StartJoypadVibration( int InputType, int Power, int Time ) ;


			
概略 ジョイパッドの振動を開始する


			
引数
				 InputType : 振動を開始するパッドの識別子

					　　　　　　　　DX_INPUT_PAD1　　　　: パッド１

					　　　　　　　　DX_INPUT_PAD2　　　　: パッド２

					　　　　　　　　DX_INPUT_PAD3　　　　: パッド３

					　　　　　　　　DX_INPUT_PAD4　　　　: パッド４

					Power : 振動の強さ(0～1000)

					Time : 振動させる時間(ミリ秒単位)

					　　　　-1 で StopJoypadVibration が呼ばれるまで振動し続ける


			
			
戻り値 　０：成功
			
　 －１：エラー発生


			

				 解説
				 　ジョイパッドの中には振動機能がついているものがありますが、
				この関数はその機能を使用してパッドを振動させたい時に使います。

				　振動機能のないパッドでは当然振動しません。


				
			
		


		

			サンプル



				　パッド１を最大の振動の強さで２秒間振動させます。

			
-------------------------------------------------------------------------------



#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			 LPSTR lpCmdLine, int nCmdShow )
{
	// ＤＸライブラリ初期化処理
	if( DxLib_Init() == -1 )
		 return -1;	// エラーが起きたら直ちに終了

	// 振動開始
	StartJoypadVibration( DX_INPUT_PAD1, 1000, 2000 ) ;

	// ２秒間経過するまで待つ
	WaitTimer( 2000 ) ;

	// ＤＸライブラリ使用の終了処理
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int StopJoypadVibration( int InputType ) ;

概略 ジョイパッドの振動を停止する

引数  InputType : 振動を停止するパッドの識別子
　　　　　　　　DX_INPUT_PAD1　　　　: パッド１
　　　　　　　　DX_INPUT_PAD2　　　　: パッド２
　　　　　　　　DX_INPUT_PAD3　　　　: パッド３
　　　　　　　　DX_INPUT_PAD4　　　　: パッド４
戻り値 　０：成功
　 －１：エラー発生

解説  　StartJoypadVibration関数で開始した振動を停止します。
　ただ、StartJoypadVibration 関数でも時間指定で自動的に振動を止めることは出来るので、 主に StartJoypadVibration 関数の時間指定で -1 を指定した場合に使用します。
サンプル

　ありません



　　マウス入力関連関数

宣言 int SetMouseDispFlag( int DispFlag );

概略 マウスカーソルの表示設定フラグのセット

引数  DispFlag : 　マウスの表示の有無を示すフラグ、TRUEで表示し、
　　　　　　　FALSEで表示をしない。
戻り値 　０：成功
　 －１：エラー発生

解説  　マウスカーソルの表示の有無を設定します。TRUEで表示し、 FALSEで表示しません（デフォルトではFALSE）。
　マウスを使用したプログラムを作成する場合マウスカーソルが 見えなくては話にならないのでこの関数で見えるようにします。

サンプル

　マウスカーソルを表示状態にする
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// マウスを表示状態にする
	SetMouseDispFlag( TRUE ) ;

	// キー入力を待つ(『WaitKey』を使用)
	WaitKey() ;

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int GetMousePoint( int *XBuf, int *YBuf );

概略 マウスカーソルの位置を取得する

引数  XBuf ,YBuf :　マウスカーソル現在地のX座標とY座標を保存する
　　　　　　int型変数のポインタ
戻り値 　０：成功
　 －１：エラー発生

解説  　マウスカーソルの画面上での座標をXBufとYBufの示すint型変数 に格納します。ボタンを押した瞬間マウスがどこにいたか、等を 得るのに使用します。

サンプル

　マウスの座標を画面に表示する
-------------------------------------------------------------------------------


#include "DxLib.h"
#include <stdlib.h>

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	char StrBuf[ 128 ] , StrBuf2[ 32 ];
	int MouseX , MouseY ;
	int StringCr , BoxCr ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// マウスを表示状態にする
	SetMouseDispFlag( TRUE ) ;

	// 白色の値を取得
	StringCr = GetColor( 255 , 255 , 255 ) ;

	// 黒の値を取得
	BoxCr = GetColor( 0 , 0 , 0 ) ;

	// キーが押されるまでループ
	while( CheckHitKeyAll() == 0 )
	{
		// マウスの位置を取得
		GetMousePoint( &MouseX , &MouseY ) ;

		// 表示する文字列を作成
		{
			lstrcpy( StrBuf , "座標 Ｘ" ) ; // 文字列"座標 Ｘ"をStrBufにコピー	
			itoa( MouseX , StrBuf2 , 10 ) ; // MouseXの値を文字列にしてStrBuf2に格納
			lstrcat( StrBuf , StrBuf2 ) ; // StrBufの内容にStrBuf2の内容を付け足す
			lstrcat( StrBuf , "　Ｙ " ) ; // StrBufの内容に文字列"　Ｙ "を付け足す
			itoa( MouseY , StrBuf2 , 10 ) ; // MouseYの値を文字列にしてStrBuf2に格納
			lstrcat( StrBuf , StrBuf2 ) ; // StrBufの内容にStrBuf2の内容を付け足す
		}

		// 画面左上の領域に黒い四角を描き前に描いてあった
		// 文字列を消す
		DrawBox( 0 , 0 , 200 , 32 , BoxCr , TRUE ) ;

		// 座標文字列を描く
		DrawString( 0 , 0 , StrBuf , StringCr ) ;
				
		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			break ;	// エラーが起きたらループを抜ける
		}

		// 一定時間待つ
		WaitTimer( 100 ) ;
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int SetMousePoint( int PointX , int PointY );

概略 マウスカーソルの位置をセットする

引数 PointX , PointY : 新しいマウスカーソルの位置
戻り値 　０：成功
　 －１：エラー発生

解説  　マウスカーソルの位置を( PointX , PointY )の示す座標に 移動します、この関数を使うとマウスカーソルは強制的に 指定の座標の移動する事になります。

サンプル

　１秒経つごとにマウスカーソルが指定の座標に戻されてしまうプログラム
-------------------------------------------------------------------------------


#include "DxLib.h"
#include <stdlib.h>

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			 LPSTR lpCmdLine, int nCmdShow )
{
	int Count ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// マウスを表示状態にする
	SetMouseDispFlag( TRUE ) ;

	// 現在のカウンタ値を得る『GetNowCount』関数使用
	Count = GetNowCount() ;

	// キーが押されるまでループ
	while( CheckHitKeyAll() == 0 )
	{
		// 前回のカウンタ参照から１秒たっているか判定
		if( GetNowCount() - Count > 1000 )
		{
			// 経っていたらマウスの位置を画面左上に移動

			// マウスの位置をセット
			SetMousePoint( 0 , 0 ) ;

			// 現在のカウンタ値を得る
			Count = GetNowCount() ;
		}

		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			break ;	// エラーが起きたらループを抜ける
		}
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int GetMouseInput( void ) ;

概略 マウスカーソルのボタンの状態を得る

引数 なし
戻り値 マウスの入力状態値

解説  　マウスの入力状態値を得ます。
　戻り値を以下に示す定義値とＡＮＤ演算し、結果が０で なければそのボタンが押されている事になります。

MOUSE_INPUT_LEFT　　： マウス左ボタン
MOUSE_INPUT_RIGHT　 ： マウス右ボタン
MOUSE_INPUT_MIDDLE　： マウス中央ボタン

例
　　左ボタンが押されているか調べる


	
	if( ( GetMouseInput() & MOUSE_INPUT_LEFT ) != 0 )
	{
		// 押されている
	}
	else
	{
		// 押されていない
	}



　尚、マウスのボタンが４ボタン以上ある場合は、以下の定義値とＡＮＤ演算することで ４ボタン以上のボタンの押下状態を得ることが出来ます。

MOUSE_INPUT_4　： マウス４ボタン
MOUSE_INPUT_5　： マウス５ボタン
MOUSE_INPUT_6　： マウス６ボタン
MOUSE_INPUT_7　： マウス７ボタン
MOUSE_INPUT_8　： マウス８ボタン

サンプル

　マウス右ボタンが押されるまで待つ
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	int MouseInput ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// マウスを表示状態にする
	SetMouseDispFlag( TRUE ) ;

	// マウスの入力を待つ
	MouseInput = GetMouseInput() ;
	while( ( MouseInput & MOUSE_INPUT_RIGHT ) == 0 )
	{
		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			break ;	// エラーが起きたらループから抜ける
		}

		// マウスの入力を得る
		MouseInput = GetMouseInput() ;
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int GetMouseWheelRotVol( void ) ;

概略 マウスホイールの回転量を得る

引数 なし
戻り値 マウスの入力状態値

解説  　前回この関数が呼ばれてから今回この関数が呼ばれるまでにマウスホイールが回転した量を得ます。
　手前に回した分はマイナスの値として、奥に回した分はプラスの値として返ってきます。
サンプル

　何かキーが押されるまで回転量の合計を画面に表示し続けます。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	int Rot ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
		 return -1;	// エラーが起きたら直ちに終了

	// 裏画面を使用
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// 合計値を初期化
	Rot = 0 ;

	// 何かキーが押されるまでループ
	while( CheckHitKeyAll() == 0 )
	{
		// メッセージ処理
		if( ProcessMessage() == -1 ) break ;	// エラーが起きたらループから抜ける

		// 前回 GetMouseWheelRotVol が呼ばれてから今回までの回転量を足す
		Rot += GetMouseWheelRotVol() ;

		// 画面を初期化
		ClearDrawScreen() ;

		// 画面に回転量を描画
		DrawFormatString( 0, 0, GetColor( 255,255,255 ), "%d", Rot ) ;

		// 裏画面の内容を表画面に表示
		ScreenFlip() ;
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------



　　キーボード入力関連関数

宣言 int CheckHitKeyAll( void ) ;

概略 すべてのキーの押下状態を取得する（キーの特定はできない）

引数 なし
戻り値 　０：成功
　 －１：エラー発生

解説  　すべてのキーのどれかが押されているか判定し、結果を返します
　この関数で特定のキーを判定する事は出来ません。特定のキー入力を 判定するには次のCheckHitKey関数を使用してください。

サンプル

　キー入力があるまで待つ
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	int Cr ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// 白色の値を取得
	Cr = GetColor( 255 , 255 , 255 ) ;

	// 文字列の描画
	DrawString( 200 , 240 - 32 , "キーを押してください" , Cr );

	// キーの入力待ち
	while( CheckHitKeyAll() == 0 )
	{
		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			 break ;	// エラーが発生したらループを抜ける
		}
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int CheckHitKey( int KeyCode ) ;

概略 特定キーの入力状態を得る

引数 KeyCode　:　入力状態を取得するキーコード
戻り値 １：押されている
　 ０：押されていない

解説  　特定のキーの入力状態を得ます。例えば『Ｉ』キーの入力状態を 調べたい場合は『CheckHitKey( KEY_INPUT_I )』として関数を呼び ます。
　この『KEY_INPUT_I』はマクロを使用して定義したもので、すべての キーに対してこのような選別子が定義されています。
　それを以下に記します。多いです

KEY_INPUT_BACK  // バックスペースキー
KEY_INPUT_TAB  // タブキー
KEY_INPUT_RETURN  // エンターキー

KEY_INPUT_LSHIFT  // 左シフトキー
KEY_INPUT_RSHIFT  // 右シフトキー
KEY_INPUT_LCONTROL  // 左コントロールキー
KEY_INPUT_RCONTROL  // 右コントロールキー
KEY_INPUT_ESCAPE  // エスケープキー
KEY_INPUT_SPACE  // スペースキー
KEY_INPUT_PGUP  // ＰａｇｅＵＰキー
KEY_INPUT_PGDN  // ＰａｇｅＤｏｗｎキー
KEY_INPUT_END  // エンドキー
KEY_INPUT_HOME  // ホームキー
KEY_INPUT_LEFT  // 左キー
KEY_INPUT_UP  // 上キー
KEY_INPUT_RIGHT  // 右キー
KEY_INPUT_DOWN  // 下キー
KEY_INPUT_INSERT  // インサートキー
KEY_INPUT_DELETE  // デリートキー

KEY_INPUT_MINUS  // －キー
KEY_INPUT_YEN  // ￥キー
KEY_INPUT_PREVTRACK  // ＾キー
KEY_INPUT_PERIOD  // ．キー
KEY_INPUT_SLASH  // ／キー
KEY_INPUT_LALT  // 左ＡＬＴキー
KEY_INPUT_RALT  // 右ＡＬＴキー
KEY_INPUT_SCROLL  // ScrollLockキー
KEY_INPUT_SEMICOLON  // ；キー
KEY_INPUT_COLON  // ：キー
KEY_INPUT_LBRACKET  // ［キー
KEY_INPUT_RBRACKET  // ］キー
KEY_INPUT_AT  // ＠キー
KEY_INPUT_BACKSLASH  // ＼キー
KEY_INPUT_COMMA  // ，キー
KEY_INPUT_CAPSLOCK  // CaspLockキー
KEY_INPUT_PAUSE  // PauseBreakキー

KEY_INPUT_NUMPAD0  // テンキー０
KEY_INPUT_NUMPAD1  // テンキー１
KEY_INPUT_NUMPAD2  // テンキー２
KEY_INPUT_NUMPAD3  // テンキー３
KEY_INPUT_NUMPAD4  // テンキー４
KEY_INPUT_NUMPAD5  // テンキー５
KEY_INPUT_NUMPAD6  // テンキー６
KEY_INPUT_NUMPAD7  // テンキー７
KEY_INPUT_NUMPAD8  // テンキー８
KEY_INPUT_NUMPAD9  // テンキー９
KEY_INPUT_MULTIPLY  // テンキー＊キー
KEY_INPUT_ADD  // テンキー＋キー
KEY_INPUT_SUBTRACT  // テンキー－キー
KEY_INPUT_DECIMAL  // テンキー．キー
KEY_INPUT_DIVIDE  // テンキー／キー
KEY_INPUT_NUMPADENTER  // テンキーのエンターキー

KEY_INPUT_F1  // Ｆ１キー
KEY_INPUT_F2  // Ｆ２キー
KEY_INPUT_F3  // Ｆ３キー
KEY_INPUT_F4  // Ｆ４キー
KEY_INPUT_F5  // Ｆ５キー
KEY_INPUT_F6  // Ｆ６キー
KEY_INPUT_F7  // Ｆ７キー
KEY_INPUT_F8  // Ｆ８キー
KEY_INPUT_F9  // Ｆ９キー
KEY_INPUT_F10  // Ｆ１０キー
KEY_INPUT_F11  // Ｆ１１キー
KEY_INPUT_F12  // Ｆ１２キー

KEY_INPUT_A  // Ａキー
KEY_INPUT_B  // Ｂキー
KEY_INPUT_C  // Ｃキー
KEY_INPUT_D  // Ｄキー
KEY_INPUT_E  // Ｅキー
KEY_INPUT_F  // Ｆキー
KEY_INPUT_G  // Ｇキー
KEY_INPUT_H  // Ｈキー
KEY_INPUT_I  // Ｉキー
KEY_INPUT_J  // Ｊキー
KEY_INPUT_K  // Ｋキー
KEY_INPUT_L  // Ｌキー
KEY_INPUT_M  // Ｍキー
KEY_INPUT_N  // Ｎキー
KEY_INPUT_O  // Ｏキー
KEY_INPUT_P  // Ｐキー
KEY_INPUT_Q  // Ｑキー
KEY_INPUT_R  // Ｒキー
KEY_INPUT_S  // Ｓキー
KEY_INPUT_T  // Ｔキー
KEY_INPUT_U  // Ｕキー
KEY_INPUT_V  // Ｖキー
KEY_INPUT_W  // Ｗキー
KEY_INPUT_X  // Ｘキー
KEY_INPUT_Y  // Ｙキー
KEY_INPUT_Z  // Ｚキー
KEY_INPUT_0  // ０キー
KEY_INPUT_1  // １キー
KEY_INPUT_2  // ２キー
KEY_INPUT_3  // ３キー
KEY_INPUT_4  // ４キー
KEY_INPUT_5  // ５キー
KEY_INPUT_6  // ６キー
KEY_INPUT_7  // ７キー
KEY_INPUT_8  // ８キー
KEY_INPUT_9  // ９キー


例　ＥＳＣキーが押されているか調べる



	if( CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
	{
		// 押されていない
	}
	else
	{
		// 押されている
	}



サンプル

　Ｚキーが押されるまで待つ
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	int Cr ;

	if( DxLib_Init() == -1 )	// ＤＸライブラリ初期化処理
	{
		 return -1;	// エラーが起きたら直ちに終了
	}

	// 白色の値を取得
	Cr = GetColor( 255 , 255 , 255 ) ;

	// 文字列の描画
	DrawString( 230 , 240 - 32 , "Ｚキーを押してください" , Cr );

	// Ｚキーの入力待ち
	while( CheckHitKey( KEY_INPUT_Z ) == 0 )
	{
		// メッセージ処理
		if( ProcessMessage() == -1 )
		{
			 break ;	// エラーが発生したらループを抜ける
		}
	}

	DxLib_End() ;		// ＤＸライブラリ使用の終了処理

	return 0 ;		// ソフトの終了
}

-------------------------------------------------------------------------------


宣言 int GetHitKeyStateAll( char *KeyStateBuf ) ;

概略 キーボードのすべてのキーの押下状態を取得する

引数 char *KeyStateBuf : すべてのキーの押下状態を格納するバッファのポインタ
戻り値 　０：成功
　 －１：エラー発生

解説  　CheckHitKey 関数はキーボードのキーの押下状態を取得するため の関数です。
　沢山のキーの状態を CheckHitKey 関数で調べる場合は当たり前 ですが沢山 CheckHitKey 関数を使わなければなりません。
　ですが、実は CheckHitKey 関数はとても無駄の多い関数です。
理由は聞かないで下さい。とにかく無駄が多い関数なのです。
　ですから複数のキーの状態を一度に知りたい場合は、 CheckHitKey 関数 よりこの GetHitKeyStateAll 関数を使ってください。この関数は すべてのキーについて CheckHitKey 関数を使った場合と同じものを 一度に配列に格納してくれます。

例　Z キーの状態を知りたい場合


char Buf[ 256 ] ;

GetHitKeyStateAll( Buf ) ;

if( Buf[ KEY_INPUT_Z ] == 1 )
{
	// Ｚキーが押されている
}
else
{
	// Ｚキーは押されていない
}

　使うにはまず char 型変数 256 個の配列を宣言します。必ず char 型で、数は 256 個でないといけません。
　そしてその配列のポインタをおもむろに GetHitKeyStateAll 関数 に渡します。そうすると GetHitKeyStateAll 関数は char 型配列に すべてのキーの押下状態を格納してくれます。
　あとは CheckHitKey 関数で知りたいキーを識別するために使って いた KEY_INPUT_Y や KEY_INPUT_ESCAPE 等を関数に渡した配列の 要素番号にして、その要素が１かそれ意外か判断するだけです。 １なら押されていて、０だと押されていません。これだけです。
　何が便利か、といわれますと、CheckHitKey より手続きが面倒に なったので何も便利になっているわけではないのですが、とりあえず 処理速度の効率を気にされる場合は是非使ってください。(^^;

　なお、キーの識別値一覧はすぐ上の CheckHitKey 関数の解説に 載っています。

サンプル

　ＣとＫとＹのキーを一度に押すまで終了しないプログラムです。当然 CheckHitKey 関数でも同じことは出来ます。
-------------------------------------------------------------------------------


#include "DxLib.h"

#define PI	3.1415926535897932384626433832795f

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
									 LPSTR lpCmdLine, int nCmdShow )
{
	char KeyBuf[ 256 ] ;

	// ＤＸライブラリ初期化処理
	if( DxLib_Init() == -1 ) return -1;

	// メッセージの表示
	DrawString( 0 , 0 , " C と K と Y のキーを同時に押したら終了します ", GetColor( 255 , 255 , 255 ) ) ;

	// 無限ループ
	while( 1 )
	{
		// すべてのキーの状態を得る
		GetHitKeyStateAll( KeyBuf ) ;

		// ＣとＫとＹのキーが押されていたらループから抜ける
		if( KeyBuf[ KEY_INPUT_C ] == 1 &&
			KeyBuf[ KEY_INPUT_K ] == 1 &&
			KeyBuf[ KEY_INPUT_Y ] == 1 )
		{
			break ;
		}

		// Windows 依存のメッセージ処理を行う
		if( ProcessMessage() == -1 ) break ;
	}

	// ＤＸライブラリ使用の終了処理
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


　　半角文字入力関連関数

宣言  char GetInputChar( int DeleteFlag ) ;

概略 文字入力バッファに溜まった文字データから１文字取得する

引数  int DeleteFlag : 取得した文字をバッファから削除するか、フラグ
　　　　　　　　　　　　　　( TRUE: 削除　　FALSE : 削除しない )
戻り値 ０　：文字入力バッファには何もデータがない
それ以外：文字コード又は操作コード

　　　　操作コード
　　　　CTRL_CODE_BS : バックスペース
　　　　　　　　CTRL_CODE_TAB : タブ
　　　　　　　　CTRL_CODE_CR : 改行
　　　　　　　　CTRL_CODE_DEL : ＤＥＬキー

　　　　　　　　CTRL_CODE_LEFT : ←キー
　　　　　　　　CTRL_CODE_RIGHT : →キー
　　　　　　　　CTRL_CODE_UP : ↑キー
　　　　　　　　CTRL_CODE_DOWN : ↓キー
　　　　　　　　CTRL_CODE_ESC : ＥＳＣキー
　　　　　　　　CTRL_CODE_CMP : 操作コード敷居値

解説  　キーボードの押下状態は CheckHitKey 関数で調べることが出来 ます、ですが CheckHitKey 関数は『今このキーが押されているか』 という情報を知りたい場合には便利ですが、『なんの文字が入力され たか』という情報を取得したい場合には大変不都合です。
　そこで登場するのがこの関数です。

　ＤＸライブラリは内部で CheckHitKey 関数などによるキーボードの 直接的な押下状態の取得以外に、『なんの文字が入力されたか』と いう情報を随時保存しています。
　保存された入力データは、この GetInputChar 関数などで明示的に 利用者がデータを取得されない限り保持されつづけます(限界は ありますが…) このデータを保存する領域を 文字入力バッファ と呼びます。

　この関数はその文字入力バッファに溜まったデータの内のもっとも 古い入力文字１文字を返します、DeleteFlag は取得した文字を 文字入力バッファから削除するかどうかを指定するフラグで、TRUE の場合 削除され、FALSE の場合は削除されません、削除されない場合は次に この関数が呼ばれた時も前回と同じ文字データが返されます。 　何故こんなフラグが存在するのか、というのは意外と使って行く内に 欲しくなってくると思ったからです。

　なお文字入力バッファには文字データだけが保存されるわけでは ありません、一部の操作コードも保存されます。そのコードは上記の通り、 #define により宣言された数値です。
　戻り値が操作コードなのか、文字コードなのかを判断するには戻り値が CTRL_CODE_CMP の値との大小で判断することが出来ます。

　戻り値 >=　CTRL_CODE_CMP　:　文字コード
　戻り値 　戻り値 == 0　　　　　　　　:　入力データ無し

　ちなみに、なにも文字が入力されず、文字入力バッファになにも 文字がない場合は０が返されます。

サンプル

画面中央に入力された文字を随時表示します
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			LPSTR lpCmdLine, int nCmdShow )
{
	char String[ 2 ] ;
	char InputChar ;

	// 画面モードの設定
	SetGraphMode( 640 , 480 , 16 ) ;

	// ＤＸライブラリ初期化処理
	if( DxLib_Init() == -1 )
	{
		// エラーが起きたら直ちに終了
		return -1;
	}
	
	// 入力される文字を随時画面中央に描画します
	{
		String[ 1 ] = 0 ;

		// ＥＳＣキーが押されるか、何らかの内部エラーが発生するまでループする
		while( !ProcessMessage() && ( CheckHitKey( KEY_INPUT_ESCAPE ) == 0 ) )
		{
			// 文字入力バッファから文字を取得する
			InputChar = GetInputChar( TRUE ) ;

			// 操作コード以外の文字入力があった場合のみ表示処理を行う
			if( InputChar != 0 && InputChar >= CTRL_CODE_CMP )
			{
				// 画面の消去
				ClearDrawScreen() ;

				// 文字の保存
				String[ 0 ] = InputChar ;

				// 描画
				DrawString( 312 , 232 , String , GetColor( 255 , 255 , 255 )  ) ;
			}
		}
	}

	// ＤＸライブラリ使用の終了処理
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言  char GetInputCharWait( int DeleteFlag ) ;

概略  　文字入力バッファに溜まった文字データから１文字取得する、 バッファになにも文字コードがない場合はキーが押されるまで待つ

引数  int DeleteFlag : 取得した文字をバッファから削除するか、フラグ
　　　　　　　　　　　　　　( TRUE: 削除　　FALSE : 削除しない )
戻り値 ０　：文字入力バッファには何もデータがない
それ以外：文字コード又は操作コード

　　　　操作コード
　　　　CTRL_CODE_BS : バックスペース
　　　　　　　　CTRL_CODE_TAB : タブ
　　　　　　　　CTRL_CODE_CR : 改行
　　　　　　　　CTRL_CODE_DEL : ＤＥＬキー

　　　　　　　　CTRL_CODE_LEFT : ←キー
　　　　　　　　CTRL_CODE_RIGHT : →キー
　　　　　　　　CTRL_CODE_UP : ↑キー
　　　　　　　　CTRL_CODE_DOWN : ↓キー
　　　　　　　　CTRL_CODE_ESC : ＥＳＣキー
　　　　　　　　CTRL_CODE_CMP : 操作コード敷居値

解説  　GetInputChar 関数の文字が入力されるまで待つ、バージョン です。それ以外は GetInputChar 関数と全く同じなので GetInputChar 関数の 解説を参照して下さい。

サンプル

ありません



宣言  int ClearInputCharBuf( void ) ;

概略  　文字入力バッファをクリアする

引数  なし
戻り値 ０　：成功
－１：エラー発生

解説  　GetInputChar 関数で取得できる文字入力バッファのデータを初期化します。
　この関数は、例としてアクションゲームのネームエントリーに GetInputChar 関数を 利用しようとした場合、ゲームプレイ中も滅茶苦茶にテンキーやショットキーを押すので 文字入力バッファは滅茶苦茶な文字のデータが溢れています。
　この状態で GetInputChar 関数で入力文字を取得した場合、ゲーム中に操作のために 押していたキーの文字データが延々と吐き出されるわけです。
　これではこまるのでネームエントリー処理前にこの関数で文字入力バッファを初期化 するわけです。

サンプル

ありません



　　日本語入力関連関数

宣言  int KeyInputString( int x , int y ,
　　　　　　　　　　　　int CharMaxLength , char *StrBuffer ,
　　　　　　　　　　　　int CancelValidFlag ) ;

概略 キーボードによる文字列入力

引数  int x , y　　　　　　　　: 入力中の文字列を描画する領域の左上座標
int CharMaxLength　: 入力できる最大文字数(全角文字は2文字とする)
char *StrBuffer 　　: 入力した文字列を保存するバッファへのアドレス
int CancelValidFlag : 　入力中のＥＳＣキーによるキャンセルが可能か
　　　　　　　　　　　　　否か(TRUE:可能 FALSE:不可能)
戻り値 １　：問題なく入力を終了
２　：入力はキャンセルされた
－１：エラー発生

解説  　キーボードによる文字列の入力を行います。引数 x , y を起点に入力中の文字列が 表示されます。
　エンターキーを押すと入力が終了したとみなされ入力された文字列は StrBuffer の 示すアドレスに格納されます。なお入力できる最大文字数は CharMaxLength で指定し ます。バッファ領域には CharMaxLength の分の文字が入る領域を確保しておかなけれ ばなりません。
　CancelValidFlag はキャンセルを有効にするかどうかというもので、これを TRUE に すると有効になり、FALSE にするとキャンセルは出来なくなります。キャンセル が有効な場合は ESC キーを押すと関数から出てきます。その場合は戻り値が２になります。

サンプル

名前を聞いてくるので名前を入力します。その後それを表示するだけのプログラムです。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		 LPSTR lpCmdLine, int nCmdShow )
{
	char Name[ 31 ] ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() == -1 ) return -1 ;

	// 名前入力指示文字列の描画
	DrawString( 0 , 0 , "名前を入力してください" , GetColor( 255 , 255 , 255 ) ) ;

	// 名前の入力
	KeyInputString( 0 , 16 , 30 , Name , FALSE ) ;

	// 画面の初期化
	ClearDrawScreen() ;

	// 名前の表示
	DrawString( 0 , 0 , "あなたの名前は" , GetColor( 255 , 255 , 255 ) ) ;
	DrawString( 0 , 16 , Name ,  GetColor( 255 , 255 , 255 ) ) ;
		
	// キー入力待ち	
	WaitKey() ;

	// ＤＸライブラリの使用終了
	DxLib_End() ;

	// 終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言  int KeyInputSingleCharString( int x , int y , int CharMaxLength ,
　　　　　　　　　　　　　　　　　 char *StrBuffer , int CancelValidFlag ) ;

概略 キーボードによる半角文字列のみの入力

引数  int x , y : 入力中の文字列を描画する領域の左上座標
int CharMaxLength : 入力できる最大文字数(全角文字は2文字とする)
char *StrBuffer : 入力した文字列を保存するバッファへのアドレス
int CancelValidFlag : 入力中のＥＳＣキーによるキャンセルが可能か否か(TRUE:可能 FALSE:不可能)
戻り値 １　：問題なく入力を終了
　 ２　：入力はキャンセルされた
　 －１：エラー発生

解説  　KeyInpurString の半角文字列のみを入力できるようにしたものです。 漢字やひらがななどの２バイト文字は入力することが出来ません。
その他の動作は KeyInputString と同じものです。

サンプル

名前を英字で入力するよう聞いてきます。入力後、それを画面に表示します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			LPSTR lpCmdLine, int nCmdShow )
{
	char Name[ 31 ] ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() == -1 ) return -1 ;
		
	// 名前入力指示文字列の描画
	DrawString( 0 , 0 , "名前を英字で入力してください" , GetColor( 255 , 255 , 255 ) ) ;

	// 名前の入力
	KeyInputSingleCharString( 0 , 16 , 30 , Name , FALSE ) ;

	// 画面の初期化
	ClearDrawScreen() ;

	// 名前の表示
	DrawString( 0 , 0 , "あなたの名前は" , GetColor( 255 , 255 , 255 ) ) ;
	DrawString( 0 , 16 , Name ,  GetColor( 255 , 255 , 255 ) ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの使用終了
	DxLib_End() ;

	// 終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言  int KeyInputNumber( int x , int y , int MaxNum , int MinNum ,
　　　　　　　　　　　　　 int CancelValidFlag ) ;

概略 キーボードによる数値の入力

引数  int x , y : 入力中の文字列を描画する領域の左上座標
int MaxNum , MinNum : 入力する数値の最大値と最小値
int CancelValidFlag : 入力中のＥＳＣキーによるキャンセルが可能か
　　　　　　　　　　　　　　　否か(TRUE:可能 FALSE:不可能)
戻り値 MaxNum + 1 の値 : 処理はキャンセルされた
　 MinNum - 1 の値 : エラー発生
　 上記以外の値 : 正常に入力して得た数値

解説  　キーボードによる数値入力を行います。入力中の文字列は x , y を 起点とした領域に描画されます。
　この関数のみ入力した数値が直接返ってきます。　

サンプル

描画する線の長さを入力し、その後その長さの線を描画します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		LPSTR lpCmdLine, int nCmdShow )
{
	int LineLength ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() == -1 ) return -1 ;

	// 線の長さ入力指示文字列の描画
	DrawString( 0 , 0 , "線の長さを入力してください(０～６４０)" , GetColor( 255 , 255 , 255 ) ) ;

	// 線の長さ入力
	LineLength = KeyInputNumber( 0 , 16 , 640 , 0 , FALSE ) ;

	// 画面の初期化
	ClearDrawScreen() ;

	// 線の描画
	DrawLine( 0 , 100 , LineLength , 100 , GetColor( 255 , 255 , 255 ) ) ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの使用終了
	DxLib_End() ;

	// 終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言  int SetKeyInputStringColor( int NmlStr , int NmlCur ,
　　　　　　　　　　　　　　　　　　　int IMEStr , int IMECur ,
　　　　　　　　　　　　　　　　　　　int IMELine , int IMESelectStr ,
　　　　　　　　　　　　　　　　　　　int IMEModeStr , int NmlStrE ,
　　　　　　　　　　　　　　　　　　　int IMESelectStrE , int IMEModeStrE ,
　　　　　　　　　　　　　　　　　　　int IMESelectWinE , int IMESelectWinF ) ;

概略 KeyInputString系 関数使用時の文字の各色を変更する

引数  int NmlStr : 入力文字列の色
int NmlCur : ＩＭＥ非使用時のカーソルの色
int IMEStr : ＩＭＥ使用時の入力文字列の色
int IMECur : ＩＭＥ使用時のカーソルの色
int IMELine : ＩＭＥ使用時の変換文字列の下線
int IMESelectStr : ＩＭＥ使用時の選択対象の変換候補文字列の色
int IMEModeStr : ＩＭＥ使用時の入力モード文字列の色(『全角ひらがな』等)
int NmlStrE : 入力文字列の縁の色
int IMESelectStrE : ＩＭＥ使用時の選択対象の変換候補文字列の縁の色
int IMEModeStrE : ＩＭＥ使用時の入力モード文字列の縁の色
int IMESelectWinE : ＩＭＥ使用時の変換候補ウインドウの縁の色
int IMESelectWinF : ＩＭＥ使用時の変換候補ウインドウの下地の色
戻り値 　０：成功
　 －１：エラー発生

解説  　KeyInputString , KeyInputSingleCharString 等の キーボードデータ入力関数中で表示される文字その他の色を変更します。 設定する色については GetColor 関数で取得できる色コードを 使用します。
　格引数については上記の説明文を参考にして下さい。

サンプル

　ありません



宣言  int MakeKeyInput( int MaxStrLength , int CancelValidFlag ,
　　　　　　　　　　　int SingleCharOnlyFlag , int NumCharOnlyFlag ) ;

概略 新しいキー入力データの作成

引数  int MaxStrLength : 入力できる最大文字数(半角文字単位)
int CancelValidFlag : ESCキーによるキャンセル機能の有無(TRUE:有 FALSE:無)
int SingleCharOnlyFlag : 半角文字のみの入力か否か(TRUE:半角文字のみ
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　FALSE:フラグ無効)
int NumCharOnlyFlag : 数値文字のみの入力か否か(TRUE:数字文字のみ
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　FALSE:フラグ無効)
戻り値 －１　　　　　　　　　：エラー発生
　 それ以外の数値　：キー入力ハンドル(識別番号)

解説  　この関数から以下のすべての関数は上記の直接的な文字列入力関数 とは違い、すべてこの関数で得られる『キー入力ハンドル』という 識別番号を使用してキー入力を行うための関数となります。
　そもそもＤＸライブラリを使用したソフトでチャットソフトを作成する となると、キー入力を常に受けつけながら相手から送信されたメッセージ をいつでも受け取れるようにしなくてはならないので、そのようなキー入力 では上記の KeyInputString 等のキー入力が終了するまで関数から処理が 抜けないタイプの関数では対応できません。
　そこでキー入力は勝手にやらせておいて、それとは別に相手からメッセ ージが来た場合はすぐに画面に表示するような処理をするためにキー入力 ハンドルというものを使用したキー入力手段を用意しました。

　その方法を以下に示します。

１．MakeKeyInput で目的に合ったキー入力ハンドルを作成

２．SetActiveKeyInput 作成したキー入力ハンドルをアクティブにする、 以降キーの入力はアクティブにしたキー入力ハンドルが受け持つデータ 領域に流れます。

３．CheckKeyInput でキー入力が終了したか調べる、終っていないうちは DrawKeyInputString でキー入力の途中経過を画面の好きなところに 描画する。
　必要であれば現在の入力モードを DrawKeyInputModeString を使用 して描画する。

４．キー入力が終っていたら GetKeyInputString 又は GetKeyInput Number で入力結果の文字列(又は数値)を得る

５．DeleteKeyInput で作成したキー入力ハンドルを削除する

　ここでは最初の MakeKeyInput 関数について、この関数では作成した キー入力ハンドルで入力できる文字の数をまず MaxStrLength で指定します、 単位は半角文字単位で日本語のひらがな・漢字などは半角でいう２文字にな りますので注意してください。
　次に CancelValidFlag は入力にキャンセルを有効にするかどうか、です。 有効にした場合は ＥＳＣ キーを押すことによって入力はキャンセルされます。 キャンセルされたのか、正常に入寮が終了したのかは (6-19)CheckKeyInput 関数に よって知ることが出来ます。なお有効にする場合は TRUE , しない場合は FALSE をセットします。
　次に SingleCharOnlyFlag ですがこれは日本語文字などのいわゆる２バイト 文字(全角文字)の入力を出来ないようにするか、否かのパラメータです。これを 有効( TRUE )にすると日本語の入力をしようとしてもはじかれます。有効にしな い場合は FALSE にします。
　最後に NumCharOnlyFlag は半角の数字文字のみを入力できるようにするか、 を指定するパラメータです。これを TRUE にすることによって半角の 0 から 9 までの文字しか入力できなくなります。１６進数でいえば a から f もあるの ですがＤＸライブラリでは１６進数は対応していません。無効にする場合は FALSE です。
　このように指定して関数を呼ぶとキー入力ハンドルの作成に成功すれば戻り値 としてハンドルとなる int 型の数値が得られます。以降この数値はキー入力 終了時まで必要となるので保存しておきます。

サンプル

KeyInputString と同じことをキー入力ハンドルを使用して実現します。
-------------------------------------------------------------------------------


#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
		LPSTR lpCmdLine, int nCmdShow )
{
	char String[ 256 ] ;
	int InputHandle ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() == -1 ) return -1 ;

	// 描画先を裏にする
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キー入力ハンドルを作る(キャンセルなし全角文字有り数値入力じゃなし)
	InputHandle = MakeKeyInput( 50 , FALSE , FALSE , FALSE ) ;

	// 作成したキー入力ハンドルをアクティブにする
	SetActiveKeyInput( InputHandle ) ;

	// キー入力終了待ちループ
	// (ProcessMessageをループごとに行う)
	while( !ProcessMessage() )
	{
		// 入力が終了している場合は終了
		if( CheckKeyInput( InputHandle ) != 0 ) break ;

		// 画面の初期化
		ClearDrawScreen() ;

		// 入力モードを描画
		DrawKeyInputModeString( 640 , 480 ) ; 

		// 入力途中の文字列を描画
		DrawKeyInputString( 0 , 0 , InputHandle ) ;

		// 裏画面の内容を表画面に反映させる
		ScreenFlip() ;
	}

	// 入力された文字列を取得
	GetKeyInputString( String , InputHandle ) ;

	// 用済みのインプットハンドルを削除する
	DeleteKeyInput( InputHandle ) ;

	// 画面の初期化
	ClearDrawScreen() ;

	// 入力された文字列を画面に表示する
	DrawString( 0 , 0 , "あなたが入力した文字列は" , GetColor( 255 , 255 , 255 ) ) ;
	DrawString( 0 , 16 , String , GetColor( 255 , 255 , 255 ) ) ;

	// 裏画面の内容を表画面に反映させる
	ScreenFlip() ;

	// キー入力待ち
	WaitKey() ;

	// ＤＸライブラリの使用終了
	DxLib_End() ;

	// 終了
	return 0 ;
}

-------------------------------------------------------------------------------


宣言 int DeleteKeyInput( int InputHandle ) ;

概略 キー入力データの削除

引数 int InputHandle : 削除するキー入力ハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　MakeKeyInput 関数で作成したキー入力ハンドルを削除します。
　以降削除したキー入力ハンドルは無効となります。

サンプル

MakeKeyInput 関数のサンプルを参考にして下さい



宣言 int InitKeyInput( void ) ;

概略 すべてのキー入力データの削除

引数 なし
戻り値 　０：成功
　 －１：エラー発生

解説  　MakeKeyInput 関数で作成したキー入力ハンドルをすべて削除します。

サンプル

　ありません。



宣言 int SetActiveKeyInput( int InputHandle ) ;

概略 指定のキー入力をアクティブにする

引数 int InputHandle : アクティブにするキー入力ハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　指定した MakeKeyInput で作成したキー入力ハンドルをアクティブ にします。アクティブになったキー入力ハンドルは以降キーボードの 入力データを受けることになります。
　アクティブにすることの出来るキー入力ハンドルは常に一つで、指定の キー入力ハンドルをアクティブにする以前にアクティブになっていたキー 入力ハンドルは非アクティブになります。
　これは当然ですが一度に複数のキー入力先に入力が出来ても意味がないか らです。

　なお、キー入力が終了しているキー入力ハンドルを指定すると終了状態が 初期化され、再び入力出来るようにすることが出来ます。

サンプル

MakeKeyInput 関数のサンプルを参照して下さい。



宣言 int CheckKeyInput( int InputHandle ) ;

概略 入力が終了しているか取得する

引数 int InputHandle : キー入力ハンドル
戻り値 ０　：キー入力はまだ完了もキャンセルもされていない
　 １　：キー入力は正常に終了した
　 ２　：キー入力はキャンセルされた
　 －１：エラー発生

解説  　MakeKeyInput で作成したキー入力が終了したか、キャンセルされたか まだ入力中か、の情報を得ます。戻り値による状態は上記の通りです。

サンプル

MakeKeyInput 関数のサンプルを参照して下さい



宣言 int DrawKeyInputString( int x , int y , int InputHandle ) ;

概略 キー入力中データの描画

引数  int x , y : 入力中の文字列を描画する座標
int InputHandle : 入力中文字列を描画したいキー入力のハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　MakeKeyInput で作成したキー入力の途中経過を画面に描画する 際に使用します。この関数は描画する文字列が画面端までいって しまった場合自動的に改行されますので、SetDrawArea 関数で 描画可能領域を変更することによって好きな領域に文字列を収める ことが出来ます。

サンプル

MakeKeyInput 関数のサンプルを参照して下さい



宣言 int DrawKeyInputModeString( int x , int y ) ;

概略 入力モード文字列を描画する

引数 int x , y : 入力モードを描画する座標
戻り値 　０：成功
　 －１：エラー発生

解説  　キーボード入力の入力モード文字列を描画します。入力モード文字列とは 『ひらがな』や『全角英数』とうです。ＩＭＥを使用していない場合は なにも描画されません。

サンプル

　MakeKeyInput 関数のサンプルを参考にして下さい



宣言 int SetKeyInputString( char *String , int InputHandle ) ;

概略 キー入力データに指定の文字列をセットする

引数  char *String : セットする文字列があるアドレス
int InputHandle : セットするキー入力のハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　MakeKeyInput 関数で作成したキー入力の入力中文字列を String で指定するアドレスにある文字列に置き換えます。
試しに MakeKeyInput 関数のサンプル



	// 作成したキー入力ハンドルをアクティブにする
	SetActiveKeyInput( InputHandle ) ;

	// キー入力終了待ちループ
	// (ProcessMessageをループごとに行う)
	while( !ProcessMessage() )


の部分を



	// 作成したキー入力ハンドルをアクティブにする
	SetActiveKeyInput( InputHandle ) ;

	SetKeyInputString( "ここに文章を入力してください" , InputHandle ) ;

	// キー入力終了待ちループ
	// (ProcessMessageをループごとに行う)
	while( !ProcessMessage() )


に変更してみてください

サンプル

　特に有りません



宣言 int SetKeyInputNumber( int Number , int InputHandle ) ;

概略 キー入力データに指定の数値を文字に置き換えてセットする

引数  int Number : セットする数字となる数値
int InputHandle : 数字をセットするキー入力のハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　SetKeyInputString の数字バージョンです。 Number に 希望の数値を入れると、自動的に文字に変換され入力中の文字列と 置き替わります。
試しに MakeKeyInput 関数のサンプル



	// 作成したキー入力ハンドルをアクティブにする
	SetActiveKeyInput( InputHandle ) ;

	// キー入力終了待ちループ
	// (ProcessMessageをループごとに行う)
	while( !ProcessMessage() )


の部分を



	// 作成したキー入力ハンドルをアクティブにする
	SetActiveKeyInput( InputHandle ) ;

	SetKeyInputNumber( 1234568 ,InputHandle ) ;

	// キー入力終了待ちループ
	// (ProcessMessageをループごとに行う)
	while( !ProcessMessage() )


に変更してみてください

サンプル

　特に有りません



宣言 int GetKeyInputString( char *StrBuffer , int InputHandle ) ;

概略 入力データの文字列を取得する

引数  char *StrBuffer : 文字列を格納するバッファのアドレス
int InputHandle : 入力データ文字列が欲しいキー入力のハンドル
戻り値 　０：成功
　 －１：エラー発生

解説  　キー入力中、又は終了したキー入力文字列を取得するための関数です。
　キー入力がされた結果はこの関数を持って得ることが出来ます。

サンプル

　MakeKeyInput のサンプルを参考にして下さい



宣言 int GetKeyInputNumber( int InputHandle ) ;

概略 入力データの文字列を数値として取得する

引数 int InputHandle : 数値を得たいキー入力のハンドル
戻り値 　入力された文字列を数値に変換したもの。
　 (故にエラーが発生したかどうかを判断する術はありません)

解説  　入力中、または入力が終了したキー入力文字列を数値に変換して 得ます。入力された文字列の中に数字以外のものが含まれていると 必ず０が返されます。
　のでこの関数を使用するキー入力は MakeKeyInput でキー入力 ハンドルを作成する再に NumCharOnlyFlag を TRUE にして有効に しておくことを推奨します。

サンプル

　特に有りません




-------------------------------------------------------------------------------
戻る
