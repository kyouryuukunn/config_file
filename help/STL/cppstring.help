?? TITLE : C++文字列(std::string)

cppreference.com -> C++文字列

C++文字列(std::string)

コンストラクタ  文字列を初期化するメソッド
演算子  比較、および文字列の割り当てを行う
append()  文字列の後ろに他の文字列を追加する
assign()  文字列にテキストを割り当てる
at()  指定されたインデックスの文字を返す
begin()  最初の文字を示すイテレータを返す
c_str()  C言語形式の文字配列を返す
capacity()  文字列が格納できる文字数を返す
compare()  ２つの文字列を比較する
copy()  文字列の中に文字列をコピーする
data()  最初の文字へのポインタを返す
empty()  文字列が空の時にtrueを返す
end()  文字列の最後を指すイテレータを返す
erase()  文字列の一部分を削除する
find()  与えられた文字列を検索する
find_first_of()  与えられた文字列を検索し、一番最初の要素のインデックスを返す
find_first_not_of()  与えられた文字列の中の文字ではない最初の要素のインデックスを返す
find_last_of()  文字列の中から文字を検索し、一番最後の要素のインデックスを返す
find_last_not_of()  与えられた文字列の中の文字ではない最後の要素のインデックスを返す
get_allocator()  文字列のアロケータを返す
insert()  文字列の中に他の文字列を挿入する
length()  文字列の長さを返す
max_size()  文字列が保持することができる最大の長さを返す
rbegin()  文字列の最後を示すリバースイテレータを返す
rend()  文字列の最初を示すリバースイテレータを返す
replace()  文字列の中の文字を置換する
reserve()  文字を格納する容量を確保する
resize()  文字列の大きさを変更する
rfind()  与えられた文字列を検索し、最後の要素のインデックスを返す
size()  文字列の文字数を返す
substr()  文字列の一部を新しい文字列オブジェクトとしてコピーする
swap()  ２つの文字列を交換する


-------------------------------------------------------------------------------------- 



?? TITLE : C++文字列

cppreference.com -> C++文字列 -> 詳細

C++文字列

-------------------------------------------------------------------------------

コンストラクタ

文法:



  string();
  string( size_type 長さ, char 文字 );
  string( const char *文字列 );
  string( const char *文字列, size_type 長さ );
  string( string &文字列, size_type インデックス, size_type 長さ );
  string( input_iterator コピー元の最初のイテレータ, input_iterator コピー元の最後のイテレータ );


新しい文字列を以下のような様々な方法で構築する:

  * 文字 を長さ 分コピーする
  * 文字列 を複製する。オプションで複製する文字列の長さ を指定できる
  * 他の文字列 のインデックス から始まり、長さ の大きさを持つ部分文字列の複製をする
  * コピー元の最初のイテレータ からコピー元の最後のイテレータ の間の要素をコピーする

サンプル:


    string str1( 5, 'c' );
    string str2( "Now is the time..." );
    string str3( str2, 11, 4 );
    cout << str1 << endl;
    cout << str2 << endl;
    cout << str3 << endl;

表示:


    ccccc
    Now is the time...
    time
    

-------------------------------------------------------------------------------

演算子

文法:



  ==
  >
  <
  >=
  <=
  !=
  +
  +=
  []


==, >, <, >=, <=, !=の各演算子を使用して文字列の比較を行うことができる。また、+演算子や+=演算子を用いて文字列を結合することができる。 []演算子を使用して特定の箇所の文字を参照することができる。

関連トピック
at(), compare().
-------------------------------------------------------------------------------

append

文法:



  basic_string &append( const basic_string &文字列 );
  basic_string &append( const char *文字列 );
  basic_string &append( const basic_string &文字列, size_type インデックス, size_type 長さ );
  basic_string &append( const char *文字列, size_type 文字数 );
  basic_string &append( size_type 文字数, char 文字 );
  basic_string &append( input_iterator コピー元の最初のイテレータ, input_iterator コピー元の最後のイテレータ );


関数は以下のような様々な方法で文字列を追加する:

  * 現在の文字列の後ろに文字列 を追加する
  * 文字列 のインデックス から始まり長さ の大きさを持つ部分文字列を現在の文字列の後ろに追加する
  * 文字列 のうちの最初の文字数 を現在の文字列の後ろに追加する
  * 文字 を文字数 分繰り返して現在の文字列の後ろに追加する
  * コピー元の最初のイテレータ とコピー元の最後のイテレータ の間の要素を現在の文字列の後ろに追加する

サンプルコード:


    string str = "Hello World";
    str.append( 10, '!' );
    cout << str << endl;

表示


    Hello World!!!!!!!!!!

関連トピック
+ 演算子
-------------------------------------------------------------------------------

assign

文法:



  basic_string &assign( const basic_string &文字列 );
  basic_string &assign( const char *文字列 );
  basic_string &assign( const char *文字列, size_type 文字数 );
  basic_string &assign( const basic_string &文字列, size_type インデックス, size_type 長さ );
  basic_string &assign( size_type 文字数, char 文字 );


この関数は以下のような様々な方法で文字列を割り当てる:

  * 現在の文字列に文字列 を割り当てる
  * 文字数 分の文字列 を現在の文字列に割り当てる
  * 与えられた 文字列 のうち、インデックス と長さ で指定された部分文字列を現在の文字列に割り当てる
  * 文字 を文字数 分繰り返して現在の文字列に割り当てる

サンプルコード:


    string str1, str2 = "War and Peace";
    str1.assign( str2, 4, 3 );  
    cout << str1 << endl;

表示:


    and
    

-------------------------------------------------------------------------------

at

文法:



  reference at( size_type インデックス );


at()関数はインデックス で指定された文字への参照を返す。 もしインデックス が文字列の範囲を超えていた場合にはout_of_rangeクラスのオブジェクトを範囲外アクセスのエラーを例外として報告する。


    string text = "ABCDEF";
    char ch = text.at( 2 );

文字'C'が得られる

関連トピック
[]演算子
-------------------------------------------------------------------------------

begin

文法:



  iterator begin();


begin()関数は現在の文字列の最初の要素を指すイテレータを返す。

関連トピック
end()
-------------------------------------------------------------------------------

c_str

文法:



  const char *c_str();


c_str()関数は、現在の文字列を指す、C言語方式の文字列のポインタを返す。

関連トピック
[]
-------------------------------------------------------------------------------

capacity

文法:



  size_type capacity();


capacity()関数は現在の文字列がメモリ割り当てを追加で行わなくても格納可能な文字のサイズを返す。この数値はsize()の返値よりも大きいことが保証されている。

関連トピック
max_size(), reserve(), resize(), size(),
-------------------------------------------------------------------------------

compare

文法:



  int compare( const basic_string &文字列 );
  int compare( const char *文字列 );
  int compare( size_type インデックス, size_type 長さ, const basic_string &文字列 );
  int compare( size_type インデックス, size_type 長さ, const basic_string &文字列, size_type インデックス2,
  size_type 長さ2 );
  int compare( size_type インデックス, size_type 長さ, const char *文字列, size_type 長さ2 );


compare()関数は文字列 との比較で様々な結果を返す。

返値 場合
負 自分 < 比較対象
ゼロ 自分 == 比較対象
正 自分 > 比較対象

また、この関数は以下のようなさまざまな形式での比較を行う。

  * 文字列 と現在の文字列を比較する
  * 文字列 の中のインデックス と長さ で指定される部分文字列と現在の文字列を比較する
  * 部分文字列同士を比較する。文字列 の中のインデックス2 と長さ2 で示される部分文字列と、現在の文字列の中のインデックス と長さ で示される部分文字列を比較する。
  * 部分文字列同士を比較する。文字列 の最初から長さ2 までの部分文字列と、現在の文字列の中のインデックス と長さ で示される部分文字列を比較する

関連トピック
演算子
-------------------------------------------------------------------------------

copy

文法:



  size_type copy( char *文字列, size_type 文字数, size_type インデックス );


copy()関数は現在の文字列のインデックス で始まる文字数 分の文字を文字列 にコピーする。返値はコピーした文字数である。

-------------------------------------------------------------------------------

data

文法:



  const char *data();


data()関数は現在の文字列の最初の文字を示すポインタを返す。

関連トピック
c_str()
-------------------------------------------------------------------------------

empty

文法:



  bool empty();


empty()関数は文字列が空の時にtrue を返す。そうでない場合にはfalse を返す。

-------------------------------------------------------------------------------

end

文法:



  iterator end();


end()関数は現在の文字列の最後を指すイテレータを返す。

関連トピック
begin()
-------------------------------------------------------------------------------

erase

文法:



  iterator erase( iterator 位置 );
  iterator erase( iterator 消去開始位置, iterator 消去終了位置 );
  basic_string &erase( size_type インデックス = 0, size_type 文字数 = 最後 );


erase()関数は以下のような動作をする:

  * 位置 で表される文字を消去し、次の文字を指す を返す
  * 消去開始位置 と消去終了位置 の間の文字列を削除し、削除された文字の次を指すイテレータを返す
  * 現在の文字列のインデックス で表される部分から文字数 分の文字を削除し、現在の文字列を表す*thisを返す。

インデックス と文字数 はデフォルトの値を持っている。そのため、インデックス だけを指定した場合にはそこから最後の文字までを削除する。インデックスも省略した場合にはすべての文字を削除する。サンプル:


    string s("So, you like donuts, eh? Well, have all the donuts in the world!");
    cout << "オリジナルの文字列は '" << s << "'" << endl;
  
    s.erase( 50, 14 );
    cout << "現在の状態は '" << s << "'" << endl;

    s.erase( 24 );
    cout << "現在の状態は '" << s << "'" << endl;

    s.erase();
    cout << "現在の状態は '" << s << "'" << endl;

このように表示される


    オリジナルの文字列は 'So, you like donuts, eh? Well, have all the donuts in the world!'
    現在の状態は 'So, you like donuts, eh? Well, have all the donuts'
    現在の状態は 'So, you like donuts, eh?'
    現在の状態は ''

-------------------------------------------------------------------------------

find

文法:



  size_type find( const basic_string &文字列, size_type インデックス );
  size_type find( const char *文字列, size_type インデックス );
  size_type find( const char *文字列, size_type インデックス, size_type 長さ );
  size_type find( char 文字, size_type インデックス );


find()関数は以下のような様々な方法で検索を行う:

  * 現在の文字列のインデックス 番目の文字から検索を開始し、最初に文字列 が現れた場所を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から検索を開始し、長さ 分の大きさを持つ 文字列 が最初に現れる位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字 が最初に現れる位置を返す。見つからない場合にはstring::nposを返す

サンプル:


    string str1( "Alpha Beta Gamma Delta" );
    unsigned int loc = str1.find( "Omega", 0 );
    if( loc != string::npos )
      cout << "Omegaの位置は " << loc << endl;
    else
      cout << "Omegaは見つかりませんでした" << endl;
    
    

-------------------------------------------------------------------------------

find_first_of

文法:



  size_type find_first_of( const basic_string &文字列, size_type インデックス = 0 );
  size_type find_first_of( const char *文字列, size_type インデックス = 0 );
  size_type find_first_of( const char *文字列, size_type インデックス, size_type 文字数 );
  size_type find_first_of( char 文字, size_type インデックス = 0 );


find_first_of()関数は以下の動作を行う。

  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字列 の中に含まれる文字が最初に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から文字数 分の範囲を検索を開始し、文字列 の中に含まれる文字が最初に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字 が最初に見つかった位置を返す。見つからない場合にはstring::nposを返す

関連トピック
find()
-------------------------------------------------------------------------------

find_first_not_of

文法:



  size_type find_first_not_of( const basic_string &文字列, size_type インデックス = 0 );
  size_type find_first_not_of( const char *文字列, size_type インデックス = 0 );
  size_type find_first_not_of( const char *文字列, size_type インデックス, size_type 文字数 );
  size_type find_first_not_of( char 文字, size_type インデックス = 0 );


find_first_not_of()は以下のような検索を行う:

  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字列 の中に含まれない文字が最初に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から文字数 分の範囲を検索を開始し、文字列 の中に含まれない文字が最初に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字 以外の文字が最初に見つかった位置を返す。見つからない場合にはstring::nposを返す

関連トピック
find()
-------------------------------------------------------------------------------

find_last_of

文法:



  size_type find_last_of( const basic_string &文字列, size_type インデックス = npos );
  size_type find_last_of( const char *文字列, size_type インデックス = npos );
  size_type find_last_of( const char *文字列, size_type インデックス, size_type 文字数 );
  size_type find_last_of( char 文字, size_type インデックス = npos );


find_last_of()関数は以下のような検索を行う:

  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字列 の中に含まれる文字が最後に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から文字数 分の範囲を検索を開始し、文字列 の中に含まれる文字が最後に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字 が最後に見つかった位置を返す。見つからない場合にはstring::nposを返す

関連トピック
find()
-------------------------------------------------------------------------------

find_last_not_of

文法:



  size_type find_last_not_of( const basic_string &文字列, size_type インデックス = npos );
  size_type find_last_not_of( const char *文字列, size_type インデックス = npos);
  size_type find_last_not_of( const char *文字列, size_type インデックス, size_type 文字数 );
  size_type find_last_not_of( char 文字, size_type インデックス = npos );


find_last_not_of() 関数は以下のような検索を行う:

  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字列 の中に含まれない文字が最後に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から文字数 分の範囲を検索を開始し、文字列 の中に含まれない文字が最後に見つかった位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から検索を開始し、文字 ではない文字が最後に見つかった位置を返す。見つからない場合にはstring::nposを返す

関連トピック
find()
-------------------------------------------------------------------------------

get_allocator

文法:



  allocator_type get_allocator();


get_allocator()関数は現在の文字列のアロケータを返す

-------------------------------------------------------------------------------

insert

文法:



  iterator insert( iterator 挿入位置, const char &文字 );
  basic_string &insert( size_type インデックス, const basic_string &文字列 );
  basic_string &insert( size_type インデックス, const char *文字列 );
  basic_string &insert( size_type インデックス1, const basic_string &文字列, size_type インデックス2, size_type 文字数 );
  basic_string &insert( size_type インデックス, const char *文字列, size_type 文字数 );
  basic_string &insert( size_type インデックス, size_type 文字数, char 文字 );
  void insert( iterator 挿入位置, size_type 文字数, const char &ch );
  void insert( iterator 挿入位置, iterator コピー元の最初, iterator コピー元の最後 );


insert()は以下のようなたくさんの目的の操作を行う:

  * 文字 を挿入位置 の直前に挿入する
  * 現在の文字列のインデックス で表される位置に文字列 を挿入する
  * インデックス2 および文字数 で示される文字列 の部分文字列を、現在の文字列のインデックス1 に挿入する
  * 文字数 分の文字列 の文字列を、現在の文字列のインデックス に挿入する
  * 文字数 個分の文字 を、現在の文字列のインデックス に挿入する
  * 文字数 個分の文字 を、現在の文字列の挿入位置 で表される文字の直前に挿入する
  * コピー元の最初 とコピー元の最後 の間の文字列を、現在の文字列の挿入位置 で表される文字の直前に挿入する

関連トピック
replace()
-------------------------------------------------------------------------------

length

文法:



  size_type length();


length() 関数は現在の文字列の長さを返す。この関数の返値はsize()と同じである。

関連トピック
size()
-------------------------------------------------------------------------------

max_size

文法:



  size_type max_size();


max_size()関数は文字列が保持することが可能な最大の文字数を返す。

-------------------------------------------------------------------------------

rbegin

文法:



  const reverse_iterator rbegin();


rbegin()関数は文字列の最後を指すリバースイテレータを返す。

関連トピック
rend()
-------------------------------------------------------------------------------

rend

文法:



  const reverse_iterator rend();


rend()関数は文字列の最初を指すリバースイテレータを返す。

関連トピック
rbegin()
-------------------------------------------------------------------------------

replace

文法:



  basic_string &replace( size_type インデックス, size_type 文字数, const basic_string &文字列 );
  basic_string &replace( size_type インデックス1, size_type 文字数1, const basic_string &文字列, size_type インデックス2,
  size_type 文字数2 );
  basic_string &replace( size_type インデックス, size_type 文字数, const char *文字列 );
  basic_string &replace( size_type インデックス, size_type 文字数1, const char *文字列, size_type 文字数2 );
  basic_string &replace( size_type インデックス, size_type 文字数1, size_type 文字数2, char 文字 );
  basic_string &replace( iterator 置換開始位置, iterator 置換終了位置, const basic_string &文字列 );
  basic_string &replace( iterator 置換開始位置, iterator 置換終了位置, const char *文字列 );
  basic_string &replace( iterator 置換開始位置, iterator 置換終了位置, const char *文字列, size_type 文字数 );
  basic_string &replace( iterator 置換開始位置, iterator 置換終了位置, size_type 文字数, char 文字 );


replace()関数は以下のように振る舞う:

  * 現在の文字列のインデックス から始まる箇所と、文字数 分の文字列 を置換する
  * 現在の文字列のインデックス1 から始まり文字数1 の部分と、インデックス2 から始まり文字数2 の文字列 部分文字列の置換をする
  * 現在の文字列のインデックス から始まり文字数 の部分と、文字列 の置換をする
  * 現在の文字列のインデックス1 から始まり文字数1 の部分と、文字数2 個分の文字 の置換を行う
  * 現在の文字列の置換開始位置 と置換終了位置 の文字列と、文字列 を置換する
  * 現在の文字列の置換開始位置 と置換終了位置 の文字列と、文字数 分の文字列 を置換する
  * 現在の文字列の置換開始位置 と置換終了位置 の文字列と、文字数 個分の文字 の置換を行う

以下のコードは "They say he carved it himself...find your soul-mate, Homer." と表示するサンプルである:


    string s = "They say he carved it himself...from a BIGGER spoon";
    string s2 = "find your soul-mate, Homer.";

    s.replace( 32, s2.length(), s2 );

    cout << s << endl;
 

関連トピック
insert()
-------------------------------------------------------------------------------

reserve

文法:



  void reserve( size_type 文字数 );


reserve() 関数は現在の文字列の許容量(capacity())を文字数 以上にする。

関連トピック
capacity()
-------------------------------------------------------------------------------

resize

文法:



  void resize( size_type 文字数 );
  void resize( size_type 文字数, char 文字 );


resize() 関数は現在の文字列を文字数 のサイズに変更する、オプションで、新たにできた空間を埋める文字 を指定することができる。

-------------------------------------------------------------------------------

rfind

文法:



  size_type rfind( const basic_string &文字列, size_type インデックス );
  size_type rfind( const char *文字列, size_type インデックス );
  size_type rfind( const char *文字列, size_type インデックス, size_type 文字数 );
  size_type rfind( char 文字, size_type インデックス );


rfind()関数は以下のような動作をする:

  * 現在の文字列のインデックス 番目の文字から逆順に検索を開始し、最後に文字列 が現れた場所を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から逆順に検索を開始し、長さ 分の大きさを持つ 文字列 が最後に現れる位置を返す。見つからない場合にはstring::nposを返す
  * 現在の文字列のインデックス 番目の文字から逆順に検索を開始し、文字 が最後に現れる位置を返す。見つからない場合にはstring::nposを返す

以下のサンプルコードでは最初にrfind()が呼ばれたときには、ターゲットとなる言葉が9文字目にあるためにstring::nposが返される。しかし、文字列の20番目までには含まれるため、二回目に呼ばれたときには9が返る。


    int loc;
    string s = "My cat's breath smells like cat food.";

    loc = s.rfind( "breath", 8 );
    cout << "The word breath is at index " << loc << endl;

    loc = s.rfind( "breath", 20 );
    cout << "The word breath is at index " << loc << endl;
 

関連トピック
find()
-------------------------------------------------------------------------------

size

文法:



  size_type size();


size() 関数は現在の文字列の文字数を返す

関連トピック
length(), max_size()
-------------------------------------------------------------------------------

substr

文法:



  basic_string substr( size_type インデックス, size_type 文字数 = npos );


substr()関数は現在の文字列のインデックス から始まり長さ の部分文字列部分文字列を返す。 文字数が省略された場合にはデフォルトとしてstring::nposが使用され、substr()関数の戻り値はインデックスから最後まで全部になる。 サンプル:


    string s("What we have here is a failure to communicate");

    string sub = s.substr(21);

    cout << "The original string is " << s << endl;
    cout << "The substring is " << sub << endl;

表示


    The original string is What we have here is a failure to communicate
    The substring is a failure to communicate

-------------------------------------------------------------------------------

swap

文法:



  void swap( basic_string &文字列 );


swap()関数は文字列 と現在の文字列を入れ替える。サンプル:


    string first( "これが最初" );
    string second( "そして二番目" );
    first.swap( second );
    cout << first << endl;
    cout << second << endl;

displays


    そして二番目
    これが最初

